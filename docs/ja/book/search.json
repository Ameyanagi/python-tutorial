[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python チュートリアル",
    "section": "",
    "text": "Python チュートリアル\n包括的な Python チュートリアルへようこそ！この本では Python の基礎から応用まで学習できます。",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#学習内容",
    "href": "index.html#学習内容",
    "title": "Python チュートリアル",
    "section": "学習内容",
    "text": "学習内容\nこのチュートリアルは様々なスキルレベルに対応し、以下の内容をカバーします：\n\n環境構築 - uv、poetry、miniforge、Git/GitHub、VS Code\nPython の基本 - 構文、データ型、制御フロー、関数\nオブジェクト指向プログラミング - クラス、継承、高度なパターン\n高度なトピック - 型ヒント、非同期プログラミング、マルチプロセシング\n実際の応用 - データサイエンス、自動化、Web 開発",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#チュートリアルの特徴",
    "href": "index.html#チュートリアルの特徴",
    "title": "Python チュートリアル",
    "section": "チュートリアルの特徴",
    "text": "チュートリアルの特徴\n\n🖥️ インタラクティブな例 - 実行結果付きのコード\n📝 演習とクイズ - 理解度をテスト\n🚀 実践プロジェクト - 実際のアプリケーションを構築\n🎯 複数の形式 - 書籍、スライド、PDF\n🌐 バイリンガル - 英語と日本語で利用可能\n\n\n\n\n\n\n\n⚡ 新機能: ライブインタラクティブ Python + ファイルアップロード\n\n\n\nこのチュートリアルは Quarto Live と Quarto Drop を搭載 - ブラウザで直接 Python コードを実行・編集でき、独自のデータファイルもアップロード可能！インストール不要で、実データを使った実践的な学習がすぐに始められます。",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#前提条件",
    "href": "index.html#前提条件",
    "title": "Python チュートリアル",
    "section": "前提条件",
    "text": "前提条件\n\n基本的なコンピュータリテラシー\n学習と実験への意欲\nPython 3.12+（インストール方法も説明します！）",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#このチュートリアルの使い方",
    "href": "index.html#このチュートリアルの使い方",
    "title": "Python チュートリアル",
    "section": "このチュートリアルの使い方",
    "text": "このチュートリアルの使い方\n\n順次学習 - 最良の結果を得るために章順に進む\nコード実践 - すべての例を自分で実行する\n演習完了 - 学習を強化する\nプロジェクト構築 - 実際の問題に知識を適用する",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#書籍チャプター",
    "href": "index.html#書籍チャプター",
    "title": "Python チュートリアル",
    "section": "📚 書籍チャプター",
    "text": "📚 書籍チャプター\nPython の旅を始める準備はできましたか？環境構築から始めましょう！",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#インタラクティブ-revealjs-スライド",
    "href": "index.html#インタラクティブ-revealjs-スライド",
    "title": "Python チュートリアル",
    "section": "🎬 インタラクティブ RevealJS スライド",
    "text": "🎬 インタラクティブ RevealJS スライド\n完全なナビゲーション機能とモバイル最適化付きプロフェッショナルプレゼンテーション：\n🎯 スライドコレクションを見る →\n\n日本語スライド (完全版利用可能)\n基本概念: - 🚀 導入とセットアップ - Python と uv を始める - 📊 データ型とコレクション - リスト、辞書、セット - 🔀 制御フロー - If/else文、ループ - ⚙️ 関数 - 再利用可能なコードブロック - 🚨 エラーハンドリング - Try/except パターン\nコード組織: - 📦 モジュールとパッケージ - コード組織 - 🏗️ クラスとオブジェクト - オブジェクト指向プログラミング - 🔗 継承 - 高度な OOP 概念 - 🏷️ 型ヒント - 現代的な Python 型システム\n高度な応用: - 📈 データサイエンス - NumPy、Pandas、機械学習 - 🌐 IoT 接続と産業プロトコル - シリアル、Modbus、InfluxDB\n\n\nEnglish スライド (完全版利用可能)\nコア Python 概念: - 🚀 Introduction & Setup - Python と uv を始める - 📊 Data Types & Collections - リスト、辞書、セット - 🔀 Control Flow - If/else文、ループ - ⚙️ Functions - 再利用可能なコードブロック - 🚨 Error Handling - Try/except パターン\nコード組織: - 📦 Modules & Packages - コード組織 - 🏗️ Classes & Objects - オブジェクト指向プログラミング - 🔗 Inheritance - 高度な OOP 概念 - 🏷️ Type Hints - 現代的な Python 型システム\n高度な応用: - 📈 Data Science - NumPy、Pandas、機械学習 - 🌐 IoT Connectivity - Serial、Modbus、InfluxDB\n\n\n🎮 RevealJS 機能:\n\nナビゲーション: 矢印キー、マウスクリック、タッチジェスチャー (iPhone 対応)\nショートカット: ESC (概要表示), F (フルスクリーン), S (発表者モード)\nインタラクティブ: チョークボード (B キー)、メニュー、プログレスバー\nモバイル: スマートフォンを含むすべてのデバイスに最適化",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#言語ナビゲーション",
    "href": "index.html#言語ナビゲーション",
    "title": "Python チュートリアル",
    "section": "🌐 言語ナビゲーション",
    "text": "🌐 言語ナビゲーション\n\n🇯🇵 日本語 (現在) - 日本語版を表示中\n🇺🇸 English版 - 英語版に切り替え\n🏠 メインランディング - ホームページに戻る\n\n\nPython を学習する準備はできましたか？ 環境構築から始めるか、上記のインタラクティブスライドを探索してください！",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "book/01-setup.html",
    "href": "book/01-setup.html",
    "title": "1  環境構築",
    "section": "",
    "text": "1.1 Python のインストール\nこの章では、モダンなツールを使用して Python 開発環境をセットアップします。適切な開発環境の構築は、Python プログラミングにおいて非常に重要です。これは、木工作業を始める前に作業場を整えるようなもので、適切なツールがあれば作業がずっと楽になります。\n最高の型ヒントサポートのために Python 3.12 以降を推奨します。Python 3.12 には重要なパフォーマンス改善と強化された型ヒントが含まれており、コードをより信頼性高く、デバッグしやすくします。これは、基本的な電卓から科学電卓にアップグレードするようなもので、より多くの機能とより高い精度を得ることができます。",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>環境構築</span>"
    ]
  },
  {
    "objectID": "book/01-setup.html#python-のインストール",
    "href": "book/01-setup.html#python-のインストール",
    "title": "1  環境構築",
    "section": "",
    "text": "1.1.1 Windows\n# winget を使用（Windows用パッケージマネージャー）\nwinget install Python.Python.3.12\n\n# Microsoft Store を使用（初心者に最も簡単）\n# Microsoft Store で \"Python 3.12\" を検索\nこれらのコマンドの動作: winget は Windows の最新パッケージマネージャーで、Python を自動的にダウンロードし、適切な PATH 設定でインストールします。Microsoft Store版は サンドボックス化されており自動更新されるため、初心者には最適です。\n\n\n1.1.2 macOS\n# Homebrew を使用（macOS用パッケージマネージャー）\nbrew install python@3.12\n\n# pyenv を使用（Python バージョン管理ツール）\npyenv install 3.12.8\npyenv global 3.12.8\nこれらのコマンドの動作: Homebrew は Python を /opt/homebrew/bin にインストールし、依存関係を自動管理します。pyenv はより高度で、複数の Python バージョンをインストールして簡単に切り替えることができます。pyenv は複数の工具箱を持っているようなもので、各プロジェクトに適した道具（Python バージョン）を選択できます。\n\n\n1.1.3 Linux\n# Ubuntu/Debian（APT パッケージマネージャーを使用）\nsudo apt update                      # パッケージリストを更新\nsudo apt install python3.12 python3.12-venv  # Python + 仮想環境サポートをインストール\n\n# Fedora（DNF パッケージマネージャーを使用）\nsudo dnf install python3.12\n\n# Arch Linux（Pacman パッケージマネージャーを使用）\nsudo pacman -S python               # 常に最新の Python をインストール\nこれらのコマンドの動作: 各 Linux ディストリビューションは異なるパッケージマネージャーを使用しますが、すべて同じ作業を行います - Python をダウンロード、インストール、設定します。sudo コマンドはシステム全体のパッケージをインストールするために必要な管理者権限を提供します。Ubuntu/Debian では仮想環境（各プロジェクト用の分離された Python 環境）を有効にするために python3.12-venv もインストールします。",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>環境構築</span>"
    ]
  },
  {
    "objectID": "book/01-setup.html#環境管理ツール",
    "href": "book/01-setup.html#環境管理ツール",
    "title": "1  環境構築",
    "section": "1.2 環境管理ツール",
    "text": "1.2 環境管理ツール\n\n1.2.1 uv (推奨)\nuv は最も高速な Python パッケージマネージャー兼環境ツールです。\n\n1.2.1.1 インストール\n# Linux/macOS\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n\n1.2.1.2 使用方法\n# プロジェクト作成\nuv init my-project\ncd my-project\n\n# 仮想環境作成\nuv venv\n\n# パッケージ追加\nuv add requests pandas\n\n# コマンド実行\nuv run python script.py\nuv run pytest\n\n\n\n1.2.2 Poetry (代替案)\nPoetry は依存関係管理とパッケージングを提供します。\n\n1.2.2.1 インストール\ncurl -sSL https://install.python-poetry.org | python3 -\n\n\n1.2.2.2 使用方法\n# プロジェクト作成\npoetry new my-project\ncd my-project\n\n# 依存関係追加\npoetry add requests pandas\n\n# 依存関係インストール\npoetry install\n\n# コマンド実行\npoetry run python script.py\n\n\n\n1.2.3 Miniforge (データサイエンス用)\nMiniforge は conda-forge をデフォルトチャネルとする conda を提供します。\n\n1.2.3.1 インストール\n# https://github.com/conda-forge/miniforge からダウンロード\n# インストールスクリプト実行\nbash Miniforge3-Linux-x86_64.sh\n\n\n1.2.3.2 使用方法\n# 環境作成\nconda create -n myenv python=3.12\nconda activate myenv\n\n# パッケージインストール\nconda install pandas numpy matplotlib",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>環境構築</span>"
    ]
  },
  {
    "objectID": "book/01-setup.html#演習",
    "href": "book/01-setup.html#演習",
    "title": "1  環境構築",
    "section": "1.3 演習",
    "text": "1.3 演習\n\nPython 3.12 をインストールしてください\nuv をインストールしてテストプロジェクトを作成してください\n仮想環境を作成して pandas を追加してください\nuv run を使用して簡単な Python スクリプトを実行してください",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>環境構築</span>"
    ]
  },
  {
    "objectID": "book/01-setup.html#次のステップ",
    "href": "book/01-setup.html#次のステップ",
    "title": "1  環境構築",
    "section": "1.4 次のステップ",
    "text": "1.4 次のステップ\n環境の準備ができたので、バージョン管理のための Git と GitHub について学びましょう。",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>環境構築</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html",
    "href": "book/02-git-github.html",
    "title": "2  Git と GitHub",
    "section": "",
    "text": "2.1 Git とは？\nGit はコードの変更を追跡し、他の人と協力するために不可欠です。このチュートリアル全体で Git を使用します。\nGit は以下の機能を持つ分散バージョン管理システムです： - コードの変更を追跡 - 以前のバージョンに戻すことが可能 - 他の開発者との協力を支援 - プロジェクトの完全な履歴を保持",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#git-のインストール",
    "href": "book/02-git-github.html#git-のインストール",
    "title": "2  Git と GitHub",
    "section": "2.2 Git のインストール",
    "text": "2.2 Git のインストール\n\n2.2.1 Windows\n# winget を使用\nwinget install Git.Git\n\n# chocolatey を使用\nchoco install git\n\n\n2.2.2 macOS\n# Homebrew を使用\nbrew install git\n\n# Xcode Command Line Tools を使用\nxcode-select --install\n\n\n2.2.3 Linux\n# Ubuntu/Debian\nsudo apt install git\n\n# Fedora\nsudo dnf install git\n\n# Arch Linux\nsudo pacman -S git",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#基本的な-git-設定",
    "href": "book/02-git-github.html#基本的な-git-設定",
    "title": "2  Git と GitHub",
    "section": "2.3 基本的な Git 設定",
    "text": "2.3 基本的な Git 設定\n身元を設定します：\ngit config --global user.name \"あなたの名前\"\ngit config --global user.email \"your.email@example.com\"\ngit config --global init.defaultBranch main",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#必須の-git-コマンド",
    "href": "book/02-git-github.html#必須の-git-コマンド",
    "title": "2  Git と GitHub",
    "section": "2.4 必須の Git コマンド",
    "text": "2.4 必須の Git コマンド\n\n2.4.1 リポジトリの初期化\n# 新しいリポジトリを作成\ngit init\n\n# 既存のリポジトリをクローン\ngit clone https://github.com/user/repo.git\n\n\n2.4.2 基本的なワークフロー\n# ステータスを確認\ngit status\n\n# ファイルをステージングに追加\ngit add filename.py\ngit add .  # すべてのファイルを追加\n\n# 変更をコミット\ngit commit -m \"新機能を追加\"\n\n# 履歴を表示\ngit log --oneline\n\n\n2.4.3 ブランチング\n# 新しいブランチを作成\ngit branch feature-name\ngit checkout feature-name\n# または一つのコマンドで：\ngit checkout -b feature-name\n\n# ブランチを切り替え\ngit checkout main\n\n# ブランチをマージ\ngit checkout main\ngit merge feature-name\n\n# ブランチを削除\ngit branch -d feature-name",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#github-の基本",
    "href": "book/02-git-github.html#github-の基本",
    "title": "2  Git と GitHub",
    "section": "2.5 GitHub の基本",
    "text": "2.5 GitHub の基本\nGitHub は Git リポジトリをクラウドでホストし、コラボレーション機能を追加します。\n\n2.5.1 リポジトリの作成\n\ngithub.com にアクセス\n“New repository” をクリック\nリポジトリ名を選択\n説明を追加\nパブリック/プライベートを選択\nREADME、.gitignore、ライセンスを追加\n\n\n\n2.5.2 ローカルをリモートに接続\n# リモート origin を追加\ngit remote add origin https://github.com/username/repo.git\n\n# GitHub にプッシュ\ngit push -u origin main\n\n# 変更をプル\ngit pull origin main\n\n\n2.5.3 GitHub ワークフロー\n# 1. 機能ブランチを作成\ngit checkout -b feature/new-functionality\n\n# 2. 変更を加えてコミット\ngit add .\ngit commit -m \"feat: 新機能を追加\"\n\n# 3. ブランチをプッシュ\ngit push origin feature/new-functionality\n\n# 4. GitHub でプルリクエストを作成\n# 5. レビューしてマージ\n# 6. 機能ブランチを削除\ngit checkout main\ngit pull origin main\ngit branch -d feature/new-functionality",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#python-固有の-git-実践",
    "href": "book/02-git-github.html#python-固有の-git-実践",
    "title": "2  Git と GitHub",
    "section": "2.6 Python 固有の Git 実践",
    "text": "2.6 Python 固有の Git 実践\n\n2.6.1 Python 用 .gitignore\n.gitignore ファイルを作成：\n# Python\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n.Python\nenv/\nvenv/\n.venv/\n.ENV/\n\n# IDEs\n.vscode/\n.idea/\n*.swp\n*.swo\n\n# OS\n.DS_Store\nThumbs.db\n\n# プロジェクト固有\ndocs/\n.pytest_cache/\n\n\n2.6.2 コミットメッセージの規約\n明確で説明的なコミットメッセージを使用：\n# 良い例\ngit commit -m \"feat: ユーザー認証システムを追加\"\ngit commit -m \"fix: ログイン検証バグを解決\"\ngit commit -m \"docs: API ドキュメントを更新\"\n\n# 悪い例\ngit commit -m \"色々更新\"\ngit commit -m \"バグ修正\"\ngit commit -m \"変更\"\n\n\n2.6.3 一般的なプレフィックス：\n\nfeat: - 新機能\nfix: - バグ修正\ndocs: - ドキュメント\nstyle: - コード整形\nrefactor: - コード再構築\ntest: - テスト追加\nchore: - メンテナンス作業",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#実践演習",
    "href": "book/02-git-github.html#実践演習",
    "title": "2  Git と GitHub",
    "section": "2.7 実践演習",
    "text": "2.7 実践演習\n実際の Python プロジェクトで練習しましょう：\n# シンプルな計算機を作成\n# ファイル: calculator.py\n\ndef add(a: float, b: float) -&gt; float:\n    \"\"\"二つの数を足す。\"\"\"\n    return a + b\n\ndef subtract(a: float, b: float) -&gt; float:\n    \"\"\"a から b を引く。\"\"\"\n    return a - b\n\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"二つの数を掛ける。\"\"\"\n    return a * b\n\ndef divide(a: float, b: float) -&gt; float:\n    \"\"\"a を b で割る。\"\"\"\n    if b == 0:\n        raise ValueError(\"ゼロで割ることはできません\")\n    return a / b\n\nif __name__ == \"__main__\":\n    print(\"計算機デモ\")\n    print(f\"5 + 3 = {add(5, 3)}\")\n    print(f\"5 - 3 = {subtract(5, 3)}\")\n    print(f\"5 * 3 = {multiply(5, 3)}\")\n    print(f\"5 / 3 = {divide(5, 3):.2f}\")\n\n2.7.1 演習手順\n\nリポジトリを初期化：\nmkdir python-calculator\ncd python-calculator\ngit init\ncalculator.py を作成 上記のコードを使用\n追加してコミット：\ngit add calculator.py\ngit commit -m \"feat: 基本的な計算機能能を追加\"\nGitHub リポジトリを作成してプッシュ：\ngit remote add origin https://github.com/yourusername/python-calculator.git\ngit push -u origin main\n機能を追加（新しいブランチを作成）：\ngit checkout -b feature/power-function\nべき乗関数を追加 calculator.py に：\ndef power(a: float, b: float) -&gt; float:\n    \"\"\"a を b 乗する。\"\"\"\n    return a ** b\nコミットしてプッシュ：\ngit add calculator.py\ngit commit -m \"feat: べき乗関数を追加\"\ngit push origin feature/power-function\nGitHub でプルリクエストを作成",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#git-のベストプラクティス",
    "href": "book/02-git-github.html#git-のベストプラクティス",
    "title": "2  Git と GitHub",
    "section": "2.8 Git のベストプラクティス",
    "text": "2.8 Git のベストプラクティス\n\n頻繁にコミット - 小さく論理的なコミット\n明確なメッセージを書く - 何をなぜ説明\nブランチを使用 - main ブランチを安定に保つ\nマージ前にレビュー - プルリクエストを使用\n履歴をきれいに保つ - 不要なマージコミットを避ける\n定期的にバックアップ - リモートに頻繁にプッシュ",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#よくある問題のトラブルシューティング",
    "href": "book/02-git-github.html#よくある問題のトラブルシューティング",
    "title": "2  Git と GitHub",
    "section": "2.9 よくある問題のトラブルシューティング",
    "text": "2.9 よくある問題のトラブルシューティング\n\n2.9.1 変更を元に戻す\n# ステージングされていない変更を元に戻す\ngit checkout -- filename.py\n\n# ステージングされた変更を元に戻す\ngit reset HEAD filename.py\n\n# 最後のコミットを元に戻す（変更を保持）\ngit reset --soft HEAD~1\n\n# 最後のコミットを元に戻す（変更を破棄）\ngit reset --hard HEAD~1\n\n\n2.9.2 コンフリクトの解決\nGit が自動的にマージできない場合：\n\nコンフリクトしたファイルを開く\nコンフリクトマーカーを探す： &lt;&lt;&lt;&lt;&lt;&lt;&lt;、=======、&gt;&gt;&gt;&gt;&gt;&gt;&gt;\nコンフリクトを解決するために編集\nコンフリクトマーカーを削除\n解決したファイルを追加してコミット",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#次のステップ",
    "href": "book/02-git-github.html#次のステップ",
    "title": "2  Git と GitHub",
    "section": "2.10 次のステップ",
    "text": "2.10 次のステップ\nGit と GitHub を理解したので、Python 構文に進んでコーディングを始めましょう！",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/02-git-github.html#リソース",
    "href": "book/02-git-github.html#リソース",
    "title": "2  Git と GitHub",
    "section": "2.11 リソース",
    "text": "2.11 リソース\n\nGit ドキュメント\nGitHub ガイド\nインタラクティブ Git チュートリアル",
    "crumbs": [
      "基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git と GitHub</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html",
    "href": "book/03-syntax.html",
    "title": "3  Python 構文と基本",
    "section": "",
    "text": "3.1 初めての Python プログラム\nPython の清潔で読みやすい構文は、初心者にとって完璧でありながら、専門家にとって強力なままです。\nprint(\"Hello, Python!\")\nprint(\"インタラクティブな Python 学習へようこそ！\")\n\n# このメッセージを変更してコードを実行してみてください\nyour_name = \"学習者\"  # これをあなたの名前に変えてください！\nprint(f\"こんにちは、{your_name}さん！Python を学ぶ準備はできていますか？\")\nこの簡単な例は Python の哲学を実証しています：コードは読みやすく、わかりやすくあるべきです。上のコードを編集してみてください - your_name をあなたの実際の名前に変更して、再実行してみましょう！",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#ファイルアップロードのテスト",
    "href": "book/03-syntax.html#ファイルアップロードのテスト",
    "title": "3  Python 構文と基本",
    "section": "3.2 ファイルアップロードのテスト",
    "text": "3.2 ファイルアップロードのテスト\n\n\n\n\n\n\n📁 ドラッグ＆ドロップのテスト\n\n\n\nここに小さなテキストファイルをドラッグして、アップロード機能をテストしてみてください：\n\n\n\n\n\ntest.txt\n\n# ここにテキストファイルをドラッグ＆ドロップしてください\nimport os\n\ntry:\n    if os.path.exists('test.txt'):\n        with open('test.txt', 'r', encoding='utf-8') as f:\n            content = f.read()\n        print(f\"ファイルのアップロードが成功しました！\")\n        print(f\"コンテンツの長さ: {len(content)} 文字\")\n        print(f\"最初の100文字: {content[:100]}\")\n    else:\n        print(\"まだファイルがアップロードされていません。この領域にテキストファイルをドラッグしてください！\")\nexcept Exception as e:\n    print(f\"ファイル読み込みエラー: {e}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#python-の哲学---python-の禅",
    "href": "book/03-syntax.html#python-の哲学---python-の禅",
    "title": "3  Python 構文と基本",
    "section": "3.3 Python の哲学 - Python の禅",
    "text": "3.3 Python の哲学 - Python の禅\n\nimport this",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#変数と代入",
    "href": "book/03-syntax.html#変数と代入",
    "title": "3  Python 構文と基本",
    "section": "3.4 変数と代入",
    "text": "3.4 変数と代入\nPython は動的型付けを使用 - 変数の型を宣言する必要がありません：\n\n# 異なるデータ型\nname = \"Alice\"          # 文字列\nage = 25               # 整数\nheight = 5.6           # 浮動小数点数\nis_student = True      # ブール値\n\nprint(f\"名前: {name}\")\nprint(f\"年齢: {age}\")\nprint(f\"身長: {height}\")\nprint(f\"学生: {is_student}\")\n\n\n3.4.1 変数命名規則\n\n# 有効な変数名\nfirst_name = \"John\"\nlast_name = \"Doe\"\nage_2024 = 30\n_private_var = \"hidden\"\n\n# 無効な名前（エラーの原因）:\n# 2name = \"invalid\"     # 数字で始められない\n# first-name = \"invalid\" # ハイフンは使用できない\n# class = \"invalid\"     # キーワードは使用できない\n\nprint(f\"フルネーム: {first_name} {last_name}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#コメント",
    "href": "book/03-syntax.html#コメント",
    "title": "3  Python 構文と基本",
    "section": "3.5 コメント",
    "text": "3.5 コメント\nコメントはコードを読みやすくします：\n\n# これは一行コメントです\nprint(\"Hello\")  # 行末のコメント\n\n\"\"\"\nこれは複数行コメント\nまたはドキュメント文字列です。長い\n説明に使用します。\n\"\"\"\n\ndef greet(name):\n    \"\"\"\n    これは関数のドキュメント文字列です。\n    関数が何をするかを説明します。\n    \"\"\"\n    return f\"Hello, {name}!\"\n\nprint(greet(\"Python\"))",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#基本データ型",
    "href": "book/03-syntax.html#基本データ型",
    "title": "3  Python 構文と基本",
    "section": "3.6 基本データ型",
    "text": "3.6 基本データ型\n\n3.6.1 数値\n\n# 整数\ncount = 42\nnegative = -17\n\n# 浮動小数点数\nprice = 19.99\nscientific = 1.5e-4  # 0.00015\n\n# 複素数\ncomplex_num = 3 + 4j\n\nprint(f\"整数: {count}\")\nprint(f\"浮動小数点数: {price}\")\nprint(f\"科学記法: {scientific}\")\nprint(f\"複素数: {complex_num}\")\n\n\n\n3.6.2 文字列\n\n# 文字列を作成する様々な方法\nsingle_quotes = 'Hello'\ndouble_quotes = \"World\"\ntriple_quotes = \"\"\"これは\n複数行文字列です\"\"\"\n\n# 文字列の連結\ngreeting = single_quotes + \" \" + double_quotes\nprint(greeting)\n\n# 文字列フォーマット\nname = \"Python\"\nversion = 3.12\n\n# f-strings（推奨）\nmessage = f\"Welcome to {name} {version}!\"\nprint(message)\n\n# format() メソッド\nmessage2 = \"Welcome to {} {}!\".format(name, version)\nprint(message2)\n\n# % フォーマット（古いスタイル）\nmessage3 = \"Welcome to %s %.1f!\" % (name, version)\nprint(message3)\n\n\n\n3.6.3 文字列操作\n\ntext = \"Python Programming\"\n\n# 長さ\nprint(f\"長さ: {len(text)}\")\n\n# 大文字小文字メソッド\nprint(f\"大文字: {text.upper()}\")\nprint(f\"小文字: {text.lower()}\")\nprint(f\"タイトルケース: {text.title()}\")\n\n# 文字列メソッド\nprint(f\"'Python'で始まる: {text.startswith('Python')}\")\nprint(f\"'gram'を含む: {'gram' in text}\")\nprint(f\"置換: {text.replace('Python', 'Java')}\")\n\n# スライシング\nprint(f\"最初の6文字: {text[:6]}\")\nprint(f\"最後の11文字: {text[7:]}\")\nprint(f\"2文字おき: {text[::2]}\")\n\n\n\n3.6.4 ブール値\n\n# ブール値\nis_python_fun = True\nis_difficult = False\n\n# ブール演算\nprint(f\"AND: {is_python_fun and is_difficult}\")\nprint(f\"OR: {is_python_fun or is_difficult}\")\nprint(f\"NOT: {not is_difficult}\")\n\n# 真偽値性 - True/False として扱われるもの\nprint(f\"空文字列: {bool('')}\")        # False\nprint(f\"非空文字列: {bool('hello')}\") # True\nprint(f\"ゼロ: {bool(0)}\")                  # False\nprint(f\"非ゼロ: {bool(42)}\")             # True\nprint(f\"空リスト: {bool([])}\")           # False\nprint(f\"非空リスト: {bool([1, 2])}\")   # True",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#演算子",
    "href": "book/03-syntax.html#演算子",
    "title": "3  Python 構文と基本",
    "section": "3.7 演算子",
    "text": "3.7 演算子\n\n3.7.1 算術演算子\n\na, b = 10, 3\n\nprint(f\"加算: {a} + {b} = {a + b}\")\nprint(f\"減算: {a} - {b} = {a - b}\")\nprint(f\"乗算: {a} * {b} = {a * b}\")\nprint(f\"除算: {a} / {b} = {a / b}\")\nprint(f\"切り捨て除算: {a} // {b} = {a // b}\")\nprint(f\"剰余: {a} % {b} = {a % b}\")\nprint(f\"べき乗: {a} ** {b} = {a ** b}\")\n\n\n\n3.7.2 比較演算子\n\nx, y = 5, 10\n\nprint(f\"{x} == {y}: {x == y}\")   # 等しい\nprint(f\"{x} != {y}: {x != y}\")   # 等しくない\nprint(f\"{x} &lt; {y}: {x &lt; y}\")     # より小さい\nprint(f\"{x} &gt; {y}: {x &gt; y}\")     # より大きい\nprint(f\"{x} &lt;= {y}: {x &lt;= y}\")   # 以下\nprint(f\"{x} &gt;= {y}: {x &gt;= y}\")   # 以上\n\n\n\n3.7.3 代入演算子\n\nnum = 10\nprint(f\"初期値: {num}\")\n\nnum += 5    # num = num + 5\nprint(f\"+=5 後: {num}\")\n\nnum -= 3    # num = num - 3\nprint(f\"-=3 後: {num}\")\n\nnum *= 2    # num = num * 2\nprint(f\"*=2 後: {num}\")\n\nnum //= 3   # num = num // 3\nprint(f\"//=3 後: {num}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#入力と出力",
    "href": "book/03-syntax.html#入力と出力",
    "title": "3  Python 構文と基本",
    "section": "3.8 入力と出力",
    "text": "3.8 入力と出力\n\n3.8.1 ユーザー入力の取得\n\n# 注意: input() は常に文字列を返します\n# name = input(\"お名前は？ \")\n# print(f\"こんにちは、{name}!\")\n\n# 数値の場合、入力を変換します\n# age_str = input(\"何歳ですか？ \")\n# age = int(age_str)\n# print(f\"あなたは{age}歳です\")\n\n# または一行で：\n# age = int(input(\"何歳ですか？ \"))\n\n# デモンストレーション用に入力をシミュレート：\nname = \"Alice\"  # ユーザー入力をシミュレート\nage = 25       # ユーザー入力をシミュレート\n\nprint(f\"こんにちは、{name}!\")\nprint(f\"あなたは{age}歳です\")\n\n\n\n3.8.2 出力フォーマット\n\nimport math\n\n# 基本的な print\nprint(\"単純な出力\")\n\n# 複数の値\nprint(\"複数の\", \"値を\", \"一つの\", \"printで\")\n\n# カスタム区切り文字と終端\nprint(\"A\", \"B\", \"C\", sep=\"-\")\nprint(\"改行なし\", end=\" \")\nprint(\"ここで続く\")\n\n# 数値のフォーマット\npi = math.pi\nprint(f\"円周率: {pi}\")\nprint(f\"円周率（小数点2桁）: {pi:.2f}\")\nprint(f\"円周率（科学記法）: {pi:.2e}\")\n\n# パディングを使ったフォーマット\nnumber = 42\nprint(f\"右寄せ: {number:&gt;10}\")\nprint(f\"左寄せ: {number:&lt;10}\")\nprint(f\"中央寄せ: {number:^10}\")\nprint(f\"ゼロパディング: {number:05}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#インデントとコード構造",
    "href": "book/03-syntax.html#インデントとコード構造",
    "title": "3  Python 構文と基本",
    "section": "3.9 インデントとコード構造",
    "text": "3.9 インデントとコード構造\nPython はコードブロックを定義するためにインデントを使用します：\n\n# 正しいインデント\nage = 18\nif age &gt;= 18:\n    print(\"あなたは成人です\")\n    print(\"投票できます\")\nelse:\n    print(\"あなたは未成年です\")\n    print(\"まだ投票できません\")\n\nprint(\"これはif文の外側です\")\n\n\n3.9.1 よくあるインデントの間違い\n# 間違い - 一貫性のないインデント（IndentationErrorの原因）\nif True:\n    print(\"これは4スペースでインデント\")\n        print(\"これは8スペースでインデント\")  # エラー！\n\n# 間違い - インデントがない（IndentationErrorの原因）\nif True:\nprint(\"これはインデントされるべき\")  # エラー！\n\n# 正しい - 一貫性のあるインデント\nif True:\n    print(\"これは正しくインデントされています\")\n    print(\"これも同様\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#演習",
    "href": "book/03-syntax.html#演習",
    "title": "3  Python 構文と基本",
    "section": "3.10 演習",
    "text": "3.10 演習\n\n3.10.1 演習1: 変数と文字列\n個人情報の変数を作成し、きれいに表示してください：\n\n# あなたの解答をここに\nfirst_name = \"John\"\nlast_name = \"Doe\"\nage = 30\ncity = \"New York\"\nhobby = \"programming\"\n\n# 情報を表示\nprint(\"=== 個人情報 ===\")\nprint(f\"名前: {first_name} {last_name}\")\nprint(f\"年齢: {age}歳\")\nprint(f\"都市: {city}\")\nprint(f\"趣味: {hobby}\")\nprint(\"=\"*30)\n\n\n\n3.10.2 演習2: 計算機\n簡単な計算機を作成してください：\n\n# 計算機演習\nnum1 = 15\nnum2 = 4\n\nprint(f\"数値1: {num1}\")\nprint(f\"数値2: {num2}\")\nprint(\"-\" * 20)\nprint(f\"加算: {num1} + {num2} = {num1 + num2}\")\nprint(f\"減算: {num1} - {num2} = {num1 - num2}\")\nprint(f\"乗算: {num1} × {num2} = {num1 * num2}\")\nprint(f\"除算: {num1} ÷ {num2} = {num1 / num2:.2f}\")\nprint(f\"べき乗: {num1}^{num2} = {num1 ** num2}\")\n\n\n\n3.10.3 演習3: 文字列操作\n文字列メソッドを使って作業してください：\n\n# 文字列操作演習\nsentence = \"python is an amazing programming language\"\n\nprint(f\"元の文字列: {sentence}\")\nprint(f\"長さ: {len(sentence)} 文字\")\nprint(f\"単語数: {sentence.count(' ') + 1}\")\nprint(f\"タイトルケース: {sentence.title()}\")\nprint(f\"大文字: {sentence.upper()}\")\nprint(f\"先頭大文字: {sentence.capitalize()}\")\nprint(f\"'python'を'Python'に置換: {sentence.replace('python', 'Python')}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#よくある落とし穴",
    "href": "book/03-syntax.html#よくある落とし穴",
    "title": "3  Python 構文と基本",
    "section": "3.11 よくある落とし穴",
    "text": "3.11 よくある落とし穴\n\nインデントエラー - 一貫性のあるスペースを使用（4スペース推奨）\n変数命名 - 説明的な名前を使用し、規約に従う\n文字列 vs 数値 - input()は文字列を返すことを覚えておく\n大文字小文字の区別 - Nameとnameは異なる変数\n日本語でのコメント - Unicode対応なのでコメントに日本語使用可能",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#ベストプラクティス",
    "href": "book/03-syntax.html#ベストプラクティス",
    "title": "3  Python 構文と基本",
    "section": "3.12 ベストプラクティス",
    "text": "3.12 ベストプラクティス\n\n説明的な変数名を使用:\n# 悪い例\nx = 25\n\n# 良い例\nstudent_age = 25\nPEP 8 命名規約に従う:\n# 変数と関数: snake_case\nuser_name = \"Alice\"\n\n# 定数: UPPER_CASE\nMAX_ATTEMPTS = 3\n\n# クラス: PascalCase（後で学習）\n# UserAccount\nフォーマットにはf-stringsを使用（Python 3.6+）\n複雑なロジックにはコメントを追加\n可能な限り行を80文字以下に保つ",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#クイズ",
    "href": "book/03-syntax.html#クイズ",
    "title": "3  Python 構文と基本",
    "section": "3.13 クイズ",
    "text": "3.13 クイズ\n理解度をテストしてください：\n\nprint(type(5)) の出力は何ですか？\n'hello' と \"hello\" の違いは何ですか？\n文字列と数値を足すとどうなりますか？\n複数行文字列はどのように作成しますか？\n10 // 3 の結果は何ですか？\n\n\n3.13.1 回答\n\n&lt;class 'int'&gt;\n違いはない - どちらも文字列を作成\nTypeError - 一方を他方に合わせて変換する必要がある\n三重引用符を使用: \"\"\" または '''\n3（切り捨て除算）",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/03-syntax.html#次のステップ",
    "href": "book/03-syntax.html#次のステップ",
    "title": "3  Python 構文と基本",
    "section": "3.14 次のステップ",
    "text": "3.14 次のステップ\n素晴らしい！Python の基本を学びました。次は データ型とコレクション を探索して、より複雑なデータを扱う方法を学びましょう。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python 構文と基本</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html",
    "href": "book/04-data-types.html",
    "title": "4  データ型とコレクション",
    "section": "",
    "text": "4.1 リスト - 順序付きコレクション\nPython は、データを効率的に整理・操作するための強力な組み込みデータ構造を提供しています。\nリストは異なるデータ型を保持できる可変シーケンスです：\n# リストの作成\nfruits = [\"apple\", \"banana\", \"cherry\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [\"hello\", 42, 3.14, True]\n\nprint(\"果物:\", fruits)\nprint(\"数字:\", numbers)\nprint(\"混合型:\", mixed)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#リスト---順序付きコレクション",
    "href": "book/04-data-types.html#リスト---順序付きコレクション",
    "title": "4  データ型とコレクション",
    "section": "",
    "text": "4.1.1 リストの操作\n\ncolors = [\"red\", \"green\", \"blue\"]\n\n# 要素へのアクセス（0から始まるインデックス）\nprint(f\"最初の色: {colors[0]}\")\nprint(f\"最後の色: {colors[-1]}\")\n\n# 要素の追加\ncolors.append(\"yellow\")           # 末尾に追加\ncolors.insert(1, \"purple\")        # 指定位置に挿入\nprint(f\"追加後: {colors}\")\n\n# 要素の削除\ncolors.remove(\"purple\")           # 値で削除\nlast_color = colors.pop()         # 最後を削除して返す\nprint(f\"削除後: {colors}\")\nprint(f\"削除した色: {last_color}\")\n\n\n\n4.1.2 リストのメソッドとプロパティ\n\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\n\nprint(f\"元のリスト: {numbers}\")\nprint(f\"長さ: {len(numbers)}\")\nprint(f\"1の個数: {numbers.count(1)}\")\nprint(f\"4のインデックス: {numbers.index(4)}\")\n\n# ソート\nnumbers.sort()\nprint(f\"ソート後: {numbers}\")\n\n# 逆順\nnumbers.reverse()\nprint(f\"逆順: {numbers}\")\n\n# リスト内包表記（プレビュー）\nsquares = [x**2 for x in range(1, 6)]\nprint(f\"平方数: {squares}\")\n\n\n\n4.1.3 リストのスライシング\n\nletters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\nprint(f\"元のリスト: {letters}\")\nprint(f\"最初の3つ: {letters[:3]}\")\nprint(f\"最後の3つ: {letters[-3:]}\")\nprint(f\"中間: {letters[2:5]}\")\nprint(f\"2つおき: {letters[::2]}\")\nprint(f\"逆順: {letters[::-1]}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#タプル---不変シーケンス",
    "href": "book/04-data-types.html#タプル---不変シーケンス",
    "title": "4  データ型とコレクション",
    "section": "4.2 タプル - 不変シーケンス",
    "text": "4.2 タプル - 不変シーケンス\nタプルは不変シーケンスで、固定データに最適です：\n\n# タプルの作成\npoint = (10, 20)\nrgb_color = (255, 128, 0)\nperson = (\"Alice\", 25, \"Engineer\")\n\nprint(f\"座標: {point}\")\nprint(f\"RGB色: {rgb_color}\")\nprint(f\"人物情報: {person}\")\n\n# 要素へのアクセス\nprint(f\"X座標: {point[0]}\")\nprint(f\"Y座標: {point[1]}\")\n\n# タプルのアンパック\nname, age, job = person\nprint(f\"名前: {name}, 年齢: {age}, 職業: {job}\")\n\n\n4.2.1 タプルのメソッド\n\ngrades = (85, 92, 78, 92, 88, 92)\n\nprint(f\"成績: {grades}\")\nprint(f\"92の個数: {grades.count(92)}\")\nprint(f\"78のインデックス: {grades.index(78)}\")\nprint(f\"長さ: {len(grades)}\")\n\n# リストとタプルの変換\ngrades_list = list(grades)\nprint(f\"リストとして: {grades_list}\")\n\nnew_tuple = tuple([1, 2, 3, 4])\nprint(f\"リストから: {new_tuple}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#辞書---キー-値ペア",
    "href": "book/04-data-types.html#辞書---キー-値ペア",
    "title": "4  データ型とコレクション",
    "section": "4.3 辞書 - キー-値ペア",
    "text": "4.3 辞書 - キー-値ペア\n辞書はキー-値ペアとしてデータを格納します：\n\n# 辞書の作成\nstudent = {\n    \"name\": \"Alice\",\n    \"age\": 20,\n    \"major\": \"Computer Science\",\n    \"gpa\": 3.8\n}\n\nprint(\"学生情報:\", student)\n\n# 値へのアクセス\nprint(f\"名前: {student['name']}\")\nprint(f\"GPA: {student.get('gpa', '見つかりません')}\")\n\n# 値の追加/更新\nstudent[\"graduation_year\"] = 2025\nstudent[\"age\"] = 21\nprint(\"更新後:\", student)\n\n\n4.3.1 辞書のメソッド\n\ninventory = {\n    \"apples\": 50,\n    \"bananas\": 30,\n    \"oranges\": 25\n}\n\nprint(\"在庫:\", inventory)\n\n# 辞書のメソッド\nprint(\"キー:\", list(inventory.keys()))\nprint(\"値:\", list(inventory.values()))\nprint(\"アイテム:\", list(inventory.items()))\n\n# 存在確認\nprint(\"りんごあり:\", \"apples\" in inventory)\nprint(\"ぶどうあり:\", \"grapes\" in inventory)\n\n# 安全な削除\nremoved = inventory.pop(\"bananas\", 0)\nprint(f\"バナナを{removed}個削除\")\nprint(\"削除後:\", inventory)\n\n\n\n4.3.2 辞書の反復処理\n\nscores = {\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92}\n\n# キーの反復処理\nprint(\"学生:\")\nfor name in scores:\n    print(f\"  {name}\")\n\n# 値の反復処理\nprint(\"スコア:\")\nfor score in scores.values():\n    print(f\"  {score}\")\n\n# キー-値ペアの反復処理\nprint(\"学生スコア:\")\nfor name, score in scores.items():\n    print(f\"  {name}: {score}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#セット---一意なコレクション",
    "href": "book/04-data-types.html#セット---一意なコレクション",
    "title": "4  データ型とコレクション",
    "section": "4.4 セット - 一意なコレクション",
    "text": "4.4 セット - 一意なコレクション\nセットは一意な要素を格納し、数学的操作をサポートします：\n\n# セットの作成\nfruits = {\"apple\", \"banana\", \"cherry\"}\nnumbers = {1, 2, 3, 4, 5}\nmixed_set = {1, \"hello\", 3.14}\n\nprint(\"果物セット:\", fruits)\nprint(\"数字セット:\", numbers)\n\n# 要素の追加\nfruits.add(\"orange\")\nprint(\"オレンジ追加後:\", fruits)\n\n# 要素の削除\nfruits.discard(\"banana\")  # 安全な削除\nprint(\"バナナ削除後:\", fruits)\n\n\n4.4.1 セット演算\n\nset_a = {1, 2, 3, 4, 5}\nset_b = {4, 5, 6, 7, 8}\n\nprint(f\"セットA: {set_a}\")\nprint(f\"セットB: {set_b}\")\n\n# 数学的演算\nprint(f\"和集合 (A ∪ B): {set_a | set_b}\")\nprint(f\"積集合 (A ∩ B): {set_a & set_b}\")\nprint(f\"差集合 (A - B): {set_a - set_b}\")\nprint(f\"対称差集合: {set_a ^ set_b}\")\n\n# 包含テスト\nprint(f\"3 は A に含まれる: {3 in set_a}\")\nprint(f\"A は B の部分集合: {set_a.issubset(set_b)}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#適切なデータ構造の選択",
    "href": "book/04-data-types.html#適切なデータ構造の選択",
    "title": "4  データ型とコレクション",
    "section": "4.5 適切なデータ構造の選択",
    "text": "4.5 適切なデータ構造の選択\n\n\n\nデータ構造\n使用場面\n例\n\n\n\n\nリスト\n順序付き、可変コレクション\n買い物リスト、スコア\n\n\nタプル\n順序付き、不変コレクション\n座標、RGB値\n\n\n辞書\nキー-値マッピング\n学生記録、在庫\n\n\nセット\n一意な要素、高速検索\nタグ、一意ID\n\n\n\n\n# 実用的な例\nshopping_list = [\"milk\", \"bread\", \"eggs\"]        # リスト: 変更可能\ncoordinates = (40.7128, -74.0060)                # タプル: 固定点\nstudent_grades = {\"math\": 95, \"science\": 87}     # 辞書: 科目で検索\nunique_visitors = {\"alice\", \"bob\", \"charlie\"}     # セット: 重複なし",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#一般的なパターンと操作",
    "href": "book/04-data-types.html#一般的なパターンと操作",
    "title": "4  データ型とコレクション",
    "section": "4.6 一般的なパターンと操作",
    "text": "4.6 一般的なパターンと操作\n\n4.6.1 リスト内包表記\nリスト内包表記は、既存のシーケンスに基づいて新しいリストを簡潔に作成する方法です。従来のループよりも読みやすく、しばしば高速です。\n基本構文: [式 for 要素 in イテラブル if 条件]\n段階的に見てみましょう：\n\n# 従来の方法 - ループとappendを使用\nsquares = []\nfor x in range(1, 6):\n    squares.append(x**2)\nprint(\"従来型:\", squares)\n\n# リスト内包表記 - 1行で完結\n# これは「1から5までの各xについて、x²のリストを作成する」と読めます\nsquares = [x**2 for x in range(1, 6)]\nprint(\"内包表記:\", squares)\n\n# 条件付き - フィルタリングしながら変換\n# これは「1から10までの各xについて、xが偶数の場合のみx²のリストを作成する」\n# （x % 2 == 0 は余りが0、つまり偶数を意味します）\neven_squares = [x**2 for x in range(1, 11) if x % 2 == 0]\nprint(\"偶数の二乗:\", even_squares)\n\n# 文字列との組み合わせ - 各単語を変換\n# これは「wordsリストの各wordについて、word.upper()のリストを作成する」\nwords = [\"hello\", \"world\", \"python\"]\nuppercase = [word.upper() for word in words]\nprint(\"大文字:\", uppercase)\n\nなぜリスト内包表記を使うのか？ - 読みやすさ: 意図が1行で明確 - パフォーマンス: Pythonが内部的に最適化 - Pythonic: Pythonらしい書き方とされている",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#演習",
    "href": "book/04-data-types.html#演習",
    "title": "4  データ型とコレクション",
    "section": "7.1 演習",
    "text": "7.1 演習\n\n7.1.1 演習1: 学生管理システム\n\n# 学生管理システムを作成\nstudents = []\n\n# 学生を追加\ndef add_student(name, age, grades):\n    student = {\n        \"name\": name,\n        \"age\": age,\n        \"grades\": grades,\n        \"average\": sum(grades) / len(grades)\n    }\n    students.append(student)\n\n# 学生を追加\nadd_student(\"Alice\", 20, [95, 87, 92])\nadd_student(\"Bob\", 19, [78, 84, 88])\nadd_student(\"Charlie\", 21, [92, 96, 89])\n\n# 学生を表示\nprint(\"=== 学生記録 ===\")\nfor student in students:\n    print(f\"名前: {student['name']}\")\n    print(f\"年齢: {student['age']}\")\n    print(f\"成績: {student['grades']}\")\n    print(f\"平均: {student['average']:.1f}\")\n    print(\"-\" * 20)\n\n\n\n7.1.2 演習2: 単語頻度カウンター\n\n# テキスト内の単語頻度をカウント\ntext = \"python is great python is powerful python is fun\"\nwords = text.split()\n\n# 方法1: 辞書を使用\nword_count = {}\nfor word in words:\n    word_count[word] = word_count.get(word, 0) + 1\n\nprint(\"単語の頻度:\")\nfor word, count in word_count.items():\n    print(f\"{word}: {count}\")\n\n# 方法2: Counter を使用（collections から）\nfrom collections import Counter\nword_count_2 = Counter(words)\nprint(\"\\nCounter使用:\", dict(word_count_2))\n\n\n\n7.1.3 演習3: データでのセット演算\n\n# 学生の履修科目\nmath_students = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}\nscience_students = {\"Bob\", \"Charlie\", \"Eve\", \"Frank\"}\nenglish_students = {\"Alice\", \"Charlie\", \"Eve\", \"Grace\"}\n\nprint(\"数学受講生:\", math_students)\nprint(\"理科受講生:\", science_students)\nprint(\"英語受講生:\", english_students)\n\n# 分析\nboth_math_science = math_students & science_students\nprint(\"数学と理科の両方:\", both_math_science)\n\nall_students = math_students | science_students | english_students\nprint(\"全学生:\", all_students)\n\nonly_math = math_students - science_students - english_students\nprint(\"数学のみ:\", only_math)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#自己確認問題",
    "href": "book/04-data-types.html#自己確認問題",
    "title": "4  データ型とコレクション",
    "section": "7.2 自己確認問題",
    "text": "7.2 自己確認問題\n\n7.2.1 知識チェック\n\nリストとタプルの違いは何ですか？\nリストの代わりに辞書を使うのはいつですか？\nセットに重複を追加しようとするとどうなりますか？\nリストの最後の要素にアクセスするにはどうしますか？\nリストのremove()とpop()の違いは何ですか？\n\n\n\n7.2.2 コーディングチャレンジ\n\n2つのリストの共通要素を見つける関数を作成\n2つの辞書をマージするプログラムを作成\nリスト内包表記を使ってリストから偶数をフィルタリング\nリスト内で最も頻繁に現れる要素を返す関数を作成\n\n\n\n7.2.3 回答\n\nリストは可変で順序付き；タプルは不変で順序付き\nキー-値の関連付けやキーによる高速検索が必要な時\n何も起こらない - セットは自動的に重複を処理\nmy_list[-1] または my_list[len(my_list)-1]\nremove()は値で削除；pop()はインデックスで削除して値を返す",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#ベストプラクティス",
    "href": "book/04-data-types.html#ベストプラクティス",
    "title": "4  データ型とコレクション",
    "section": "7.3 ベストプラクティス",
    "text": "7.3 ベストプラクティス\n\n用途に適したデータ構造を選択する\n簡単な変換にはリスト内包表記を使用する\n辞書の安全なアクセスにはget()メソッドを使用する\n包含テストと重複除去にはセットを使用する\n複数の代入にはタプルアンパックを使用する",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#よくある落とし穴",
    "href": "book/04-data-types.html#よくある落とし穴",
    "title": "4  データ型とコレクション",
    "section": "7.4 よくある落とし穴",
    "text": "7.4 よくある落とし穴\n\n反復処理中にリストを変更 - 最初にコピーを作成\n関数パラメータで可変なデフォルトを使用\n比較でisと==を混同\n辞書が挿入順序を保持することを忘れる（Python 3.7+）",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#パフォーマンスのヒント",
    "href": "book/04-data-types.html#パフォーマンスのヒント",
    "title": "4  データ型とコレクション",
    "section": "7.5 パフォーマンスのヒント",
    "text": "7.5 パフォーマンスのヒント\n\nimport time\n\n# 包含テストでのリスト vs セット\nlarge_list = list(range(10000))\nlarge_set = set(range(10000))\n\n# リストの検索時間\nstart = time.time()\n9999 in large_list\nlist_time = time.time() - start\n\n# セットの検索時間\nstart = time.time()\n9999 in large_set\nset_time = time.time() - start\n\nprint(f\"リスト検索: {list_time:.6f} 秒\")\nprint(f\"セット検索: {set_time:.6f} 秒\")\nprint(f\"包含テストでセットは{list_time/set_time:.1f}倍高速\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#次のステップ",
    "href": "book/04-data-types.html#次のステップ",
    "title": "4  データ型とコレクション",
    "section": "7.6 次のステップ",
    "text": "7.6 次のステップ\n素晴らしい！Python の核となるデータ構造を理解しました。次は 制御フロー について学び、プログラムで判断を下し、アクションを繰り返す方法を学びましょう。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#リソース",
    "href": "book/04-data-types.html#リソース",
    "title": "4  データ型とコレクション",
    "section": "7.7 リソース",
    "text": "7.7 リソース\n\nPython データ構造ドキュメント\nReal Python: Python データ構造\nCollections モジュール",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html",
    "href": "book/05-control-flow.html",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "",
    "text": "5.1 条件文 - if、elif、else\n制御フロー文により、プログラムが条件に基づいて判断を行い、処理を繰り返すことができます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#条件文---ifelifelse",
    "href": "book/05-control-flow.html#条件文---ifelifelse",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "",
    "text": "5.1.1 基本的な if 文\n\nage = 18\n\nif age &gt;= 18:\n    print(\"あなたは成人です\")\n    print(\"投票できます\")\n\nprint(\"この行は常に実行されます\")\n\n\n\n5.1.2 if-else 文\n\ntemperature = 25\n\nif temperature &gt; 30:\n    print(\"外は暑いです！\")\n    print(\"水分補給を忘れずに\")\nelse:\n    print(\"それほど暑くありません\")\n    print(\"完璧な天気です\")\n\nprint(f\"現在の気温: {temperature}°C\")\n\n\n\n5.1.3 if-elif-else チェーン\n\nscore = 85\n\nif score &gt;= 90:\n    grade = \"A\"\n    message = \"素晴らしい！\"\nelif score &gt;= 80:\n    grade = \"B\"\n    message = \"よくできました！\"\nelif score &gt;= 70:\n    grade = \"C\"\n    message = \"頑張り続けましょう！\"\nelif score &gt;= 60:\n    grade = \"D\"\n    message = \"改善が必要です\"\nelse:\n    grade = \"F\"\n    message = \"もっと勉強しましょう\"\n\nprint(f\"得点: {score}\")\nprint(f\"評価: {grade}\")\nprint(f\"コメント: {message}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#ループ---処理の繰り返し",
    "href": "book/05-control-flow.html#ループ---処理の繰り返し",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.2 ループ - 処理の繰り返し",
    "text": "5.2 ループ - 処理の繰り返し\n\n5.2.1 for ループ\n\n# リストを使った繰り返し\nfruits = [\"りんご\", \"バナナ\", \"さくらんぼ\"]\n\nfor fruit in fruits:\n    print(f\"私は{fruit}が好きです\")\n\n\n# range() を使った数値の繰り返し\nprint(\"1から5までの数字:\")\nfor i in range(1, 6):\n    print(f\"数字: {i}\")\n\n\n# 九九の表\nprint(\"九九の表:\")\nfor i in range(1, 10):\n    for j in range(1, 10):\n        result = i * j\n        print(f\"{i} × {j} = {result:2d}\", end=\"  \")\n    print()  # 改行\n\n\n\n5.2.2 while ループ\n\n# カウントダウン\ncount = 5\nprint(\"カウントダウン開始:\")\n\nwhile count &gt; 0:\n    print(f\"{count}...\")\n    count -= 1\n\nprint(\"発射！🚀\")\n\n\n# ユーザー入力のシミュレーション（実際の例）\nimport random\n\n# ランダムな数字を生成\nsecret_number = random.randint(1, 10)\nattempts = 0\nmax_attempts = 3\n\nprint(\"1から10の数字を当ててください！\")\nprint(f\"ヒント: 秘密の数字は {secret_number} です（実際のゲームでは表示されません）\")\n\n# シミュレートされた推測\nguesses = [5, 8, secret_number]  # 実際の例では input() を使用\n\nfor guess in guesses:\n    attempts += 1\n    print(f\"推測 {attempts}: {guess}\")\n    \n    if guess == secret_number:\n        print(\"正解です！🎉\")\n        break\n    elif guess &lt; secret_number:\n        print(\"もっと大きい数字です\")\n    else:\n        print(\"もっと小さい数字です\")\n    \n    if attempts &gt;= max_attempts:\n        print(f\"残念！正解は {secret_number} でした\")\n        break",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#ループ制御文",
    "href": "book/05-control-flow.html#ループ制御文",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.3 ループ制御文",
    "text": "5.3 ループ制御文\n\n5.3.1 break - ループの中断\n\n# 特定の条件でループを終了\nnumbers = [1, 3, 5, 8, 9, 11, 13]\n\nprint(\"最初の偶数を探しています...\")\nfor num in numbers:\n    print(f\"チェック中: {num}\")\n    if num % 2 == 0:\n        print(f\"見つかりました！最初の偶数は {num} です\")\n        break\nelse:\n    print(\"偶数が見つかりませんでした\")\n\n\n\n5.3.2 continue - 次の反復へスキップ\n\n# 奇数のみを表示\nprint(\"1から10の奇数:\")\nfor i in range(1, 11):\n    if i % 2 == 0:  # 偶数の場合\n        continue    # 残りの処理をスキップ\n    print(f\"奇数: {i}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#実践的な例",
    "href": "book/05-control-flow.html#実践的な例",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.4 実践的な例",
    "text": "5.4 実践的な例\n\n5.4.1 成績計算システム\n\n# 学生の成績を処理\nstudents = [\n    {\"名前\": \"田中\", \"得点\": [85, 90, 78]},\n    {\"名前\": \"鈴木\", \"得点\": [92, 88, 95]},\n    {\"名前\": \"佐藤\", \"得点\": [76, 82, 80]}\n]\n\nprint(\"=== 成績レポート ===\")\nfor student in students:\n    name = student[\"名前\"]\n    scores = student[\"得点\"]\n    \n    # 平均点を計算\n    average = sum(scores) / len(scores)\n    \n    # 評価を決定\n    if average &gt;= 90:\n        grade = \"A\"\n    elif average &gt;= 80:\n        grade = \"B\"\n    elif average &gt;= 70:\n        grade = \"C\"\n    else:\n        grade = \"D\"\n    \n    print(f\"学生: {name}\")\n    print(f\"  得点: {scores}\")\n    print(f\"  平均: {average:.1f}\")\n    print(f\"  評価: {grade}\")\n    print()\n\n\n\n5.4.2 パスワード強度チェッカー\n\ndef check_password_strength(password):\n    \"\"\"パスワードの強度をチェックする関数\"\"\"\n    \n    # 初期設定\n    score = 0\n    feedback = []\n    \n    # 長さをチェック\n    if len(password) &gt;= 8:\n        score += 1\n    else:\n        feedback.append(\"8文字以上にしてください\")\n    \n    # 文字の種類をチェック\n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    has_special = any(c in \"!@#$%^&*\" for c in password)\n    \n    if has_upper:\n        score += 1\n    else:\n        feedback.append(\"大文字を含めてください\")\n        \n    if has_lower:\n        score += 1\n    else:\n        feedback.append(\"小文字を含めてください\")\n        \n    if has_digit:\n        score += 1\n    else:\n        feedback.append(\"数字を含めてください\")\n        \n    if has_special:\n        score += 1\n    else:\n        feedback.append(\"特殊文字を含めてください\")\n    \n    # 強度を評価\n    if score &gt;= 4:\n        strength = \"強い\"\n    elif score &gt;= 3:\n        strength = \"普通\"\n    else:\n        strength = \"弱い\"\n    \n    return strength, feedback\n\n# テスト例\ntest_passwords = [\"123\", \"password\", \"Password1\", \"MyStrongP@ss1\"]\n\nfor password in test_passwords:\n    strength, feedback = check_password_strength(password)\n    print(f\"パスワード: '{password}'\")\n    print(f\"強度: {strength}\")\n    if feedback:\n        print(\"改善点:\")\n        for suggestion in feedback:\n            print(f\"  - {suggestion}\")\n    print()",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#練習問題",
    "href": "book/05-control-flow.html#練習問題",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.5 練習問題",
    "text": "5.5 練習問題\n\n5.5.1 問題 1: FizzBuzz\n1から30までの数字を表示し、以下のルールに従ってください： - 3の倍数の場合は “Fizz” を表示 - 5の倍数の場合は “Buzz” を表示\n- 3と5の両方の倍数の場合は “FizzBuzz” を表示\n\nprint(\"=== FizzBuzz ===\")\nfor i in range(1, 31):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)\n\n\n\n5.5.2 問題 2: 素数判定\n\ndef is_prime(n):\n    \"\"\"数字が素数かどうかを判定\"\"\"\n    if n &lt; 2:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# 1から50までの素数を表示\nprint(\"1から50までの素数:\")\nprimes = []\nfor num in range(1, 51):\n    if is_prime(num):\n        primes.append(num)\n\nprint(primes)\nprint(f\"見つかった素数の数: {len(primes)}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#まとめ",
    "href": "book/05-control-flow.html#まとめ",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.6 まとめ",
    "text": "5.6 まとめ\nこの章では以下を学習しました：\n\n条件文: if、elif、else を使った判断処理\nループ: for と while を使った繰り返し処理\nループ制御: break と continue の使い方\n実践例: 成績処理、パスワード強度チェック\nアルゴリズム: FizzBuzz、素数判定\n\n制御フローはプログラミングの基本中の基本です。これらの概念をしっかりと理解し、様々な問題解決に活用しましょう。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#次の章",
    "href": "book/05-control-flow.html#次の章",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.7 次の章",
    "text": "5.7 次の章\n次は関数について学習し、コードを整理して再利用可能にする方法を学びます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html",
    "href": "book/06-functions.html",
    "title": "6  関数",
    "section": "",
    "text": "学習目標\n関数は、特定のタスクを実行する再利用可能なコードブロックです。プログラムを整理し、コードの重複を避けるのに役立ちます。\nこの章では以下を学習します：",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#学習目標",
    "href": "book/06-functions.html#学習目標",
    "title": "6  関数",
    "section": "",
    "text": "関数の定義と呼び出し\nパラメータと戻り値の使用\nデフォルトパラメータとキーワード引数\nスコープと変数の有効範囲\n関数のベストプラクティス",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#関数とは",
    "href": "book/06-functions.html#関数とは",
    "title": "6  関数",
    "section": "6.1 関数とは",
    "text": "6.1 関数とは\n関数は特定のタスクを実行するコードブロックで、プログラム内で何度でも呼び出すことができます。関数を使用することで：\n\nコードの再利用性：一度書けば何度でも使用可能\n組織化：複雑な問題を小さな部分に分割\n保守性：一箇所の変更が全ての使用箇所に反映\nテスト性：個別の部分をテストしやすい\n\n# 基本的な関数の例\ndef greet(name):\n    return f\"こんにちは、{name}さん！\"\n\nmessage = greet(\"太郎\")\nprint(message)  # 出力: こんにちは、太郎さん！",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#関数の構文",
    "href": "book/06-functions.html#関数の構文",
    "title": "6  関数",
    "section": "6.2 関数の構文",
    "text": "6.2 関数の構文\ndef 関数名(パラメータ):\n    \"\"\"オプションのドキュメント文字列\"\"\"\n    # 関数本体\n    return 値  # オプション\n主要な構成要素：\n\ndefキーワードで関数定義を開始\n関数名はPythonの命名規則に従う\nパラメータは入力値（オプション）\n:は関数本体の開始を示す\nインデントされたコードが関数本体\nreturn文で出力値を返す（オプション）",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#基本的な関数",
    "href": "book/06-functions.html#基本的な関数",
    "title": "6  関数",
    "section": "6.3 基本的な関数",
    "text": "6.3 基本的な関数\n\n6.3.1 パラメータなしの関数\ndef say_hello():\n    print(\"Hello, World!\")\n\nsay_hello()  # 関数の呼び出し\n\n\n6.3.2 値を返す関数\ndef get_pi():\n    return 3.14159\n\npi_value = get_pi()\nprint(f\"円周率は約{pi_value}です\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#パラメータを持つ関数",
    "href": "book/06-functions.html#パラメータを持つ関数",
    "title": "6  関数",
    "section": "6.4 パラメータを持つ関数",
    "text": "6.4 パラメータを持つ関数\n\n6.4.1 単一パラメータ\ndef square(number):\n    return number * number\n\nresult = square(5)\nprint(result)  # 出力: 25\n\n\n6.4.2 複数パラメータ\ndef add_numbers(a, b):\n    return a + b\n\nsum_result = add_numbers(10, 20)\nprint(sum_result)  # 出力: 30",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#デフォルトパラメータ",
    "href": "book/06-functions.html#デフォルトパラメータ",
    "title": "6  関数",
    "section": "6.5 デフォルトパラメータ",
    "text": "6.5 デフォルトパラメータ\nパラメータにデフォルト値を設定できます：\ndef greet(name, greeting=\"こんにちは\"):\n    return f\"{greeting}、{name}さん！\"\n\nprint(greet(\"太郎\"))           # こんにちは、太郎さん！\nprint(greet(\"花子\", \"おはよう\"))  # おはよう、花子さん！\nデフォルト値を持つパラメータは、持たないパラメータの後に配置する必要があります：\ndef create_profile(name, age=25, city=\"不明\"):\n    return f\"{name}、{age}歳、{city}出身\"\n\nprint(create_profile(\"太郎\"))\nprint(create_profile(\"花子\", 30))\nprint(create_profile(\"次郎\", 28, \"東京\"))",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#キーワード引数",
    "href": "book/06-functions.html#キーワード引数",
    "title": "6  関数",
    "section": "6.6 キーワード引数",
    "text": "6.6 キーワード引数\nパラメータ名を指定して関数を呼び出すことができます：\ndef describe_pet(name, animal_type, age):\n    return f\"{name}は{age}歳の{animal_type}です\"\n\n# 位置引数\nprint(describe_pet(\"ポチ\", \"犬\", 3))\n\n# キーワード引数\nprint(describe_pet(name=\"ミケ\", animal_type=\"猫\", age=2))\nprint(describe_pet(age=1, name=\"金魚\", animal_type=\"魚\"))",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#可変長引数",
    "href": "book/06-functions.html#可変長引数",
    "title": "6  関数",
    "section": "6.7 可変長引数",
    "text": "6.7 可変長引数\n\n6.7.1 *args：可変個の位置引数\ndef sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3))        # 6\nprint(sum_all(1, 2, 3, 4, 5))  # 15\n\n\n6.7.2 **kwargs：可変個のキーワード引数\ndef create_student(**info):\n    for key, value in info.items():\n        print(f\"{key}: {value}\")\n\ncreate_student(name=\"太郎\", age=20, major=\"コンピュータサイエンス\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#ローカルスコープとグローバルスコープ",
    "href": "book/06-functions.html#ローカルスコープとグローバルスコープ",
    "title": "6  関数",
    "section": "6.8 ローカルスコープとグローバルスコープ",
    "text": "6.8 ローカルスコープとグローバルスコープ\n\n6.8.1 ローカル変数\n関数内で定義された変数は、その関数内でのみ使用できます：\nx = 10  # グローバル変数\n\ndef test_scope():\n    x = 20  # ローカル変数\n    print(f\"関数内: {x}\")\n\ntest_scope()           # 関数内: 20\nprint(f\"関数外: {x}\")   # 関数外: 10\n\n\n6.8.2 globalキーワード\ncounter = 0  # グローバル変数\n\ndef increment():\n    global counter\n    counter += 1\n\nincrement()\nprint(counter)  # 出力: 1",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#return文",
    "href": "book/06-functions.html#return文",
    "title": "6  関数",
    "section": "6.9 return文",
    "text": "6.9 return文\n関数は任意のデータ型を返すことができます：\ndef get_name_length(name):\n    return len(name)\n\ndef get_user_info():\n    return \"太郎\", 25, \"エンジニア\"  # タプルを返す\n\ndef is_even(number):\n    return number % 2 == 0  # ブール値を返す\n\nname, age, job = get_user_info()\n条件によって早期リターンを行うことも可能です：\ndef calculate_grade(score):\n    if score &gt;= 90:\n        return \"優\"\n    elif score &gt;= 80:\n        return \"良\"\n    elif score &gt;= 70:\n        return \"可\"\n    else:\n        return \"不可\"",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#ドキュメント文字列",
    "href": "book/06-functions.html#ドキュメント文字列",
    "title": "6  関数",
    "section": "6.10 ドキュメント文字列",
    "text": "6.10 ドキュメント文字列\n関数の動作を説明するドキュメントを追加できます：\ndef calculate_area(length, width):\n    \"\"\"\n    長方形の面積を計算します。\n    \n    Args:\n        length (float): 長方形の長さ\n        width (float): 長方形の幅\n    \n    Returns:\n        float: 長方形の面積\n    \"\"\"\n    return length * width\n\n# ドキュメント文字列へのアクセス\nprint(calculate_area.__doc__)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#実用例電卓",
    "href": "book/06-functions.html#実用例電卓",
    "title": "6  関数",
    "section": "6.11 実用例：電卓",
    "text": "6.11 実用例：電卓\ndef add(a, b):\n    \"\"\"二つの数を足します。\"\"\"\n    return a + b\n\ndef subtract(a, b):\n    \"\"\"第一の数から第二の数を引きます。\"\"\"\n    return a - b\n\ndef multiply(a, b):\n    \"\"\"二つの数を掛けます。\"\"\"\n    return a * b\n\ndef divide(a, b):\n    \"\"\"第一の数を第二の数で割ります。\"\"\"\n    if b != 0:\n        return a / b\n    else:\n        return \"エラー: ゼロ除算です！\"\n\n# 電卓の使用\nresult1 = add(10, 5)      # 15\nresult2 = subtract(10, 5) # 5\nresult3 = multiply(10, 5) # 50\nresult4 = divide(10, 5)   # 2.0",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#演習問題",
    "href": "book/06-functions.html#演習問題",
    "title": "6  関数",
    "section": "演習問題",
    "text": "演習問題\n\n6.11.1 演習 1：温度変換器\n摂氏と華氏の温度変換を行う関数を作成してください：\ndef celsius_to_fahrenheit(celsius):\n    # ここにコードを書いてください\n    pass\n\ndef fahrenheit_to_celsius(fahrenheit):\n    # ここにコードを書いてください\n    pass\n\n# テスト\nprint(celsius_to_fahrenheit(0))   # 32になるはず\nprint(fahrenheit_to_celsius(32))  # 0になるはず\n\n\n6.11.2 演習 2：パスワード検証器\nパスワードが有効かどうかを判定する関数を作成してください：\ndef is_valid_password(password):\n    # パスワードが8文字以上で、\n    # 文字と数字の両方を含むかチェック\n    pass\n\n# テスト\nprint(is_valid_password(\"abc123\"))      # False (短すぎる)\nprint(is_valid_password(\"abcdefgh\"))    # False (数字がない)\nprint(is_valid_password(\"abc12345\"))    # True\n\n\n6.11.3 演習 3：リスト操作\nリストの統計情報を計算する関数を作成してください：\ndef calculate_stats(numbers):\n    # 最小値、最大値、平均値を計算して辞書で返す\n    pass\n\n# テスト\nstats = calculate_stats([1, 2, 3, 4, 5])\nprint(stats)  # {'min': 1, 'max': 5, 'average': 3.0}",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#解答例",
    "href": "book/06-functions.html#解答例",
    "title": "6  関数",
    "section": "解答例",
    "text": "解答例\n\n6.11.4 演習 1の解答\ndef celsius_to_fahrenheit(celsius):\n    return (celsius * 9/5) + 32\n\ndef fahrenheit_to_celsius(fahrenheit):\n    return (fahrenheit - 32) * 5/9\n\n\n6.11.5 演習 2の解答\ndef is_valid_password(password):\n    if len(password) &lt; 8:\n        return False\n    \n    has_letter = any(char.isalpha() for char in password)\n    has_number = any(char.isdigit() for char in password)\n    \n    return has_letter and has_number\n\n\n6.11.6 演習 3の解答\ndef calculate_stats(numbers):\n    if not numbers:\n        return None\n    \n    return {\n        'min': min(numbers),\n        'max': max(numbers),\n        'average': sum(numbers) / len(numbers)\n    }",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#ベストプラクティス",
    "href": "book/06-functions.html#ベストプラクティス",
    "title": "6  関数",
    "section": "6.12 ベストプラクティス",
    "text": "6.12 ベストプラクティス\n\nわかりやすい名前を使用: calculate_tax()はcalc()より良い\n関数は一つの責任を持つ: 一つの関数、一つの役割\nドキュメント文字列を使用: 関数の動作を文書化\n副作用を避ける: 関数は予測可能であるべき\n早期リターンを使用: より綺麗なコードのため\n関数をテストする: 様々なシナリオでテストケースを作成",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#まとめ",
    "href": "book/06-functions.html#まとめ",
    "title": "6  関数",
    "section": "6.13 まとめ",
    "text": "6.13 まとめ\n\n関数は再利用可能なコードブロックでプログラムを整理する\nパラメータを受け取り、値を返すことができる\nデフォルトパラメータで柔軟性を提供\n可変長引数で未知の数の引数を処理\nスコープは変数がアクセスできる場所を決定\nドキュメント文字列で関数を文書化\nベストプラクティスに従って綺麗で保守可能なコードを作成",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#次のステップ",
    "href": "book/06-functions.html#次のステップ",
    "title": "6  関数",
    "section": "6.14 次のステップ",
    "text": "6.14 次のステップ\n次章では、エラー処理と例外について学習し、より堅牢なプログラムの作成方法を学びます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/06-functions.html#自己確認",
    "href": "book/06-functions.html#自己確認",
    "title": "6  関数",
    "section": "自己確認",
    "text": "自己確認\n\n関数を使用する主な利点は何ですか？\nデフォルトパラメータとキーワード引数の違いは何ですか？\n*argsと**kwargsの用途は何ですか？\nローカルスコープとグローバルスコープの違いを説明してください。\n良い関数を作成するためのベストプラクティスを3つ挙げてください。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html",
    "href": "book/07-error-handling.html",
    "title": "7  エラー処理",
    "section": "",
    "text": "学習目標\nエラーはプログラム実行中に発生する問題です。適切にエラーを処理することで、プログラムをより堅牢で使いやすくできます。\nこの章では以下を学習します：",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#学習目標",
    "href": "book/07-error-handling.html#学習目標",
    "title": "7  エラー処理",
    "section": "",
    "text": "エラーと例外の種類\ntry-except文を使用したエラー処理\nfinally句とelse句の使用\nカスタム例外の作成\nデバッグ技術",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#エラーとは",
    "href": "book/07-error-handling.html#エラーとは",
    "title": "7  エラー処理",
    "section": "7.1 エラーとは",
    "text": "7.1 エラーとは\nエラーは、プログラム実行中に発生する問題で、適切に処理されないとプログラムが停止します。Pythonはエラーを優雅に捕捉し処理するメカニズムを提供しています。\n# これはエラーを引き起こします！\nnumber = int(\"hello\")  # ValueError: invalid literal",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#エラーの種類",
    "href": "book/07-error-handling.html#エラーの種類",
    "title": "7  エラー処理",
    "section": "7.2 エラーの種類",
    "text": "7.2 エラーの種類\n\n7.2.1 構文エラー\n# コロンの欠落\nif x &gt; 5\n    print(\"5より大きい\")\n\n# 括弧の不一致\nprint(\"Hello\"\n\n\n7.2.2 実行時エラー（例外）\n# ゼロ除算\nresult = 10 / 0\n\n# 存在しないインデックスへのアクセス\nnumbers = [1, 2, 3]\nprint(numbers[5])\n\n# 間違ったデータ型\nint(\"hello\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#一般的な例外の種類",
    "href": "book/07-error-handling.html#一般的な例外の種類",
    "title": "7  エラー処理",
    "section": "7.3 一般的な例外の種類",
    "text": "7.3 一般的な例外の種類\n# ValueError: データ型に対して間違った値\nint(\"abc\")\nfloat(\"hello\")\n\n# TypeError: 間違ったデータ型\n\"hello\" + 5\nlen(42)\n\n# IndexError: リストのインデックスが範囲外\nmy_list = [1, 2, 3]\nmy_list[10]\n\n# KeyError: 辞書のキーが存在しない\nmy_dict = {\"name\": \"太郎\"}\nmy_dict[\"age\"]\n\n# FileNotFoundError: ファイルが存在しない\nopen(\"nonexistent.txt\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#try-except文",
    "href": "book/07-error-handling.html#try-except文",
    "title": "7  エラー処理",
    "section": "7.4 try-except文",
    "text": "7.4 try-except文\n\n7.4.1 基本構文\ntry:\n    # エラーが発生する可能性のあるコード\n    risky_code()\nexcept ExceptionType:\n    # エラーを処理するコード\n    handle_error()\n\n\n7.4.2 簡単な例\ntry:\n    number = int(input(\"数字を入力してください: \"))\n    result = 10 / number\n    print(f\"結果: {result}\")\nexcept ValueError:\n    print(\"有効な数字を入力してください！\")\nexcept ZeroDivisionError:\n    print(\"ゼロで割ることはできません！\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#複数の例外の処理",
    "href": "book/07-error-handling.html#複数の例外の処理",
    "title": "7  エラー処理",
    "section": "7.5 複数の例外の処理",
    "text": "7.5 複数の例外の処理\n\n7.5.1 複数のexcept文\ntry:\n    age = int(input(\"年齢を入力してください: \"))\n    category = determine_category(age)\n    print(f\"あなたは{category}カテゴリです\")\nexcept ValueError:\n    print(\"年齢は数字で入力してください！\")\nexcept TypeError:\n    print(\"無効な年齢フォーマットです！\")\nexcept Exception as e:\n    print(f\"予期しないエラーが発生しました: {e}\")\n\n\n7.5.2 複数の例外を一緒に処理\ntry:\n    # 何らかのリスクのある操作\n    process_data()\nexcept (ValueError, TypeError, IndexError):\n    print(\"データ処理エラーが発生しました！\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#else句とfinally句",
    "href": "book/07-error-handling.html#else句とfinally句",
    "title": "7  エラー処理",
    "section": "7.6 else句とfinally句",
    "text": "7.6 else句とfinally句\n\n7.6.1 else句：例外が発生しなかった場合に実行\ntry:\n    number = int(input(\"数字を入力してください: \"))\nexcept ValueError:\n    print(\"無効な入力です！\")\nelse:\n    print(f\"入力した数字: {number}\")\n    # これは例外が発生しなかった場合のみ実行される\n\n\n7.6.2 finally句：常に実行される（クリーンアップコード）\ntry:\n    file = open(\"data.txt\", \"r\")\n    content = file.read()\nexcept FileNotFoundError:\n    print(\"ファイルが見つかりません！\")\nfinally:\n    # これは常に実行される - クリーンアップに適している\n    if 'file' in locals():\n        file.close()",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#例外情報の取得",
    "href": "book/07-error-handling.html#例外情報の取得",
    "title": "7  エラー処理",
    "section": "7.7 例外情報の取得",
    "text": "7.7 例外情報の取得\n\n7.7.1 例外の詳細を捕捉\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"エラータイプ: {type(e).__name__}\")\n    print(f\"エラーメッセージ: {e}\")\n    print(\"ゼロで割ることはできません！\")\n\n\n7.7.2 一般的な例外ハンドラー\ntry:\n    # 失敗する可能性のある操作\n    risky_operation()\nexcept Exception as e:\n    print(f\"何かが間違いました: {e}\")\n    # デバッグ用にエラーをログに記録\n    import traceback\n    traceback.print_exc()",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#カスタム例外の発生",
    "href": "book/07-error-handling.html#カスタム例外の発生",
    "title": "7  エラー処理",
    "section": "7.8 カスタム例外の発生",
    "text": "7.8 カスタム例外の発生\n\n7.8.1 raise文の使用\ndef validate_age(age):\n    if age &lt; 0:\n        raise ValueError(\"年齢は負の値にできません！\")\n    if age &gt; 150:\n        raise ValueError(\"年齢が非現実的です！\")\n    return True\n\ntry:\n    age = -5\n    validate_age(age)\nexcept ValueError as e:\n    print(f\"検証エラー: {e}\")\n\n\n7.8.2 例外の再発生\ntry:\n    process_data()\nexcept ValueError:\n    print(\"エラーをログに記録中...\")\n    raise  # 同じ例外を再発生",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#カスタム例外クラス",
    "href": "book/07-error-handling.html#カスタム例外クラス",
    "title": "7  エラー処理",
    "section": "7.9 カスタム例外クラス",
    "text": "7.9 カスタム例外クラス\n\n7.9.1 独自の例外タイプの作成\nclass InvalidEmailError(Exception):\n    \"\"\"無効なメールアドレスが提供された場合に発生\"\"\"\n    pass\n\nclass PasswordTooWeakError(Exception):\n    \"\"\"パスワードが要件を満たさない場合に発生\"\"\"\n    def __init__(self, message, min_length=8):\n        self.message = message\n        self.min_length = min_length\n        super().__init__(self.message)\n\ndef validate_password(password):\n    if len(password) &lt; 8:\n        raise PasswordTooWeakError(\n            \"パスワードが短すぎます\", \n            min_length=8\n        )",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#ファイル処理でのエラー管理",
    "href": "book/07-error-handling.html#ファイル処理でのエラー管理",
    "title": "7  エラー処理",
    "section": "7.10 ファイル処理でのエラー管理",
    "text": "7.10 ファイル処理でのエラー管理\n\n7.10.1 安全なファイル操作\ndef read_file_safely(filename):\n    try:\n        with open(filename, 'r', encoding='utf-8') as file:\n            return file.read()\n    except FileNotFoundError:\n        print(f\"ファイル'{filename}'が見つかりません！\")\n        return None\n    except PermissionError:\n        print(f\"ファイル'{filename}'を読む権限がありません！\")\n        return None\n    except Exception as e:\n        print(f\"ファイル読み込みエラー: {e}\")\n        return None\n\ncontent = read_file_safely(\"data.txt\")\nif content:\n    print(\"ファイルの読み込みに成功しました！\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#ユーザー入力の検証",
    "href": "book/07-error-handling.html#ユーザー入力の検証",
    "title": "7  エラー処理",
    "section": "7.11 ユーザー入力の検証",
    "text": "7.11 ユーザー入力の検証\n\n7.11.1 堅牢な入力処理\ndef get_integer_input(prompt, min_val=None, max_val=None):\n    while True:\n        try:\n            value = int(input(prompt))\n            \n            if min_val is not None and value &lt; min_val:\n                print(f\"値は最低{min_val}である必要があります\")\n                continue\n                \n            if max_val is not None and value &gt; max_val:\n                print(f\"値は最大{max_val}である必要があります\")\n                continue\n                \n            return value\n            \n        except ValueError:\n            print(\"有効な整数を入力してください！\")\n        except KeyboardInterrupt:\n            print(\"\\nユーザーによって操作がキャンセルされました。\")\n            return None\n\nage = get_integer_input(\"年齢を入力してください (0-120): \", 0, 120)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#デバッグ技術",
    "href": "book/07-error-handling.html#デバッグ技術",
    "title": "7  エラー処理",
    "section": "7.12 デバッグ技術",
    "text": "7.12 デバッグ技術\n\n7.12.1 print文を使用したデバッグ\ndef calculate_average(numbers):\n    print(f\"デバッグ: 入力数値 = {numbers}\")  # デバッグ情報\n    \n    if not numbers:\n        print(\"デバッグ: 空のリストが検出されました\")     # デバッグ情報\n        return 0\n    \n    total = sum(numbers)\n    count = len(numbers)\n    average = total / count\n    \n    print(f\"デバッグ: total={total}, count={count}\")  # デバッグ情報\n    return average\n\n\n7.12.2 assert文の使用\ndef divide_numbers(a, b):\n    assert b != 0, \"ゼロ除算は許可されていません\"\n    assert isinstance(a, (int, float)), \"第一引数は数値である必要があります\"\n    assert isinstance(b, (int, float)), \"第二引数は数値である必要があります\"\n    \n    return a / b",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#実用例安全な電卓",
    "href": "book/07-error-handling.html#実用例安全な電卓",
    "title": "7  エラー処理",
    "section": "7.13 実用例：安全な電卓",
    "text": "7.13 実用例：安全な電卓\nclass Calculator:\n    def safe_divide(self, a, b):\n        try:\n            # 入力の検証\n            if not isinstance(a, (int, float)):\n                raise TypeError(\"第一引数は数値である必要があります\")\n            if not isinstance(b, (int, float)):\n                raise TypeError(\"第二引数は数値である必要があります\")\n            if b == 0:\n                raise ZeroDivisionError(\"ゼロで割ることはできません\")\n            \n            result = a / b\n            return {\"success\": True, \"result\": result}\n            \n        except (TypeError, ZeroDivisionError) as e:\n            return {\"success\": False, \"error\": str(e)}\n        except Exception as e:\n            return {\"success\": False, \"error\": f\"予期しないエラー: {e}\"}\n\n# 使用方法\ncalc = Calculator()\nresult = calc.safe_divide(10, 2)\nif result[\"success\"]:\n    print(f\"結果: {result['result']}\")\nelse:\n    print(f\"エラー: {result['error']}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#演習問題",
    "href": "book/07-error-handling.html#演習問題",
    "title": "7  エラー処理",
    "section": "演習問題",
    "text": "演習問題\n\n7.13.1 演習 1：安全な数値変換器\ndef safe_int_convert(value):\n    \"\"\"\n    値を整数に安全に変換します。\n    戻り値: (success: bool, result: int または error_message: str)\n    \"\"\"\n    # ここにコードを書いてください\n    pass\n\n# テストケース\nprint(safe_int_convert(\"123\"))      # 動作するはず\nprint(safe_int_convert(\"12.34\"))    # 浮動小数点文字列を処理\nprint(safe_int_convert(\"hello\"))    # 無効な入力を処理\n\n\n7.13.2 演習 2：リストの安全なアクセス\ndef safe_list_access(my_list, index):\n    \"\"\"\n    インデックスでリスト要素に安全にアクセスします。\n    要素またはインデックスが無効な場合はデフォルトメッセージを返します。\n    \"\"\"\n    # ここにコードを書いてください\n    pass",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#解答例",
    "href": "book/07-error-handling.html#解答例",
    "title": "7  エラー処理",
    "section": "解答例",
    "text": "解答例\n\n7.13.3 演習 1の解答\ndef safe_int_convert(value):\n    try:\n        # 直接変換を最初に試す\n        return True, int(value)\n    except ValueError:\n        try:\n            # 浮動小数点文字列から整数への変換を試す\n            return True, int(float(value))\n        except ValueError:\n            return False, f\"'{value}'を整数に変換できません\"\n    except Exception as e:\n        return False, f\"予期しないエラー: {e}\"\n\n\n7.13.4 演習 2の解答\ndef safe_list_access(my_list, index):\n    try:\n        return my_list[index]\n    except IndexError:\n        return f\"インデックス {index} は範囲外です\"\n    except TypeError:\n        return \"無効なインデックスタイプです\"",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#ベストプラクティス",
    "href": "book/07-error-handling.html#ベストプラクティス",
    "title": "7  エラー処理",
    "section": "7.14 ベストプラクティス",
    "text": "7.14 ベストプラクティス\n\n具体的に: Exceptionだけでなく、特定の例外を捕捉する\nエラーを無視しない: 例外を適切に処理する\n意味のあるエラーメッセージ: ユーザーが何が間違ったかを理解できるように\nエラーをログに記録: デバッグのためにエラーを追跡\n優雅に失敗: 可能であればフォールバックオプションを提供\nリソースをクリーンアップ: finallyまたはwith文を使用\n捕捉して無視しない: 例外を捕捉したら、何かをする",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#高度なトピックコンテキストマネージャー",
    "href": "book/07-error-handling.html#高度なトピックコンテキストマネージャー",
    "title": "7  エラー処理",
    "section": "7.15 高度なトピック：コンテキストマネージャー",
    "text": "7.15 高度なトピック：コンテキストマネージャー\n\n7.15.1 with文による自動クリーンアップ\n# コンテキストマネージャーなし\ntry:\n    file = open(\"data.txt\", \"r\")\n    content = file.read()\n    # コンテンツを処理\nexcept FileNotFoundError:\n    print(\"ファイルが見つかりません！\")\nfinally:\n    file.close()  # 閉じることを覚えておく必要がある\n\n# コンテキストマネージャーあり（より良い！）\ntry:\n    with open(\"data.txt\", \"r\") as file:\n        content = file.read()\n        # 'with'ブロックを離れるときにファイルが自動的に閉じられる\nexcept FileNotFoundError:\n    print(\"ファイルが見つかりません！\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#一般的なアンチパターン",
    "href": "book/07-error-handling.html#一般的なアンチパターン",
    "title": "7  エラー処理",
    "section": "7.16 一般的なアンチパターン",
    "text": "7.16 一般的なアンチパターン\n\n7.16.1 やってはいけないこと\n# 悪い例: 処理せずにすべての例外を捕捉\ntry:\n    risky_operation()\nexcept:\n    pass  # エラーを静かに無視\n\n# 悪い例: 過度に広い例外処理\ntry:\n    specific_operation()\nexcept Exception:\n    print(\"何かが間違いました\")  # 役に立たない\n\n# 悪い例: 制御フローに例外を使用\ntry:\n    value = my_dict[\"key\"]\nexcept KeyError:\n    value = \"default\"  # 代わりに.get()を使用",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#まとめ",
    "href": "book/07-error-handling.html#まとめ",
    "title": "7  エラー処理",
    "section": "7.17 まとめ",
    "text": "7.17 まとめ\n\nエラーはプログラミングにおいて避けられない - 優雅に処理する\ntry-exceptブロックを使用して例外を捕捉し処理する\n捕捉する例外について具体的にする\n常に実行されるクリーンアップコードにはfinallyを使用\nユーザーを助けるために意味のあるエラーメッセージを提供\nリソース管理にはコンテキストマネージャーの使用を検討\nprint文とロギングを使用して体系的にデバッグ",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#次のステップ",
    "href": "book/07-error-handling.html#次のステップ",
    "title": "7  エラー処理",
    "section": "7.18 次のステップ",
    "text": "7.18 次のステップ\n次章では、モジュールとパッケージについて学習し、コードをより良く整理し再利用する方法を学びます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/07-error-handling.html#自己確認",
    "href": "book/07-error-handling.html#自己確認",
    "title": "7  エラー処理",
    "section": "自己確認",
    "text": "自己確認\n\n構文エラーと実行時エラーの違いは何ですか？\nfinally句はいつ使用しますか？\nカスタム例外を作成する利点は何ですか？\nwith文を使用する理由は何ですか？\n効果的なエラー処理のベストプラクティスを3つ挙げてください。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>エラー処理</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html",
    "href": "book/08-modules.html",
    "title": "8  モジュールとパッケージ",
    "section": "",
    "text": "学習目標\nモジュールは、インポートして使用できるPythonコードを含むファイルです。コードを論理的な単位に整理し、再利用性と保守性を向上させます。\nこの章では以下を学習します：",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#学習目標",
    "href": "book/08-modules.html#学習目標",
    "title": "8  モジュールとパッケージ",
    "section": "",
    "text": "モジュールとパッケージの概念\n組み込みモジュールの使用\nカスタムモジュールの作成\nパッケージの構造と作成\nインポート文の様々な形式",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#モジュールとは",
    "href": "book/08-modules.html#モジュールとは",
    "title": "8  モジュールとパッケージ",
    "section": "8.1 モジュールとは",
    "text": "8.1 モジュールとは\nモジュールは、Pythonコードを含む.pyファイルで、関数、クラス、変数を含むことができます。モジュールを使用することで：\n\nコードの組織化：関連する機能をグループ化\n再利用性：複数のプログラムでコードを使用\n名前空間管理：名前の衝突を回避\n保守性：更新とデバッグが容易\nコラボレーション：チームメンバーが異なるモジュールで作業可能\n\n# math_utils.py（モジュール）\ndef add(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\n\nPI = 3.14159",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#モジュールのインポート",
    "href": "book/08-modules.html#モジュールのインポート",
    "title": "8  モジュールとパッケージ",
    "section": "8.2 モジュールのインポート",
    "text": "8.2 モジュールのインポート\n\n8.2.1 モジュール全体をインポート\nimport math\n\nresult = math.sqrt(16)  # 4.0\nprint(math.pi)          # 3.141592653589793\n\n\n8.2.2 特定の関数をインポート\nfrom math import sqrt, pi\n\nresult = sqrt(16)  # math.sqrtは不要\nprint(pi)          # math.piは不要\n\n\n8.2.3 エイリアスを使用したインポート\nimport math as m\nimport numpy as np  # 一般的な慣例\n\nresult = m.sqrt(16)\narray = np.array([1, 2, 3])",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#異なるインポートスタイル",
    "href": "book/08-modules.html#異なるインポートスタイル",
    "title": "8  モジュールとパッケージ",
    "section": "8.3 異なるインポートスタイル",
    "text": "8.3 異なるインポートスタイル\n\n8.3.1 すべてをインポート（注意して使用）\nfrom math import *\n\nresult = sqrt(16)  # すべての関数が直接利用可能\n# 名前空間の汚染を引き起こす可能性！\n\n\n8.3.2 カスタム名でのインポート\nfrom math import sqrt as square_root\nfrom math import pi as PI_VALUE\n\nresult = square_root(16)\nprint(PI_VALUE)\n\n\n8.3.3 条件付きインポート\ntry:\n    import numpy as np\n    HAS_NUMPY = True\nexcept ImportError:\n    HAS_NUMPY = False\n    print(\"NumPyが利用できません\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#組み込みモジュール",
    "href": "book/08-modules.html#組み込みモジュール",
    "title": "8  モジュールとパッケージ",
    "section": "8.4 組み込みモジュール",
    "text": "8.4 組み込みモジュール\n\n8.4.1 一般的な組み込みモジュール\nimport os        # オペレーティングシステムインターフェース\nimport sys       # システム固有のパラメータ\nimport datetime  # 日付と時刻の処理\nimport random    # 乱数生成\nimport json      # JSONエンコーダー/デコーダー\nimport re        # 正規表現\nimport collections  # 特殊化されたコンテナデータ型\n\n\n8.4.2 使用例\nimport os\nprint(os.getcwd())  # 現在の作業ディレクトリ\n\nimport datetime\nnow = datetime.datetime.now()\nprint(now.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\nimport random\nnumber = random.randint(1, 100)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#カスタムモジュールの作成",
    "href": "book/08-modules.html#カスタムモジュールの作成",
    "title": "8  モジュールとパッケージ",
    "section": "8.5 カスタムモジュールの作成",
    "text": "8.5 カスタムモジュールの作成\n\n8.5.1 モジュールファイルの作成：calculator.py\n\"\"\"シンプルな電卓モジュール。\"\"\"\n\ndef add(a, b):\n    \"\"\"二つの数を足します。\"\"\"\n    return a + b\n\ndef subtract(a, b):\n    \"\"\"第二の数を第一の数から引きます。\"\"\"\n    return a - b\n\ndef multiply(a, b):\n    \"\"\"二つの数を掛けます。\"\"\"\n    return a * b\n\ndef divide(a, b):\n    \"\"\"第一の数を第二の数で割ります。\"\"\"\n    if b != 0:\n        return a / b\n    else:\n        raise ValueError(\"ゼロで割ることはできません！\")\n\n# モジュールレベル変数\nVERSION = \"1.0.0\"",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#カスタムモジュールの使用",
    "href": "book/08-modules.html#カスタムモジュールの使用",
    "title": "8  モジュールとパッケージ",
    "section": "8.6 カスタムモジュールの使用",
    "text": "8.6 カスタムモジュールの使用\n\n8.6.1 別のファイル：main.py\nimport calculator\n\n# 関数を使用\nresult1 = calculator.add(10, 5)\nresult2 = calculator.subtract(10, 5)\n\nprint(f\"加算: {result1}\")\nprint(f\"減算: {result2}\")\nprint(f\"電卓バージョン: {calculator.VERSION}\")\n\n\n8.6.2 または特定の関数をインポート\nfrom calculator import add, multiply, VERSION\n\nresult = add(10, 5)\nproduct = multiply(3, 4)\nprint(f\"バージョン: {VERSION}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#モジュール検索パス",
    "href": "book/08-modules.html#モジュール検索パス",
    "title": "8  モジュールとパッケージ",
    "section": "8.7 モジュール検索パス",
    "text": "8.7 モジュール検索パス\nPythonは以下の順序でモジュールを検索します：\nimport sys\nprint(sys.path)\n\n現在のディレクトリ\nPYTHONPATH環境変数のディレクトリ\n標準ライブラリディレクトリ\nsite-packagesディレクトリ（サードパーティパッケージ）\n\n\n8.7.1 カスタムパスの追加\nimport sys\nsys.path.append('/path/to/my/modules')\n\n# これで、そのディレクトリのモジュールが見つかります\nimport my_custom_module",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#パッケージ",
    "href": "book/08-modules.html#パッケージ",
    "title": "8  モジュールとパッケージ",
    "section": "8.8 パッケージ",
    "text": "8.8 パッケージ\nパッケージは複数のモジュールを含むディレクトリです：\nmy_package/\n├── __init__.py      # パッケージにする\n├── module1.py\n├── module2.py\n└── subpackage/\n    ├── __init__.py\n    └── module3.py\n\n8.8.1 __init__.pyファイル\n\nディレクトリをPythonパッケージにする\n空でも初期化コードを含んでも良い\nfrom package import *でインポートされるものを制御",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#パッケージの作成",
    "href": "book/08-modules.html#パッケージの作成",
    "title": "8  モジュールとパッケージ",
    "section": "8.9 パッケージの作成",
    "text": "8.9 パッケージの作成\n\n8.9.1 ディレクトリ構造\nmath_tools/\n├── __init__.py\n├── basic.py\n└── advanced.py\n\n\n8.9.2 math_tools/__init__.py\n\"\"\"数学ツールパッケージ。\"\"\"\nfrom .basic import add, subtract\nfrom .advanced import fibonacci, factorial\n\n__version__ = \"1.0.0\"\n__all__ = ['add', 'subtract', 'fibonacci', 'factorial']\n\n\n8.9.3 math_tools/basic.py\ndef add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#パッケージの使用",
    "href": "book/08-modules.html#パッケージの使用",
    "title": "8  モジュールとパッケージ",
    "section": "8.10 パッケージの使用",
    "text": "8.10 パッケージの使用\n# パッケージ全体をインポート\nimport math_tools\nresult = math_tools.add(5, 3)\n\n# 特定のモジュールをインポート\nfrom math_tools import basic\nresult = basic.add(5, 3)\n\n# 特定の関数をインポート\nfrom math_tools.basic import add\nresult = add(5, 3)\n\n# パッケージルートからインポート（__init__.pyで定義されている場合）\nfrom math_tools import add\nresult = add(5, 3)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#相対インポートと絶対インポート",
    "href": "book/08-modules.html#相対インポートと絶対インポート",
    "title": "8  モジュールとパッケージ",
    "section": "8.11 相対インポートと絶対インポート",
    "text": "8.11 相対インポートと絶対インポート\n\n8.11.1 絶対インポート（プロジェクトルートから）\nfrom math_tools.basic import add\nfrom math_tools.advanced import fibonacci\n\n\n8.11.2 相対インポート（パッケージ内）\n# math_tools/advanced.py内\nfrom .basic import add        # 同じパッケージ\nfrom ..other_package import something  # 親パッケージ\n\n# math_tools/__init__.py内\nfrom .basic import add, subtract\nfrom .advanced import fibonacci",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#name__変数",
    "href": "book/08-modules.html#name__変数",
    "title": "8  モジュールとパッケージ",
    "section": "8.12 __name__変数",
    "text": "8.12 __name__変数\nすべてのモジュールには__name__属性があります：\n# calculator.py内\nprint(f\"モジュール名: {__name__}\")\n\ndef add(a, b):\n    return a + b\n\n# ファイルが直接実行された場合のみ実行\nif __name__ == \"__main__\":\n    print(\"電卓モジュールが直接実行されています\")\n    print(f\"2 + 3 = {add(2, 3)}\")\n\nインポートされた場合： __name__はモジュール名\n直接実行された場合： __name__は\"__main__\"",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#サードパーティパッケージ",
    "href": "book/08-modules.html#サードパーティパッケージ",
    "title": "8  モジュールとパッケージ",
    "section": "8.13 サードパーティパッケージ",
    "text": "8.13 サードパーティパッケージ\n\n8.13.1 pipでのパッケージインストール\npip install requests\npip install numpy\npip install pandas\n\n\n8.13.2 サードパーティパッケージの使用\nimport requests\nimport numpy as np\nimport pandas as pd\n\n# HTTPリクエストを行う\nresponse = requests.get('https://api.github.com')\n\n# 配列を作成\narray = np.array([1, 2, 3, 4, 5])\n\n# データを扱う\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#仮想環境",
    "href": "book/08-modules.html#仮想環境",
    "title": "8  モジュールとパッケージ",
    "section": "8.14 仮想環境",
    "text": "8.14 仮想環境\n\n8.14.1 なぜ仮想環境を使用するのか？\n\nプロジェクトの依存関係を分離\nバージョンの衝突を回避\nグローバルPythonを清潔に保つ\n\n\n\n8.14.2 仮想環境の作成と使用\n# 仮想環境を作成\npython -m venv myenv\n\n# アクティベート（Windows）\nmyenv\\Scripts\\activate\n\n# アクティベート（macOS/Linux）\nsource myenv/bin/activate\n\n# パッケージをインストール\npip install requests numpy\n\n# 非アクティベート\ndeactivate",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#パッケージ管理",
    "href": "book/08-modules.html#パッケージ管理",
    "title": "8  モジュールとパッケージ",
    "section": "8.15 パッケージ管理",
    "text": "8.15 パッケージ管理\n\n8.15.1 要件ファイル\n# requirements.txtを作成\npip freeze &gt; requirements.txt\n\n# 要件からインストール\npip install -r requirements.txt\n\n\n8.15.2 requirements.txtの例\nrequests==2.28.1\nnumpy==1.21.0\npandas&gt;=1.3.0\nmatplotlib~=3.5.0",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#実用例ファイルユーティリティパッケージ",
    "href": "book/08-modules.html#実用例ファイルユーティリティパッケージ",
    "title": "8  モジュールとパッケージ",
    "section": "8.16 実用例：ファイルユーティリティパッケージ",
    "text": "8.16 実用例：ファイルユーティリティパッケージ\n\n8.16.1 パッケージ構造\nfile_utils/\n├── __init__.py\n├── readers.py\n└── writers.py\n\n\n8.16.2 file_utils/readers.py\ndef read_text_file(filename):\n    \"\"\"テキストファイル全体を読み込みます。\"\"\"\n    with open(filename, 'r', encoding='utf-8') as file:\n        return file.read()\n\ndef read_lines(filename):\n    \"\"\"ファイルの行をリストとして読み込みます。\"\"\"\n    with open(filename, 'r', encoding='utf-8') as file:\n        return [line.strip() for line in file]",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#演習問題",
    "href": "book/08-modules.html#演習問題",
    "title": "8  モジュールとパッケージ",
    "section": "演習問題",
    "text": "演習問題\n\n8.16.3 演習 1：文字列ユーティリティモジュール\n# string_utils.pyを作成し、以下の関数を実装してください：\n\ndef reverse_string(text):\n    # 文字列を逆にして返す\n    pass\n\ndef count_words(text):\n    # 単語数を返す\n    pass\n\ndef title_case(text):\n    # タイトルケースに変換\n    pass\n\n\n8.16.4 演習 2：シンプルなパッケージの作成\nhelpers/\n├── __init__.py\n├── math_helpers.py\n└── string_helpers.py",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#解答例",
    "href": "book/08-modules.html#解答例",
    "title": "8  モジュールとパッケージ",
    "section": "解答例",
    "text": "解答例\n\n8.16.5 文字列ユーティリティモジュール\ndef reverse_string(text):\n    return text[::-1]\n\ndef count_words(text):\n    return len(text.split())\n\ndef title_case(text):\n    return ' '.join(word.capitalize() for word in text.split())\n\n\n8.16.6 パッケージの__init__.py\nfrom .math_helpers import add, multiply\nfrom .string_helpers import reverse_string, count_words\n\n__version__ = \"1.0.0\"",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#ベストプラクティス",
    "href": "book/08-modules.html#ベストプラクティス",
    "title": "8  モジュールとパッケージ",
    "section": "8.17 ベストプラクティス",
    "text": "8.17 ベストプラクティス\n\nわかりやすいモジュール名を使用: database_utils、db_stuffではない\nモジュールを焦点を絞る: モジュールごとに一つの明確な目的\nモジュールを文書化: ドキュメント文字列と例を含める\n__init__.pyを使用: パッケージのインポートを制御\n循環インポートを避ける: 明確な依存関係階層を設計\n仮想環境を使用: プロジェクトの依存関係を分離\nパッケージバージョンを固定: 本番環境では特定のバージョンを使用",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#よくある落とし穴",
    "href": "book/08-modules.html#よくある落とし穴",
    "title": "8  モジュールとパッケージ",
    "section": "8.18 よくある落とし穴",
    "text": "8.18 よくある落とし穴\n\n8.18.1 1. 循環インポート\n# module_a.py\nfrom module_b import function_b\n\n# module_b.py\nfrom module_a import function_a  # 循環インポート！\n\n\n8.18.2 2. sys.pathの不適切な変更\n# 悪い例\nsys.path.insert(0, '/some/absolute/path')\n\n# より良い例\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), 'modules'))\n\n\n8.18.3 3. from module import *の使用\n# これは避ける - 名前空間の汚染を引き起こす可能性\nfrom math import *\nfrom numpy import *  # math関数を上書きする可能性！",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#まとめ",
    "href": "book/08-modules.html#まとめ",
    "title": "8  モジュールとパッケージ",
    "section": "8.19 まとめ",
    "text": "8.19 まとめ\n\nモジュールはコードを再利用可能なファイルに整理する\nパッケージは関連するモジュールをグループ化する\nPythonには一般的なタスク用の多くの組み込みモジュールがある\nimport文を使用してモジュール機能にアクセス\nプロジェクト分離のために仮想環境を使用\n綺麗で保守可能なコード組織のためのベストプラクティスに従う",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#次のステップ",
    "href": "book/08-modules.html#次のステップ",
    "title": "8  モジュールとパッケージ",
    "section": "8.20 次のステップ",
    "text": "8.20 次のステップ\n次章では、オブジェクト指向プログラミングの概念について学習し、クラスと継承を使用してより複雑なプログラムを作成する方法を学びます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/08-modules.html#自己確認",
    "href": "book/08-modules.html#自己確認",
    "title": "8  モジュールとパッケージ",
    "section": "自己確認",
    "text": "自己確認\n\nモジュールとパッケージの違いは何ですか？\n__init__.pyファイルの目的は何ですか？\n相対インポートと絶対インポートの違いは何ですか？\n仮想環境を使用する利点は何ですか？\n__name__ == \"__main__\"の意味と用途は何ですか？",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>モジュールとパッケージ</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html",
    "href": "book/09-classes.html",
    "title": "9  クラスとオブジェクト",
    "section": "",
    "text": "学習目標\nオブジェクト指向プログラミング（OOP）は、関数ではなくオブジェクトを中心にコードを整理するプログラミングパラダイムです。\nこの章では以下を学習します：",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#学習目標",
    "href": "book/09-classes.html#学習目標",
    "title": "9  クラスとオブジェクト",
    "section": "",
    "text": "オブジェクト指向プログラミングの基本概念\nクラスとオブジェクトの定義と使用\nインスタンス属性とメソッド\nクラス属性とメソッド\nカプセル化とプロパティ",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#オブジェクト指向プログラミングとは",
    "href": "book/09-classes.html#オブジェクト指向プログラミングとは",
    "title": "9  クラスとオブジェクト",
    "section": "9.1 オブジェクト指向プログラミングとは",
    "text": "9.1 オブジェクト指向プログラミングとは\nオブジェクト指向プログラミング（OOP）は、データ（属性）と動作（メソッド）の両方を含むオブジェクトを中心にコードを整理します。\n現実世界の例： - 車には属性（色、モデル、年式）と動作（開始、停止、加速）があります - 各具体的な車は、Carクラスのインスタンスです\n\n9.1.1 OOPの利点\n\nモジュール性：コードをより良く整理\n再利用性：同じコードを何度も使用可能\n保守性：変更が容易\n現実世界のモデリング：実体をコードで表現しやすい",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#クラスとオブジェクト",
    "href": "book/09-classes.html#クラスとオブジェクト",
    "title": "9  クラスとオブジェクト",
    "section": "9.2 クラスとオブジェクト",
    "text": "9.2 クラスとオブジェクト\n\n9.2.1 クラス\n\n設計図またはテンプレート\n構造と動作を定義\n家の設計図のような存在\n\n\n\n9.2.2 オブジェクト\n\nクラスのインスタンス\n実際の値を持つ\n実際の家のような存在\n\n# クラス定義\nclass Car:\n    def __init__(self, make, model):\n        self.make = make\n        self.model = model\n    \n    def start(self):\n        return f\"{self.make} {self.model}が始動しています\"\n\n# オブジェクト（インスタンス）の作成\ncar1 = Car(\"トヨタ\", \"カムリ\")\ncar2 = Car(\"ホンダ\", \"シビック\")",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#最初のクラスを作成",
    "href": "book/09-classes.html#最初のクラスを作成",
    "title": "9  クラスとオブジェクト",
    "section": "9.3 最初のクラスを作成",
    "text": "9.3 最初のクラスを作成\nclass Dog:\n    def __init__(self, name, breed):\n        self.name = name\n        self.breed = breed\n    \n    def bark(self):\n        return f\"{self.name}がワンワン！\"\n    \n    def info(self):\n        return f\"{self.name}は{self.breed}です\"\n\n# インスタンスの作成\nmy_dog = Dog(\"ポチ\", \"ゴールデンレトリバー\")\nprint(my_dog.bark())  # ポチがワンワン！\nprint(my_dog.info())  # ポチはゴールデンレトリバーです",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#init__メソッド",
    "href": "book/09-classes.html#init__メソッド",
    "title": "9  クラスとオブジェクト",
    "section": "9.4 __init__メソッド",
    "text": "9.4 __init__メソッド\nコンストラクタメソッド： - オブジェクト作成時に自動的に呼び出される - オブジェクトの初期状態を設定 - selfは作成されるインスタンスを参照\nclass Person:\n    def __init__(self, name, age, email):\n        self.name = name        # インスタンス属性\n        self.age = age          # インスタンス属性\n        self.email = email      # インスタンス属性\n        self.friends = []       # デフォルト属性\n\n# インスタンスの作成\nperson1 = Person(\"太郎\", 25, \"taro@email.com\")\nperson2 = Person(\"花子\", 30, \"hanako@email.com\")\n\nprint(person1.name)  # 太郎\nprint(person2.age)   # 30",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#インスタンス属性とメソッド",
    "href": "book/09-classes.html#インスタンス属性とメソッド",
    "title": "9  クラスとオブジェクト",
    "section": "9.5 インスタンス属性とメソッド",
    "text": "9.5 インスタンス属性とメソッド\n\n9.5.1 属性はデータを格納\nclass BankAccount:\n    def __init__(self, account_number, balance=0):\n        self.account_number = account_number\n        self.balance = balance\n        self.transaction_history = []\n\n\n9.5.2 メソッドは動作を定義\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self.balance += amount\n            self.transaction_history.append(f\"{amount}円を入金\")\n            return True\n        return False\n    \n    def withdraw(self, amount):\n        if 0 &lt; amount &lt;= self.balance:\n            self.balance -= amount\n            self.transaction_history.append(f\"{amount}円を出金\")\n            return True\n        return False",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#bankaccountクラスの使用",
    "href": "book/09-classes.html#bankaccountクラスの使用",
    "title": "9  クラスとオブジェクト",
    "section": "9.6 BankAccountクラスの使用",
    "text": "9.6 BankAccountクラスの使用\n# アカウントを作成\naccount = BankAccount(\"123456789\", 100000)\n\n# メソッドを使用\naccount.deposit(50000)\naccount.withdraw(20000)\n\n# 属性にアクセス\nprint(f\"口座: {account.account_number}\")\nprint(f\"残高: {account.balance}円\")\nprint(\"履歴:\", account.transaction_history)\n出力:\n口座: 123456789\n残高: 130000円\n履歴: ['50000円を入金', '20000円を出金']",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#クラス属性",
    "href": "book/09-classes.html#クラス属性",
    "title": "9  クラスとオブジェクト",
    "section": "9.7 クラス属性",
    "text": "9.7 クラス属性\nクラス属性はすべてのインスタンスで共有されます：\nclass Dog:\n    species = \"Canis lupus\"  # クラス属性\n    total_dogs = 0           # クラス属性\n    \n    def __init__(self, name, breed):\n        self.name = name     # インスタンス属性\n        self.breed = breed   # インスタンス属性\n        Dog.total_dogs += 1  # クラス属性を増加\n    \n    @classmethod\n    def get_total_dogs(cls):\n        return cls.total_dogs\n\n# 使用方法\ndog1 = Dog(\"ポチ\", \"ゴールデンレトリバー\")\ndog2 = Dog(\"マックス\", \"ジャーマンシェパード\")\n\nprint(Dog.species)           # Canis lupus\nprint(Dog.get_total_dogs())  # 2",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#インスタンス属性とクラス属性",
    "href": "book/09-classes.html#インスタンス属性とクラス属性",
    "title": "9  クラスとオブジェクト",
    "section": "9.8 インスタンス属性とクラス属性",
    "text": "9.8 インスタンス属性とクラス属性\nclass Counter:\n    count = 0  # クラス属性\n    \n    def __init__(self, name):\n        self.name = name      # インスタンス属性\n        Counter.count += 1    # クラス属性を変更\n        self.instance_count = 1  # インスタンス属性\n\ncounter1 = Counter(\"1番目\")\ncounter2 = Counter(\"2番目\")\n\nprint(f\"総カウンタ数: {Counter.count}\")      # 2\nprint(f\"カウンタ1の名前: {counter1.name}\")     # 1番目\nprint(f\"カウンタ2の名前: {counter2.name}\")     # 2番目",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#文字列表現",
    "href": "book/09-classes.html#文字列表現",
    "title": "9  クラスとオブジェクト",
    "section": "9.9 文字列表現",
    "text": "9.9 文字列表現\nオブジェクトを印刷可能にする：\nclass Book:\n    def __init__(self, title, author, pages):\n        self.title = title\n        self.author = author\n        self.pages = pages\n    \n    def __str__(self):\n        return f\"『{self.title}』 著者: {self.author}\"\n    \n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}', {self.pages})\"\n\nbook = Book(\"1984\", \"ジョージ・オーウェル\", 328)\nprint(str(book))   # 『1984』 著者: ジョージ・オーウェル\nprint(repr(book))  # Book('1984', 'ジョージ・オーウェル', 328)\nprint(book)        # __str__メソッドを使用",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#プロパティデコレータ",
    "href": "book/09-classes.html#プロパティデコレータ",
    "title": "9  クラスとオブジェクト",
    "section": "9.10 プロパティデコレータ",
    "text": "9.10 プロパティデコレータ\n属性へのアクセスを制御：\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius  # \"プライベート\"属性\n    \n    @property\n    def radius(self):\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value):\n        if value &lt; 0:\n            raise ValueError(\"半径は負の値にできません\")\n        self._radius = value\n    \n    @property\n    def area(self):\n        return 3.14159 * self._radius ** 2\n\ncircle = Circle(5)\nprint(circle.area)     # 78.53975\ncircle.radius = 10     # セッターを使用\nprint(circle.area)     # 314.159",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#プライベート属性",
    "href": "book/09-classes.html#プライベート属性",
    "title": "9  クラスとオブジェクト",
    "section": "9.11 プライベート属性",
    "text": "9.11 プライベート属性\nPythonの”プライベート”属性の規則：\nclass BankAccount:\n    def __init__(self, balance):\n        self.public_attr = \"誰でもアクセス可能\"\n        self._protected_attr = \"直接アクセスすべきでない\"\n        self.__private_attr = \"プライバシーのために名前が変換される\"\n    \n    def get_private(self):\n        return self.__private_attr\n\naccount = BankAccount(100000)\nprint(account.public_attr)      # OK\nprint(account._protected_attr)  # 動作するが推奨されない\n# print(account.__private_attr) # AttributeError\nprint(account.get_private())    # メソッド経由でアクセス\n注意： Pythonには真のプライベート属性はなく、規則のみです",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#クラスメソッドと静的メソッド",
    "href": "book/09-classes.html#クラスメソッドと静的メソッド",
    "title": "9  クラスとオブジェクト",
    "section": "9.12 クラスメソッドと静的メソッド",
    "text": "9.12 クラスメソッドと静的メソッド\n\n9.12.1 クラスメソッド\nクラスメソッドはインスタンスではなくクラスと連携します：\nclass Person:\n    population = 0\n    \n    def __init__(self, name):\n        self.name = name\n        Person.population += 1\n    \n    @classmethod\n    def get_population(cls):\n        return cls.population\n    \n    @classmethod\n    def create_anonymous(cls):\n        return cls(\"匿名\")\n\nprint(Person.get_population())  # 0\nperson1 = Person(\"太郎\")\nanonymous = Person.create_anonymous()\nprint(Person.get_population())  # 2\n\n\n9.12.2 静的メソッド\n静的メソッドはselfやclsを使用しません：\nclass MathUtils:\n    @staticmethod\n    def add(a, b):\n        return a + b\n    \n    @staticmethod\n    def is_even(number):\n        return number % 2 == 0\n    \n    @staticmethod\n    def factorial(n):\n        if n &lt;= 1:\n            return 1\n        return n * MathUtils.factorial(n - 1)\n\n# インスタンスを作成せずに呼び出し可能\nprint(MathUtils.add(5, 3))      # 8\nprint(MathUtils.is_even(4))     # True\nprint(MathUtils.factorial(5))   # 120",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#実用例学生管理",
    "href": "book/09-classes.html#実用例学生管理",
    "title": "9  クラスとオブジェクト",
    "section": "9.13 実用例：学生管理",
    "text": "9.13 実用例：学生管理\nclass Student:\n    total_students = 0\n    \n    def __init__(self, name, student_id, email):\n        self.name = name\n        self.student_id = student_id\n        self.email = email\n        self.grades = {}\n        self.enrolled_courses = []\n        Student.total_students += 1\n    \n    def enroll_course(self, course):\n        if course not in self.enrolled_courses:\n            self.enrolled_courses.append(course)\n            self.grades[course] = []\n    \n    def add_grade(self, course, grade):\n        if course in self.grades:\n            self.grades[course].append(grade)\n    \n    def get_average(self, course):\n        if course in self.grades and self.grades[course]:\n            return sum(self.grades[course]) / len(self.grades[course])\n        return 0\n    \n    def __str__(self):\n        return f\"学生: {self.name} (ID: {self.student_id})\"",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#studentクラスの使用",
    "href": "book/09-classes.html#studentクラスの使用",
    "title": "9  クラスとオブジェクト",
    "section": "9.14 Studentクラスの使用",
    "text": "9.14 Studentクラスの使用\n# 学生を作成\nalice = Student(\"田中太郎\", \"S001\", \"tanaka@school.edu\")\nbob = Student(\"佐藤花子\", \"S002\", \"sato@school.edu\")\n\n# コースに登録\nalice.enroll_course(\"数学\")\nalice.enroll_course(\"理科\")\nbob.enroll_course(\"数学\")\n\n# 成績を追加\nalice.add_grade(\"数学\", 85)\nalice.add_grade(\"数学\", 92)\nalice.add_grade(\"理科\", 78)\n\n# 結果を確認\nprint(alice)                               # 学生: 田中太郎 (ID: S001)\nprint(f\"数学の平均: {alice.get_average('数学')}\")  # 88.5\nprint(f\"総学生数: {Student.total_students}\")    # 2",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#演習問題",
    "href": "book/09-classes.html#演習問題",
    "title": "9  クラスとオブジェクト",
    "section": "演習問題",
    "text": "演習問題\n\n9.14.1 演習 1：Rectangleクラス\nclass Rectangle:\n    def __init__(self, width, height):\n        # ここにコードを書いてください\n        pass\n    \n    def area(self):\n        # 面積を返す\n        pass\n    \n    def perimeter(self):\n        # 周囲を返す\n        pass\n    \n    def __str__(self):\n        # 文字列表現を返す\n        pass\n\n\n9.14.2 演習 2：図書館の本システム\nclass LibraryBook:\n    def __init__(self, title, author, isbn):\n        # 本を初期化\n        pass\n    \n    def check_out(self):\n        # 貸出済みとしてマーク\n        pass\n    \n    def return_book(self):\n        # 返却済みとしてマーク\n        pass",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#解答例",
    "href": "book/09-classes.html#解答例",
    "title": "9  クラスとオブジェクト",
    "section": "解答例",
    "text": "解答例\n\n9.14.3 Rectangleクラス\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n    \n    def __str__(self):\n        return f\"Rectangle({self.width}x{self.height})\"\n\n\n9.14.4 図書館の本システム\nclass LibraryBook:\n    def __init__(self, title, author, isbn):\n        self.title = title\n        self.author = author\n        self.isbn = isbn\n        self.is_checked_out = False\n    \n    def check_out(self):\n        if not self.is_checked_out:\n            self.is_checked_out = True\n            return True\n        return False\n    \n    def return_book(self):\n        if self.is_checked_out:\n            self.is_checked_out = False\n            return True\n        return False",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#ベストプラクティス",
    "href": "book/09-classes.html#ベストプラクティス",
    "title": "9  クラスとオブジェクト",
    "section": "9.15 ベストプラクティス",
    "text": "9.15 ベストプラクティス\n\n明確で説明的なクラス名を使用: BankAccount、BAではない\n単一責任の原則に従う: 一つのクラス、一つの目的\n初期化に__init__を使用: オブジェクトの状態を適切に設定\n文字列表現を提供: __str__と__repr__を実装\n検証にプロパティを使用: 属性アクセスを制御\nクラスを文書化: ドキュメント文字列を含める\nメソッドを焦点を絞る: 各メソッドは一つのことを上手く行う",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#よくある間違い",
    "href": "book/09-classes.html#よくある間違い",
    "title": "9  クラスとオブジェクト",
    "section": "9.16 よくある間違い",
    "text": "9.16 よくある間違い\n\n9.16.1 1. selfを忘れる\nclass Counter:\n    def __init__(self, start=0):\n        count = start  # 間違い！ self.count = start であるべき\n    \n    def increment(self):\n        count += 1     # 間違い！ self.count += 1 であるべき\n\n\n9.16.2 2. 可変なデフォルト引数\n# 悪い例\nclass Student:\n    def __init__(self, name, courses=[]):\n        self.courses = courses  # インスタンス間で共有される！\n\n# 良い例\nclass Student:\n    def __init__(self, name, courses=None):\n        self.courses = courses if courses is not None else []",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#クラスを使用するタイミング",
    "href": "book/09-classes.html#クラスを使用するタイミング",
    "title": "9  クラスとオブジェクト",
    "section": "9.17 クラスを使用するタイミング",
    "text": "9.17 クラスを使用するタイミング\n\n9.17.1 クラスに適している候補\n\nデータと動作の両方を持つエンティティ\n維持する必要がある複雑な状態\n複数のインスタンスが必要な場合\n継承が有益な場合\n\n\n\n9.17.2 代替案を検討\n\n単純なデータ保存 → 辞書やnamedtupleを使用\n純粋な関数 → クラスは不要\n一回限りの使用 → 関数の方が簡単",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#まとめ",
    "href": "book/09-classes.html#まとめ",
    "title": "9  クラスとオブジェクト",
    "section": "9.18 まとめ",
    "text": "9.18 まとめ\n\nクラスはオブジェクトを作成するための設計図\nオブジェクトはデータ（属性）と動作（メソッド）を組み合わせる\n__init__メソッドは新しいインスタンスを初期化\nselfを使用して現在のインスタンスを参照\nクラス属性は共有、インスタンス属性は一意\nプロパティは属性への制御されたアクセスを提供\n良いクラス設計はコードをより整理され再利用可能にする",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#次のステップ",
    "href": "book/09-classes.html#次のステップ",
    "title": "9  クラスとオブジェクト",
    "section": "9.19 次のステップ",
    "text": "9.19 次のステップ\n次章では、継承とポリモーフィズムについて学習し、より複雑で柔軟なオブジェクト指向プログラムの作成方法を学びます。",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/09-classes.html#自己確認",
    "href": "book/09-classes.html#自己確認",
    "title": "9  クラスとオブジェクト",
    "section": "自己確認",
    "text": "自己確認\n\nクラスとオブジェクトの違いは何ですか？\n__init__メソッドの目的は何ですか？\nインスタンス属性とクラス属性の違いは何ですか？\nプロパティデコレータを使用する理由は何ですか？\n良いクラス設計のベストプラクティスを3つ挙げてください。",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クラスとオブジェクト</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html",
    "href": "book/11-inheritance.html",
    "title": "10  継承とポリモーフィズム",
    "section": "",
    "text": "10.1 継承の理解\n継承（inheritance）により、既存のクラスを基にして新しいクラスを作成でき、コードの再利用と論理的な階層構造を構築できます。ポリモーフィズム（polymorphism）により、異なる型のオブジェクトを統一的に扱うことができます。",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#継承の理解",
    "href": "book/11-inheritance.html#継承の理解",
    "title": "10  継承とポリモーフィズム",
    "section": "",
    "text": "10.1.1 基本的な継承\n\n# 基底クラス（親クラス・スーパークラス）\nclass Animal:\n    \"\"\"一般的な動物を表す基底クラス\"\"\"\n    \n    def __init__(self, name, species):\n        self.name = name\n        self.species = species\n        self.energy = 100\n    \n    def eat(self, food):\n        \"\"\"一般的な食事の動作\"\"\"\n        self.energy += 10\n        print(f\"{self.name}は{food}を食べて、エネルギーを得ました。エネルギー: {self.energy}\")\n    \n    def sleep(self):\n        \"\"\"一般的な睡眠の動作\"\"\"\n        self.energy += 20\n        print(f\"{self.name}は眠って、エネルギーを回復しました。エネルギー: {self.energy}\")\n    \n    def make_sound(self):\n        \"\"\"一般的な鳴き声 - サブクラスでオーバーライドされます\"\"\"\n        print(f\"{self.name}が音を出しています\")\n    \n    def __str__(self):\n        return f\"{self.species}の{self.name}\"\n\n# 派生クラス（子クラス・サブクラス）\nclass Dog(Animal):\n    \"\"\"Animalクラスを継承するDogクラス\"\"\"\n    \n    def __init__(self, name, breed):\n        # 親のコンストラクタを呼び出し\n        super().__init__(name, \"犬\")\n        self.breed = breed\n        self.tricks = []\n    \n    def make_sound(self):\n        \"\"\"親のメソッドをオーバーライド\"\"\"\n        print(f\"{self.name}が吠えます: ワンワン！\")\n    \n    def learn_trick(self, trick):\n        \"\"\"犬特有のメソッド\"\"\"\n        self.tricks.append(trick)\n        print(f\"{self.name}は{trick}を覚えました！\")\n    \n    def perform_trick(self):\n        \"\"\"覚えた芸を披露\"\"\"\n        if self.tricks:\n            trick = self.tricks[-1]  # 最後に覚えた芸\n            print(f\"{self.name}が{trick}を披露します！\")\n        else:\n            print(f\"{self.name}はまだ芸を覚えていません\")\n\nclass Cat(Animal):\n    \"\"\"Animalクラスを継承するCatクラス\"\"\"\n    \n    def __init__(self, name, color):\n        super().__init__(name, \"猫\")\n        self.color = color\n        self.lives = 9  # 猫は9つの命を持つ\n    \n    def make_sound(self):\n        \"\"\"親のメソッドをオーバーライド\"\"\"\n        print(f\"{self.name}が鳴きます: ニャーニャー\")\n    \n    def climb(self, object_name):\n        \"\"\"猫特有のメソッド\"\"\"\n        print(f\"{self.name}が{object_name}に登ります\")\n\n# 継承の使用例\ndog = Dog(\"ポチ\", \"柴犬\")\ncat = Cat(\"タマ\", \"黒\")\n\nprint(f\"犬: {dog}\")\nprint(f\"猫: {cat}\")\n\ndog.make_sound()\ncat.make_sound()\n\ndog.learn_trick(\"お座り\")\ndog.learn_trick(\"お手\")\ndog.perform_trick()\n\ncat.climb(\"木\")",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#メソッドのオーバーライド",
    "href": "book/11-inheritance.html#メソッドのオーバーライド",
    "title": "10  継承とポリモーフィズム",
    "section": "10.2 メソッドのオーバーライド",
    "text": "10.2 メソッドのオーバーライド\n\n10.2.1 super()を使った親メソッドの拡張\n\nclass Vehicle:\n    \"\"\"乗り物の基底クラス\"\"\"\n    \n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n        self.fuel = 100\n    \n    def start(self):\n        print(f\"{self.brand} {self.model}のエンジンが始動しました\")\n    \n    def stop(self):\n        print(f\"{self.brand} {self.model}のエンジンが停止しました\")\n\nclass Car(Vehicle):\n    \"\"\"自動車クラス\"\"\"\n    \n    def __init__(self, brand, model, doors):\n        super().__init__(brand, model)  # 親のコンストラクタを呼び出し\n        self.doors = doors\n    \n    def start(self):\n        # 親のメソッドを呼び出してから追加処理\n        super().start()\n        print(\"シートベルトを確認してください\")\n    \n    def open_trunk(self):\n        print(\"トランクを開きました\")\n\nclass Motorcycle(Vehicle):\n    \"\"\"オートバイクラス\"\"\"\n    \n    def __init__(self, brand, model, cc):\n        super().__init__(brand, model)\n        self.cc = cc  # 排気量\n    \n    def start(self):\n        super().start()\n        print(\"ヘルメットを着用してください\")\n\n# 使用例\ncar = Car(\"トヨタ\", \"プリウス\", 4)\nmotorcycle = Motorcycle(\"ホンダ\", \"CB400\", 400)\n\ncar.start()\ncar.open_trunk()\n\nprint()\nmotorcycle.start()",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#ポリモーフィズム",
    "href": "book/11-inheritance.html#ポリモーフィズム",
    "title": "10  継承とポリモーフィズム",
    "section": "10.3 ポリモーフィズム",
    "text": "10.3 ポリモーフィズム\n\n10.3.1 同じインターフェースで異なる動作\n\nclass Shape:\n    \"\"\"図形の基底クラス\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def area(self):\n        \"\"\"面積計算 - サブクラスで実装される\"\"\"\n        raise NotImplementedError(\"サブクラスで実装してください\")\n    \n    def perimeter(self):\n        \"\"\"周囲長計算 - サブクラスで実装される\"\"\"\n        raise NotImplementedError(\"サブクラスで実装してください\")\n\nclass Circle(Shape):\n    \"\"\"円クラス\"\"\"\n    \n    def __init__(self, radius):\n        super().__init__(\"円\")\n        self.radius = radius\n    \n    def area(self):\n        import math\n        return math.pi * self.radius ** 2\n    \n    def perimeter(self):\n        import math\n        return 2 * math.pi * self.radius\n\nclass Rectangle(Shape):\n    \"\"\"長方形クラス\"\"\"\n    \n    def __init__(self, width, height):\n        super().__init__(\"長方形\")\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Triangle(Shape):\n    \"\"\"三角形クラス\"\"\"\n    \n    def __init__(self, base, height, side1, side2):\n        super().__init__(\"三角形\")\n        self.base = base\n        self.height = height\n        self.side1 = side1\n        self.side2 = side2\n    \n    def area(self):\n        return 0.5 * self.base * self.height\n    \n    def perimeter(self):\n        return self.base + self.side1 + self.side2\n\n# ポリモーフィズムの実践\ndef print_shape_info(shape):\n    \"\"\"図形の情報を表示する関数\"\"\"\n    print(f\"{shape.name}:\")\n    print(f\"  面積: {shape.area():.2f}\")\n    print(f\"  周囲長: {shape.perimeter():.2f}\")\n    print()\n\n# 異なる図形のリスト\nshapes = [\n    Circle(5),\n    Rectangle(4, 6),\n    Triangle(6, 4, 5, 5)\n]\n\n# 同じインターフェースで異なる図形を処理\nprint(\"=== 図形の情報 ===\")\nfor shape in shapes:\n    print_shape_info(shape)",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#抽象基底クラスabc",
    "href": "book/11-inheritance.html#抽象基底クラスabc",
    "title": "10  継承とポリモーフィズム",
    "section": "10.4 抽象基底クラス（ABC）",
    "text": "10.4 抽象基底クラス（ABC）\n\n10.4.1 より厳密な抽象化\n\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    \"\"\"データベースの抽象基底クラス\"\"\"\n    \n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n        self.connected = False\n    \n    @abstractmethod\n    def connect(self):\n        \"\"\"接続処理 - 必須実装\"\"\"\n        pass\n    \n    @abstractmethod\n    def disconnect(self):\n        \"\"\"切断処理 - 必須実装\"\"\"\n        pass\n    \n    @abstractmethod\n    def execute_query(self, query):\n        \"\"\"クエリ実行 - 必須実装\"\"\"\n        pass\n    \n    def is_connected(self):\n        \"\"\"接続状態確認 - 共通実装\"\"\"\n        return self.connected\n\nclass SQLiteDatabase(Database):\n    \"\"\"SQLiteデータベース実装\"\"\"\n    \n    def connect(self):\n        print(f\"SQLiteデータベースに接続中: {self.connection_string}\")\n        self.connected = True\n        return \"SQLite接続成功\"\n    \n    def disconnect(self):\n        print(\"SQLiteデータベースから切断中\")\n        self.connected = False\n        return \"SQLite切断完了\"\n    \n    def execute_query(self, query):\n        if not self.connected:\n            return \"エラー: データベースに接続されていません\"\n        print(f\"SQLiteクエリ実行: {query}\")\n        return f\"SQLite結果: {query}の実行完了\"\n\nclass PostgreSQLDatabase(Database):\n    \"\"\"PostgreSQLデータベース実装\"\"\"\n    \n    def connect(self):\n        print(f\"PostgreSQLデータベースに接続中: {self.connection_string}\")\n        self.connected = True\n        return \"PostgreSQL接続成功\"\n    \n    def disconnect(self):\n        print(\"PostgreSQLデータベースから切断中\")\n        self.connected = False\n        return \"PostgreSQL切断完了\"\n    \n    def execute_query(self, query):\n        if not self.connected:\n            return \"エラー: データベースに接続されていません\"\n        print(f\"PostgreSQLクエリ実行: {query}\")\n        return f\"PostgreSQL結果: {query}の実行完了\"\n\n# データベース管理システム\nclass DatabaseManager:\n    \"\"\"データベース管理クラス\"\"\"\n    \n    def __init__(self):\n        self.databases = []\n    \n    def add_database(self, database):\n        \"\"\"データベースを追加\"\"\"\n        self.databases.append(database)\n    \n    def connect_all(self):\n        \"\"\"全データベースに接続\"\"\"\n        for db in self.databases:\n            result = db.connect()\n            print(f\"結果: {result}\")\n    \n    def execute_on_all(self, query):\n        \"\"\"全データベースでクエリ実行\"\"\"\n        for db in self.databases:\n            if db.is_connected():\n                result = db.execute_query(query)\n                print(f\"結果: {result}\")\n\n# 使用例\nmanager = DatabaseManager()\n\n# 異なる種類のデータベースを追加\nsqlite_db = SQLiteDatabase(\"data.db\")\npostgres_db = PostgreSQLDatabase(\"postgresql://localhost:5432/mydb\")\n\nmanager.add_database(sqlite_db)\nmanager.add_database(postgres_db)\n\nprint(\"=== データベース管理システム ===\")\nmanager.connect_all()\nprint()\nmanager.execute_on_all(\"SELECT * FROM users\")",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#多重継承",
    "href": "book/11-inheritance.html#多重継承",
    "title": "10  継承とポリモーフィズム",
    "section": "10.5 多重継承",
    "text": "10.5 多重継承\n\n10.5.1 複数の親クラスからの継承\n\nclass Flying:\n    \"\"\"飛行能力のミックスイン\"\"\"\n    \n    def __init__(self):\n        self.altitude = 0\n    \n    def take_off(self):\n        self.altitude = 100\n        print(\"離陸しました！高度: 100m\")\n    \n    def land(self):\n        self.altitude = 0\n        print(\"着陸しました！\")\n    \n    def fly_higher(self, meters):\n        self.altitude += meters\n        print(f\"高度を上げました。現在の高度: {self.altitude}m\")\n\nclass Swimming:\n    \"\"\"泳ぐ能力のミックスイン\"\"\"\n    \n    def __init__(self):\n        self.depth = 0\n    \n    def dive(self, meters):\n        self.depth += meters\n        print(f\"潜水しました。現在の深度: {self.depth}m\")\n    \n    def surface(self):\n        self.depth = 0\n        print(\"水面に浮上しました！\")\n\nclass Duck(Animal, Flying, Swimming):\n    \"\"\"アヒルクラス - 多重継承の例\"\"\"\n    \n    def __init__(self, name):\n        Animal.__init__(self, name, \"アヒル\")\n        Flying.__init__(self)\n        Swimming.__init__(self)\n    \n    def make_sound(self):\n        print(f\"{self.name}が鳴きます: ガーガー\")\n\nclass Penguin(Animal, Swimming):\n    \"\"\"ペンギンクラス - 泳げるが飛べない\"\"\"\n    \n    def __init__(self, name):\n        Animal.__init__(self, name, \"ペンギン\")\n        Swimming.__init__(self)\n    \n    def make_sound(self):\n        print(f\"{self.name}が鳴きます: ガァガァ\")\n    \n    def slide_on_ice(self):\n        print(f\"{self.name}が氷の上を滑ります！\")\n\n# 使用例\nprint(\"=== 多重継承の例 ===\")\nduck = Duck(\"ドナルド\")\npenguin = Penguin(\"ペンギン太郎\")\n\nprint(f\"アヒル: {duck}\")\nduck.make_sound()\nduck.eat(\"パン\")\nduck.take_off()\nduck.fly_higher(50)\nduck.land()\nduck.dive(2)\nduck.surface()\n\nprint()\nprint(f\"ペンギン: {penguin}\")\npenguin.make_sound()\npenguin.eat(\"魚\")\npenguin.dive(10)\npenguin.slide_on_ice()\npenguin.surface()",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/11-inheritance.html#実践例図書館管理システム",
    "href": "book/11-inheritance.html#実践例図書館管理システム",
    "title": "10  継承とポリモーフィズム",
    "section": "10.6 実践例：図書館管理システム",
    "text": "10.6 実践例：図書館管理システム\n\n10.6.1 継承を活用した実際のアプリケーション\n\nfrom datetime import datetime, timedelta\n\nclass LibraryItem:\n    \"\"\"図書館アイテムの基底クラス\"\"\"\n    \n    def __init__(self, title, item_id, location):\n        self.title = title\n        self.item_id = item_id\n        self.location = location\n        self.checked_out = False\n        self.due_date = None\n        self.borrower = None\n    \n    def check_out(self, borrower_name, days=14):\n        \"\"\"貸出処理\"\"\"\n        if self.checked_out:\n            return f\"エラー: {self.title}は既に貸出中です\"\n        \n        self.checked_out = True\n        self.borrower = borrower_name\n        self.due_date = datetime.now() + timedelta(days=days)\n        return f\"{self.title}を{borrower_name}に貸出しました。返却期限: {self.due_date.strftime('%Y-%m-%d')}\"\n    \n    def return_item(self):\n        \"\"\"返却処理\"\"\"\n        if not self.checked_out:\n            return f\"エラー: {self.title}は貸出されていません\"\n        \n        borrower = self.borrower\n        self.checked_out = False\n        self.borrower = None\n        self.due_date = None\n        return f\"{self.title}が{borrower}から返却されました\"\n    \n    def is_overdue(self):\n        \"\"\"延滞チェック\"\"\"\n        if not self.checked_out:\n            return False\n        return datetime.now() &gt; self.due_date\n    \n    def get_info(self):\n        \"\"\"基本情報を取得\"\"\"\n        status = \"貸出中\" if self.checked_out else \"利用可能\"\n        return f\"{self.title} (ID: {self.item_id}) - {status}\"\n\nclass Book(LibraryItem):\n    \"\"\"書籍クラス\"\"\"\n    \n    def __init__(self, title, item_id, location, author, isbn, pages):\n        super().__init__(title, item_id, location)\n        self.author = author\n        self.isbn = isbn\n        self.pages = pages\n        self.item_type = \"書籍\"\n    \n    def get_info(self):\n        base_info = super().get_info()\n        return f\"{base_info}\\n  著者: {self.author}, ページ数: {self.pages}\"\n\nclass DVD(LibraryItem):\n    \"\"\"DVDクラス\"\"\"\n    \n    def __init__(self, title, item_id, location, director, duration, rating):\n        super().__init__(title, item_id, location)\n        self.director = director\n        self.duration = duration  # 分\n        self.rating = rating\n        self.item_type = \"DVD\"\n    \n    def check_out(self, borrower_name, days=7):  # DVDは短期貸出\n        return super().check_out(borrower_name, days)\n    \n    def get_info(self):\n        base_info = super().get_info()\n        return f\"{base_info}\\n  監督: {self.director}, 上映時間: {self.duration}分\"\n\nclass Magazine(LibraryItem):\n    \"\"\"雑誌クラス\"\"\"\n    \n    def __init__(self, title, item_id, location, issue_number, publication_date):\n        super().__init__(title, item_id, location)\n        self.issue_number = issue_number\n        self.publication_date = publication_date\n        self.item_type = \"雑誌\"\n    \n    def check_out(self, borrower_name, days=3):  # 雑誌は超短期貸出\n        return super().check_out(borrower_name, days)\n    \n    def get_info(self):\n        base_info = super().get_info()\n        return f\"{base_info}\\n  号数: {self.issue_number}, 発行日: {self.publication_date}\"\n\n# 図書館管理システム\nclass Library:\n    \"\"\"図書館クラス\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.items = {}\n    \n    def add_item(self, item):\n        \"\"\"アイテムを追加\"\"\"\n        self.items[item.item_id] = item\n        print(f\"{item.item_type}「{item.title}」を追加しました\")\n    \n    def find_item(self, item_id):\n        \"\"\"アイテムを検索\"\"\"\n        return self.items.get(item_id)\n    \n    def list_available_items(self):\n        \"\"\"利用可能なアイテム一覧\"\"\"\n        print(f\"\\n=== {self.name} 利用可能アイテム ===\")\n        for item in self.items.values():\n            if not item.checked_out:\n                print(item.get_info())\n    \n    def list_overdue_items(self):\n        \"\"\"延滞アイテム一覧\"\"\"\n        print(f\"\\n=== {self.name} 延滞アイテム ===\")\n        overdue_items = [item for item in self.items.values() if item.is_overdue()]\n        if not overdue_items:\n            print(\"延滞アイテムはありません\")\n        else:\n            for item in overdue_items:\n                print(f\"{item.get_info()} - 借用者: {item.borrower}\")\n\n# 使用例\nprint(\"=== 図書館管理システム ===\")\nlibrary = Library(\"中央図書館\")\n\n# 様々なアイテムを追加\nbook1 = Book(\"Pythonプログラミング入門\", \"B001\", \"1F-A1\", \"田中太郎\", \"978-4-123456-78-9\", 350)\nbook2 = Book(\"データサイエンス実践\", \"B002\", \"2F-B3\", \"佐藤花子\", \"978-4-987654-32-1\", 480)\ndvd1 = DVD(\"プログラミング講座\", \"D001\", \"B1-AV1\", \"山田監督\", 120, \"G\")\nmagazine1 = Magazine(\"テックマガジン\", \"M001\", \"1F-雑誌棚\", \"2024年1月号\", \"2024-01-01\")\n\nlibrary.add_item(book1)\nlibrary.add_item(book2)\nlibrary.add_item(dvd1)\nlibrary.add_item(magazine1)\n\n# 利用可能アイテム表示\nlibrary.list_available_items()\n\n# 貸出処理\nprint(f\"\\n{book1.check_out('鈴木一郎')}\")\nprint(f\"{dvd1.check_out('田中二郎')}\")\n\n# 再度利用可能アイテム表示\nlibrary.list_available_items()\n\n# 延滞チェック\nlibrary.list_overdue_items()\n\nこの章では、継承とポリモーフィズムの基本概念から実践的な応用まで学習しました。継承により既存のコードを再利用し、ポリモーフィズムにより柔軟で拡張可能なプログラムを作成することができます。",
    "crumbs": [
      "オブジェクト指向プログラミング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>継承とポリモーフィズム</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html",
    "href": "book/10-type-hints.html",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "",
    "text": "11.1 型ヒントとは\n型ヒント（Type Hints）は Python 3.5 から導入された機能で、コードの可読性を向上させ、バグを事前に発見するのに役立ちます。\n型ヒントは、変数や関数の引数・戻り値の型を明示的に指定する仕組みです。\n# 型ヒントなし\ndef greet(name):\n    return f\"Hello, {name}!\"\n\n# 型ヒントあり\ndef greet_typed(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\n# 使用例\nmessage = greet_typed(\"太郎\")\nprint(message)",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#基本的な型の指定",
    "href": "book/10-type-hints.html#基本的な型の指定",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.2 基本的な型の指定",
    "text": "11.2 基本的な型の指定\n\n11.2.1 プリミティブ型\n\nfrom typing import List, Dict, Tuple, Optional\n\n# 基本型\nname: str = \"田中\"\nage: int = 25\nheight: float = 170.5\nis_student: bool = True\n\nprint(f\"名前: {name} ({type(name).__name__})\")\nprint(f\"年齢: {age} ({type(age).__name__})\")\nprint(f\"身長: {height} ({type(height).__name__})\")\nprint(f\"学生: {is_student} ({type(is_student).__name__})\")\n\n\n\n11.2.2 コレクション型\n\n# リスト型\nnumbers: List[int] = [1, 2, 3, 4, 5]\nnames: List[str] = [\"太郎\", \"花子\", \"次郎\"]\n\n# 辞書型\nstudent_ages: Dict[str, int] = {\n    \"太郎\": 20,\n    \"花子\": 22,\n    \"次郎\": 19\n}\n\n# タプル型\ncoordinates: Tuple[float, float] = (35.6762, 139.6503)\nrgb_color: Tuple[int, int, int] = (255, 128, 0)\n\nprint(f\"数値リスト: {numbers}\")\nprint(f\"名前リスト: {names}\")\nprint(f\"学生の年齢: {student_ages}\")\nprint(f\"座標: {coordinates}\")\nprint(f\"RGB色: {rgb_color}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#関数の型ヒント",
    "href": "book/10-type-hints.html#関数の型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.3 関数の型ヒント",
    "text": "11.3 関数の型ヒント\n\n11.3.1 基本的な関数\n\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"二つの数値を足し算する関数\"\"\"\n    return a + b\n\ndef calculate_average(numbers: List[float]) -&gt; float:\n    \"\"\"数値リストの平均を計算\"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)\n\ndef format_name(first: str, last: str, middle: str = \"\") -&gt; str:\n    \"\"\"名前をフォーマット\"\"\"\n    if middle:\n        return f\"{last} {first} {middle}\"\n    return f\"{last} {first}\"\n\n# 使用例\nresult = add_numbers(10, 20)\nprint(f\"10 + 20 = {result}\")\n\nscores = [85.5, 92.0, 78.5, 90.0]\navg = calculate_average(scores)\nprint(f\"平均点: {avg:.1f}\")\n\nfull_name = format_name(\"太郎\", \"田中\")\nprint(f\"フルネーム: {full_name}\")\n\n\n\n11.3.2 Optional と Union 型\n\nfrom typing import Optional, Union\n\ndef find_student(students: List[str], name: str) -&gt; Optional[int]:\n    \"\"\"学生のインデックスを検索（見つからない場合は None）\"\"\"\n    try:\n        return students.index(name)\n    except ValueError:\n        return None\n\ndef process_number(value: Union[int, float, str]) -&gt; float:\n    \"\"\"様々な型の数値を float に変換\"\"\"\n    if isinstance(value, str):\n        return float(value)\n    return float(value)\n\n# 使用例\nstudents = [\"太郎\", \"花子\", \"次郎\"]\n\nindex = find_student(students, \"花子\")\nif index is not None:\n    print(f\"花子は {index} 番目にいます\")\nelse:\n    print(\"花子が見つかりません\")\n\n# Union 型のテスト\nprint(f\"整数 42: {process_number(42)}\")\nprint(f\"浮動小数点 3.14: {process_number(3.14)}\")\nprint(f\"文字列 '123.45': {process_number('123.45')}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#クラスの型ヒント",
    "href": "book/10-type-hints.html#クラスの型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.4 クラスの型ヒント",
    "text": "11.4 クラスの型ヒント\n\nfrom typing import ClassVar\nfrom datetime import datetime\n\nclass Student:\n    \"\"\"学生クラス\"\"\"\n    \n    # クラス変数の型ヒント\n    school_name: ClassVar[str] = \"東京大学\"\n    \n    def __init__(self, name: str, age: int, grade: int) -&gt; None:\n        self.name: str = name\n        self.age: int = age\n        self.grade: int = grade\n        self.scores: List[float] = []\n    \n    def add_score(self, score: float) -&gt; None:\n        \"\"\"成績を追加\"\"\"\n        self.scores.append(score)\n    \n    def get_average_score(self) -&gt; Optional[float]:\n        \"\"\"平均点を取得\"\"\"\n        if not self.scores:\n            return None\n        return sum(self.scores) / len(self.scores)\n    \n    def get_info(self) -&gt; Dict[str, Union[str, int, float, None]]:\n        \"\"\"学生情報を辞書で返す\"\"\"\n        return {\n            \"name\": self.name,\n            \"age\": self.age,\n            \"grade\": self.grade,\n            \"average_score\": self.get_average_score()\n        }\n    \n    def __str__(self) -&gt; str:\n        return f\"学生: {self.name} ({self.age}歳, {self.grade}年生)\"\n\n# 使用例\nstudent = Student(\"田中太郎\", 20, 2)\nstudent.add_score(85.5)\nstudent.add_score(92.0)\nstudent.add_score(78.5)\n\nprint(student)\nprint(f\"平均点: {student.get_average_score():.1f}\")\nprint(f\"詳細情報: {student.get_info()}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#ジェネリック型",
    "href": "book/10-type-hints.html#ジェネリック型",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.5 ジェネリック型",
    "text": "11.5 ジェネリック型\n\nfrom typing import TypeVar, Generic, List\n\n# 型変数の定義\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    \"\"\"ジェネリックなスタッククラス\"\"\"\n    \n    def __init__(self) -&gt; None:\n        self._items: List[T] = []\n    \n    def push(self, item: T) -&gt; None:\n        \"\"\"要素をプッシュ\"\"\"\n        self._items.append(item)\n    \n    def pop(self) -&gt; Optional[T]:\n        \"\"\"要素をポップ\"\"\"\n        if self._items:\n            return self._items.pop()\n        return None\n    \n    def peek(self) -&gt; Optional[T]:\n        \"\"\"トップの要素を確認\"\"\"\n        if self._items:\n            return self._items[-1]\n        return None\n    \n    def is_empty(self) -&gt; bool:\n        \"\"\"スタックが空かどうか\"\"\"\n        return len(self._items) == 0\n    \n    def size(self) -&gt; int:\n        \"\"\"スタックのサイズ\"\"\"\n        return len(self._items)\n\n# 文字列スタック\nstring_stack: Stack[str] = Stack()\nstring_stack.push(\"最初\")\nstring_stack.push(\"二番目\")\nstring_stack.push(\"三番目\")\n\nprint(f\"スタックサイズ: {string_stack.size()}\")\nprint(f\"トップ要素: {string_stack.peek()}\")\nprint(f\"ポップ: {string_stack.pop()}\")\n\n# 数値スタック\nnumber_stack: Stack[int] = Stack()\nnumber_stack.push(10)\nnumber_stack.push(20)\nnumber_stack.push(30)\n\nprint(f\"数値スタックサイズ: {number_stack.size()}\")\nprint(f\"数値トップ: {number_stack.peek()}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#高度な型ヒント",
    "href": "book/10-type-hints.html#高度な型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.6 高度な型ヒント",
    "text": "11.6 高度な型ヒント\n\n11.6.1 Callable 型\n\nfrom typing import Callable\n\ndef apply_operation(x: int, y: int, operation: Callable[[int, int], int]) -&gt; int:\n    \"\"\"二つの数値に演算を適用\"\"\"\n    return operation(x, y)\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\ndef multiply(a: int, b: int) -&gt; int:\n    return a * b\n\n# 使用例\nresult1 = apply_operation(10, 5, add)\nresult2 = apply_operation(10, 5, multiply)\n\nprint(f\"10 + 5 = {result1}\")\nprint(f\"10 × 5 = {result2}\")\n\n# ラムダ関数も使用可能\nresult3 = apply_operation(10, 5, lambda x, y: x - y)\nprint(f\"10 - 5 = {result3}\")\n\n\n\n11.6.2 Literal 型\n\nfrom typing import Literal\n\ndef set_color(color: Literal[\"red\", \"green\", \"blue\"]) -&gt; str:\n    \"\"\"指定された色を設定\"\"\"\n    return f\"色を {color} に設定しました\"\n\ndef calculate_shape_area(shape: Literal[\"circle\", \"square\", \"triangle\"], size: float) -&gt; float:\n    \"\"\"図形の面積を計算\"\"\"\n    import math\n    \n    if shape == \"circle\":\n        return math.pi * (size / 2) ** 2\n    elif shape == \"square\":\n        return size ** 2\n    elif shape == \"triangle\":\n        return (size ** 2) * math.sqrt(3) / 4\n    \n    return 0.0\n\n# 使用例\nprint(set_color(\"red\"))\nprint(set_color(\"blue\"))\n\narea1 = calculate_shape_area(\"circle\", 10)\narea2 = calculate_shape_area(\"square\", 10)\nprint(f\"円の面積 (直径10): {area1:.2f}\")\nprint(f\"正方形の面積 (辺10): {area2:.2f}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#型ヒントの検証",
    "href": "book/10-type-hints.html#型ヒントの検証",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.7 型ヒントの検証",
    "text": "11.7 型ヒントの検証\n\n11.7.1 mypy を使った静的型チェック\n\n# 以下は mypy でチェックできる例\n\ndef divide_numbers(a: int, b: int) -&gt; float:\n    \"\"\"数値を割り算する（型安全版）\"\"\"\n    if b == 0:\n        raise ValueError(\"ゼロで割ることはできません\")\n    return a / b\n\ndef process_user_data(data: Dict[str, Union[str, int]]) -&gt; str:\n    \"\"\"ユーザーデータを処理\"\"\"\n    name = data.get(\"name\", \"未知\")\n    age = data.get(\"age\", 0)\n    \n    if not isinstance(name, str):\n        name = str(name)\n    if not isinstance(age, int):\n        age = int(age) if str(age).isdigit() else 0\n    \n    return f\"{name} ({age}歳)\"\n\n# 正しい使用例\nresult = divide_numbers(10, 3)\nprint(f\"10 ÷ 3 = {result:.2f}\")\n\nuser = {\"name\": \"田中太郎\", \"age\": 25}\ninfo = process_user_data(user)\nprint(f\"ユーザー情報: {info}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#実践的な例タスク管理システム",
    "href": "book/10-type-hints.html#実践的な例タスク管理システム",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.8 実践的な例：タスク管理システム",
    "text": "11.8 実践的な例：タスク管理システム\n\nfrom typing import NamedTuple\nfrom enum import Enum\nfrom datetime import datetime, date\n\nclass Priority(Enum):\n    \"\"\"タスクの優先度\"\"\"\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    URGENT = 4\n\nclass Task(NamedTuple):\n    \"\"\"タスクデータ構造\"\"\"\n    id: int\n    title: str\n    description: str\n    priority: Priority\n    due_date: Optional[date]\n    completed: bool = False\n\nclass TaskManager:\n    \"\"\"タスク管理システム\"\"\"\n    \n    def __init__(self) -&gt; None:\n        self._tasks: Dict[int, Task] = {}\n        self._next_id: int = 1\n    \n    def create_task(\n        self, \n        title: str, \n        description: str, \n        priority: Priority = Priority.MEDIUM,\n        due_date: Optional[date] = None\n    ) -&gt; Task:\n        \"\"\"新しいタスクを作成\"\"\"\n        task = Task(\n            id=self._next_id,\n            title=title,\n            description=description,\n            priority=priority,\n            due_date=due_date\n        )\n        self._tasks[self._next_id] = task\n        self._next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -&gt; Optional[Task]:\n        \"\"\"IDでタスクを取得\"\"\"\n        return self._tasks.get(task_id)\n    \n    def get_tasks_by_priority(self, priority: Priority) -&gt; List[Task]:\n        \"\"\"優先度でタスクをフィルタ\"\"\"\n        return [task for task in self._tasks.values() if task.priority == priority]\n    \n    def complete_task(self, task_id: int) -&gt; bool:\n        \"\"\"タスクを完了にマーク\"\"\"\n        if task_id in self._tasks:\n            old_task = self._tasks[task_id]\n            self._tasks[task_id] = old_task._replace(completed=True)\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -&gt; List[Task]:\n        \"\"\"期限切れのタスクを取得\"\"\"\n        today = date.today()\n        return [\n            task for task in self._tasks.values()\n            if task.due_date and task.due_date &lt; today and not task.completed\n        ]\n\n# 使用例\nmanager = TaskManager()\n\n# タスクの作成\ntask1 = manager.create_task(\n    \"レポート作成\", \n    \"Python チュートリアルのレポートを書く\",\n    Priority.HIGH,\n    date(2024, 12, 31)\n)\n\ntask2 = manager.create_task(\n    \"買い物\", \n    \"食材を買いに行く\",\n    Priority.MEDIUM\n)\n\ntask3 = manager.create_task(\n    \"メール返信\", \n    \"重要なメールに返信する\",\n    Priority.URGENT,\n    date(2024, 1, 15)\n)\n\nprint(f\"作成されたタスク: {task1}\")\nprint(f\"高優先度タスク数: {len(manager.get_tasks_by_priority(Priority.HIGH))}\")\n\n# タスクの完了\nsuccess = manager.complete_task(task2.id)\nprint(f\"タスク完了: {success}\")\n\n# 期限切れタスクのチェック\noverdue = manager.get_overdue_tasks()\nprint(f\"期限切れタスク数: {len(overdue)}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#型ヒントのベストプラクティス",
    "href": "book/10-type-hints.html#型ヒントのベストプラクティス",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.9 型ヒントのベストプラクティス",
    "text": "11.9 型ヒントのベストプラクティス\n\n11.9.1 1. 段階的な導入\n\n# 始めは重要な関数から\ndef important_function(data: List[str]) -&gt; Dict[str, int]:\n    \"\"\"重要な処理を行う関数\"\"\"\n    result = {}\n    for item in data:\n        result[item] = len(item)\n    return result\n\n# 徐々に全体に拡張\n\n\n\n11.9.2 2. 複雑な型の簡略化\n\nfrom typing import TypeAlias, Any\n\n# 複雑な型を別名で定義\nUserData: TypeAlias = Dict[str, Union[str, int, List[str]]]\nProcessResult: TypeAlias = Tuple[bool, str, Optional[Dict[str, Any]]]\n\ndef process_user(data: UserData) -&gt; ProcessResult:\n    \"\"\"ユーザーデータを処理\"\"\"\n    try:\n        # 処理ロジック\n        return True, \"成功\", {\"processed\": True}\n    except Exception as e:\n        return False, str(e), None",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#まとめ",
    "href": "book/10-type-hints.html#まとめ",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.10 まとめ",
    "text": "11.10 まとめ\n型ヒントは以下の利点を提供します：\n\nコードの可読性向上: 関数の期待する入力と出力が明確\nIDE サポート: より良い自動補完とエラー検出\nバグの早期発見: 型チェッカーによる静的解析\nドキュメント: コード自体が型情報を含む\nリファクタリング支援: 型安全な変更が可能\n\n\n11.10.1 推奨事項\n\n新しいプロジェクトでは積極的に使用\n既存コードは段階的に追加\nmypy や pyright などの型チェッカーを活用\n複雑な型は TypeAlias で簡略化\nジェネリック型で再利用性を向上\n\n型ヒントは Python をより堅牢で保守性の高い言語にする重要な機能です。モダンな Python 開発では必須のスキルとなっています。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#次の章",
    "href": "book/10-type-hints.html#次の章",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.11 次の章",
    "text": "11.11 次の章\n次は非同期プログラミングについて学び、並行処理の基礎を理解しましょう。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/12-async.html",
    "href": "book/12-async.html",
    "title": "12  非同期プログラミングと並行性",
    "section": "",
    "text": "12.1 非同期プログラミングの理解\n非同期プログラミングを使用すると、ブロックすることなく複数のタスクを効率的に処理できる並行コードを記述できます。これは、Webリクエスト、ファイル操作、データベースクエリなどのI/Oバウンドな操作に最適です。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#非同期プログラミングの理解",
    "href": "book/12-async.html#非同期プログラミングの理解",
    "title": "12  非同期プログラミングと並行性",
    "section": "",
    "text": "12.1.1 同期 vs 非同期\n\nimport time\nimport asyncio\n\n# 同期的なアプローチ - ブロッキング\ndef sync_task(name: str, duration: int) -&gt; str:\n    \"\"\"時間のかかるタスクを同期的にシミュレート\"\"\"\n    print(f\"{name}を開始...\")\n    time.sleep(duration)  # プログラム全体をブロック\n    print(f\"{name}を完了\")\n    return f\"{name}からの結果\"\n\ndef run_sync_tasks():\n    \"\"\"複数のタスクを同期的に実行\"\"\"\n    print(\"=== 同期実行 ===\")\n    start_time = time.time()\n    \n    result1 = sync_task(\"タスク1\", 2)\n    result2 = sync_task(\"タスク2\", 2)\n    result3 = sync_task(\"タスク3\", 2)\n    \n    end_time = time.time()\n    print(f\"合計時間: {end_time - start_time:.2f}秒\")\n    return [result1, result2, result3]\n\n# 非同期的なアプローチ - ノンブロッキング\nasync def async_task(name: str, duration: int) -&gt; str:\n    \"\"\"時間のかかるタスクを非同期的にシミュレート\"\"\"\n    print(f\"{name}を開始...\")\n    await asyncio.sleep(duration)  # ノンブロッキングな待機\n    print(f\"{name}を完了\")\n    return f\"{name}からの結果\"\n\nasync def run_async_tasks():\n    \"\"\"複数のタスクを非同期的に実行\"\"\"\n    print(\"\\n=== 非同期実行 ===\")\n    start_time = time.time()\n    \n    # タスクを並行実行\n    results = await asyncio.gather(\n        async_task(\"タスク1\", 2),\n        async_task(\"タスク2\", 2),\n        async_task(\"タスク3\", 2)\n    )\n    \n    end_time = time.time()\n    print(f\"合計時間: {end_time - start_time:.2f}秒\")\n    return results\n\n# 実行比較\nprint(\"同期と非同期の実行時間比較:\")\nsync_results = run_sync_tasks()\n\n# 非同期の実行\nasync_results = await run_async_tasks()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#基本的な非同期パターン",
    "href": "book/12-async.html#基本的な非同期パターン",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.2 基本的な非同期パターン",
    "text": "12.2 基本的な非同期パターン\n\n12.2.1 async/await の基本\n\nimport asyncio\nimport random\n\nasync def fetch_data(url: str) -&gt; str:\n    \"\"\"Webからデータを取得する模擬関数\"\"\"\n    print(f\"データを取得中: {url}\")\n    \n    # ランダムな遅延で実際のHTTPリクエストをシミュレート\n    delay = random.uniform(1, 3)\n    await asyncio.sleep(delay)\n    \n    print(f\"データ取得完了: {url}\")\n    return f\"{url}からのデータ\"\n\nasync def process_data(data: str) -&gt; str:\n    \"\"\"データを処理する模擬関数\"\"\"\n    print(f\"データ処理中: {data}\")\n    \n    # 処理時間をシミュレート\n    await asyncio.sleep(1)\n    \n    processed = f\"処理済み: {data}\"\n    print(f\"データ処理完了: {processed}\")\n    return processed\n\nasync def fetch_and_process(url: str) -&gt; str:\n    \"\"\"データの取得と処理を順序実行\"\"\"\n    # 段階的な処理\n    raw_data = await fetch_data(url)\n    processed_data = await process_data(raw_data)\n    return processed_data\n\n# 複数URLの並行処理\nasync def main():\n    urls = [\n        \"https://api.example1.com\",\n        \"https://api.example2.com\", \n        \"https://api.example3.com\"\n    ]\n    \n    print(\"=== 複数URLの並行処理 ===\")\n    start_time = time.time()\n    \n    results = await asyncio.gather(\n        *[fetch_and_process(url) for url in urls]\n    )\n    \n    end_time = time.time()\n    print(f\"\\n処理完了！合計時間: {end_time - start_time:.2f}秒\")\n    \n    for i, result in enumerate(results, 1):\n        print(f\"結果{i}: {result}\")\n\n# 実行\nawait main()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#コルーチンとタスク",
    "href": "book/12-async.html#コルーチンとタスク",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.3 コルーチンとタスク",
    "text": "12.3 コルーチンとタスク\n\n12.3.1 Task の作成と管理\n\nimport asyncio\nfrom typing import List\n\nasync def download_file(filename: str, size_mb: int) -&gt; str:\n    \"\"\"ファイルダウンロードをシミュレート\"\"\"\n    print(f\"ダウンロード開始: {filename} ({size_mb}MB)\")\n    \n    # サイズに比例したダウンロード時間\n    download_time = size_mb * 0.5\n    await asyncio.sleep(download_time)\n    \n    print(f\"ダウンロード完了: {filename}\")\n    return f\"{filename} (サイズ: {size_mb}MB)\"\n\nasync def monitor_downloads():\n    \"\"\"ダウンロード監視\"\"\"\n    for i in range(5):\n        print(f\"監視中... ({i+1}/5)\")\n        await asyncio.sleep(1)\n    print(\"監視終了\")\n\nasync def manage_downloads():\n    \"\"\"ダウンロードタスクの管理\"\"\"\n    print(\"=== ダウンロード管理システム ===\")\n    \n    # ダウンロードタスクを作成\n    download_tasks = [\n        asyncio.create_task(download_file(\"document.pdf\", 10)),\n        asyncio.create_task(download_file(\"video.mp4\", 25)), \n        asyncio.create_task(download_file(\"image.jpg\", 5)),\n        asyncio.create_task(download_file(\"software.zip\", 15))\n    ]\n    \n    # 監視タスクを作成\n    monitor_task = asyncio.create_task(monitor_downloads())\n    \n    # すべてのダウンロードが完了するまで待機\n    print(\"ダウンロード開始...\")\n    completed_downloads = await asyncio.gather(*download_tasks)\n    \n    # 監視タスクをキャンセル（必要に応じて）\n    if not monitor_task.done():\n        monitor_task.cancel()\n        try:\n            await monitor_task\n        except asyncio.CancelledError:\n            print(\"監視タスクをキャンセルしました\")\n    \n    print(\"\\nすべてのダウンロードが完了:\")\n    for download in completed_downloads:\n        print(f\"  - {download}\")\n\n# 実行\nawait manage_downloads()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#エラーハンドリングとタイムアウト",
    "href": "book/12-async.html#エラーハンドリングとタイムアウト",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.4 エラーハンドリングとタイムアウト",
    "text": "12.4 エラーハンドリングとタイムアウト\n\n12.4.1 堅牢な非同期処理\n\nimport asyncio\nimport random\n\nasync def unreliable_api_call(api_name: str) -&gt; str:\n    \"\"\"不安定なAPIコールをシミュレート\"\"\"\n    print(f\"API呼び出し中: {api_name}\")\n    \n    # ランダムな遅延\n    delay = random.uniform(1, 5)\n    await asyncio.sleep(delay)\n    \n    # ランダムに失敗する\n    if random.random() &lt; 0.3:  # 30%の確率で失敗\n        raise Exception(f\"{api_name}でエラーが発生しました\")\n    \n    print(f\"API呼び出し成功: {api_name}\")\n    return f\"{api_name}からの応答データ\"\n\nasync def safe_api_call(api_name: str, timeout: float = 3.0, retries: int = 3) -&gt; str:\n    \"\"\"タイムアウトとリトライ機能付きのAPIコール\"\"\"\n    \n    for attempt in range(retries):\n        try:\n            print(f\"試行 {attempt + 1}/{retries}: {api_name}\")\n            \n            # タイムアウト付きで実行\n            result = await asyncio.wait_for(\n                unreliable_api_call(api_name),\n                timeout=timeout\n            )\n            \n            return result\n            \n        except asyncio.TimeoutError:\n            print(f\"タイムアウト: {api_name} (試行 {attempt + 1}/{retries})\")\n            if attempt == retries - 1:\n                raise Exception(f\"{api_name}: {retries}回すべてタイムアウト\")\n            \n        except Exception as e:\n            print(f\"エラー: {api_name} - {e} (試行 {attempt + 1}/{retries})\")\n            if attempt == retries - 1:\n                raise e\n            \n            # 指数バックオフでリトライ間隔を調整\n            await asyncio.sleep(2 ** attempt)\n    \n    raise Exception(f\"{api_name}: 予期しないエラー\")\n\nasync def batch_api_calls():\n    \"\"\"複数のAPIコールを並行実行（エラーハンドリング付き）\"\"\"\n    apis = [\"UserAPI\", \"ProductAPI\", \"OrderAPI\", \"PaymentAPI\"]\n    \n    results = []\n    errors = []\n    \n    # すべてのAPIコールを並行実行\n    tasks = [safe_api_call(api) for api in apis]\n    \n    # as_completed で完了順に処理\n    print(\"=== 並行APIコール（エラーハンドリング付き） ===\")\n    for completed_task in asyncio.as_completed(tasks):\n        try:\n            result = await completed_task\n            results.append(result)\n            print(f\"✅ 成功: {result}\")\n        except Exception as e:\n            errors.append(str(e))\n            print(f\"❌ 失敗: {e}\")\n    \n    print(f\"\\n結果: 成功 {len(results)}, 失敗 {len(errors)}\")\n    return results, errors\n\n# 実行\nawait batch_api_calls()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#実際のアプリケーション例",
    "href": "book/12-async.html#実際のアプリケーション例",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.5 実際のアプリケーション例",
    "text": "12.5 実際のアプリケーション例\n\n12.5.1 非同期Webスクレイピング\n\nimport asyncio\nimport time\nfrom typing import Dict, List\n\nclass AsyncWebScraper:\n    \"\"\"非同期Webスクレイピングクラス\"\"\"\n    \n    def __init__(self, max_concurrent: int = 5):\n        self.max_concurrent = max_concurrent\n        self.semaphore = asyncio.Semaphore(max_concurrent)\n        self.session_active = False\n    \n    async def fetch_page(self, url: str) -&gt; Dict:\n        \"\"\"単一ページの取得\"\"\"\n        async with self.semaphore:  # 同時リクエスト数を制限\n            print(f\"取得中: {url}\")\n            \n            # HTTPリクエストをシミュレート\n            delay = random.uniform(0.5, 2.0)\n            await asyncio.sleep(delay)\n            \n            # 模擬レスポンス\n            response = {\n                \"url\": url,\n                \"title\": f\"ページタイトル from {url}\",\n                \"content_length\": random.randint(1000, 10000),\n                \"load_time\": delay\n            }\n            \n            print(f\"完了: {url} ({delay:.2f}秒)\")\n            return response\n    \n    async def scrape_multiple(self, urls: List[str]) -&gt; List[Dict]:\n        \"\"\"複数ページの並行取得\"\"\"\n        print(f\"=== 非同期スクレイピング開始 ===\")\n        print(f\"対象URL数: {len(urls)}, 最大同時接続数: {self.max_concurrent}\")\n        \n        start_time = time.time()\n        \n        # すべてのタスクを作成\n        tasks = [self.fetch_page(url) for url in urls]\n        \n        # 完了順に結果を収集\n        results = []\n        for completed_task in asyncio.as_completed(tasks):\n            try:\n                result = await completed_task\n                results.append(result)\n                print(f\"進捗: {len(results)}/{len(urls)}\")\n            except Exception as e:\n                print(f\"エラー: {e}\")\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        \n        print(f\"\\n=== スクレイピング完了 ===\")\n        print(f\"総時間: {total_time:.2f}秒\")\n        print(f\"平均時間/URL: {total_time/len(urls):.2f}秒\")\n        \n        return results\n\n# チャット応答システム\nclass AsyncChatBot:\n    \"\"\"非同期チャットボット\"\"\"\n    \n    def __init__(self):\n        self.conversation_history = []\n        self.processing_queue = asyncio.Queue()\n        self.response_cache = {}\n    \n    async def process_message(self, user_id: str, message: str) -&gt; str:\n        \"\"\"メッセージを処理して応答を生成\"\"\"\n        print(f\"ユーザー{user_id}: {message}\")\n        \n        # キャッシュをチェック\n        cache_key = message.lower().strip()\n        if cache_key in self.response_cache:\n            print(f\"キャッシュから応答: {cache_key}\")\n            return self.response_cache[cache_key]\n        \n        # 処理時間をシミュレート\n        thinking_time = random.uniform(1, 3)\n        await asyncio.sleep(thinking_time)\n        \n        # 模擬応答生成\n        responses = [\n            f\"「{message}」について考えています...\",\n            f\"それは興味深い質問ですね。{message}について説明します。\",\n            f\"{message}に関する情報をお調べしました。\",\n            f\"ご質問の{message}についてお答えします。\"\n        ]\n        \n        response = random.choice(responses)\n        \n        # キャッシュに保存\n        self.response_cache[cache_key] = response\n        \n        # 会話履歴に追加\n        self.conversation_history.append({\n            \"user_id\": user_id,\n            \"message\": message,\n            \"response\": response,\n            \"timestamp\": time.time()\n        })\n        \n        print(f\"ボット → ユーザー{user_id}: {response}\")\n        return response\n    \n    async def handle_multiple_users(self, messages: List[tuple]) -&gt; List[str]:\n        \"\"\"複数ユーザーからのメッセージを並行処理\"\"\"\n        print(\"=== マルチユーザーチャット処理 ===\")\n        \n        tasks = [\n            self.process_message(user_id, message) \n            for user_id, message in messages\n        ]\n        \n        responses = await asyncio.gather(*tasks)\n        \n        print(f\"\\n処理完了: {len(responses)}件のメッセージ\")\n        return responses\n\n# 使用例\nasync def demo_applications():\n    \"\"\"実際のアプリケーション例のデモ\"\"\"\n    \n    # 1. Webスクレイピングのデモ\n    scraper = AsyncWebScraper(max_concurrent=3)\n    urls = [\n        \"https://example1.com\",\n        \"https://example2.com\", \n        \"https://example3.com\",\n        \"https://example4.com\",\n        \"https://example5.com\"\n    ]\n    \n    scraping_results = await scraper.scrape_multiple(urls)\n    \n    print(f\"\\nスクレイピング結果: {len(scraping_results)}ページ取得\")\n    \n    # 2. チャットボットのデモ  \n    print(\"\\n\" + \"=\"*50)\n    \n    chatbot = AsyncChatBot()\n    user_messages = [\n        (\"001\", \"Pythonについて教えて\"),\n        (\"002\", \"非同期プログラミングとは何ですか？\"),\n        (\"003\", \"Pythonについて教えて\"),  # キャッシュされる\n        (\"004\", \"AIの将来について\"),\n        (\"001\", \"ありがとうございます\")\n    ]\n    \n    chat_responses = await chatbot.handle_multiple_users(user_messages)\n    \n    print(f\"\\nチャット処理完了: {len(chat_responses)}件の応答\")\n\n# 実行\nawait demo_applications()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#パフォーマンス監視と最適化",
    "href": "book/12-async.html#パフォーマンス監視と最適化",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.6 パフォーマンス監視と最適化",
    "text": "12.6 パフォーマンス監視と最適化\n\n12.6.1 非同期プログラムの監視\n\nimport asyncio\nimport time\nfrom dataclasses import dataclass\nfrom typing import Callable, Any\n\n@dataclass\nclass TaskMetrics:\n    \"\"\"タスクのメトリクス\"\"\"\n    name: str\n    start_time: float\n    end_time: float = 0\n    duration: float = 0\n    status: str = \"running\"\n    result: Any = None\n    error: str = None\n\nclass AsyncProfiler:\n    \"\"\"非同期処理のプロファイラー\"\"\"\n    \n    def __init__(self):\n        self.metrics = {}\n        self.start_time = time.time()\n    \n    def profile_task(self, name: str):\n        \"\"\"タスクのプロファイリングデコレータ\"\"\"\n        def decorator(func: Callable):\n            async def wrapper(*args, **kwargs):\n                task_id = f\"{name}_{id(asyncio.current_task())}\"\n                \n                # メトリクス開始\n                self.metrics[task_id] = TaskMetrics(\n                    name=name,\n                    start_time=time.time()\n                )\n                \n                try:\n                    result = await func(*args, **kwargs)\n                    \n                    # 成功時のメトリクス更新\n                    metric = self.metrics[task_id]\n                    metric.end_time = time.time()\n                    metric.duration = metric.end_time - metric.start_time\n                    metric.status = \"completed\"\n                    metric.result = result\n                    \n                    return result\n                    \n                except Exception as e:\n                    # エラー時のメトリクス更新\n                    metric = self.metrics[task_id]\n                    metric.end_time = time.time()\n                    metric.duration = metric.end_time - metric.start_time\n                    metric.status = \"failed\"\n                    metric.error = str(e)\n                    \n                    raise e\n            \n            return wrapper\n        return decorator\n    \n    def get_summary(self) -&gt; dict:\n        \"\"\"実行サマリーを取得\"\"\"\n        if not self.metrics:\n            return {\"message\": \"メトリクスがありません\"}\n        \n        completed = [m for m in self.metrics.values() if m.status == \"completed\"]\n        failed = [m for m in self.metrics.values() if m.status == \"failed\"]\n        running = [m for m in self.metrics.values() if m.status == \"running\"]\n        \n        total_duration = time.time() - self.start_time\n        \n        summary = {\n            \"総実行時間\": f\"{total_duration:.2f}秒\",\n            \"総タスク数\": len(self.metrics),\n            \"完了\": len(completed),\n            \"失敗\": len(failed), \n            \"実行中\": len(running)\n        }\n        \n        if completed:\n            durations = [m.duration for m in completed]\n            summary.update({\n                \"平均実行時間\": f\"{sum(durations)/len(durations):.2f}秒\",\n                \"最短実行時間\": f\"{min(durations):.2f}秒\",\n                \"最長実行時間\": f\"{max(durations):.2f}秒\"\n            })\n        \n        return summary\n    \n    def print_detailed_report(self):\n        \"\"\"詳細レポートを表示\"\"\"\n        print(\"=== 非同期処理詳細レポート ===\")\n        \n        for task_id, metric in self.metrics.items():\n            status_emoji = {\n                \"completed\": \"✅\",\n                \"failed\": \"❌\", \n                \"running\": \"🔄\"\n            }.get(metric.status, \"❓\")\n            \n            print(f\"{status_emoji} {metric.name}\")\n            print(f\"   時間: {metric.duration:.2f}秒\")\n            print(f\"   ステータス: {metric.status}\")\n            \n            if metric.error:\n                print(f\"   エラー: {metric.error}\")\n            print()\n        \n        summary = self.get_summary()\n        print(\"=== サマリー ===\")\n        for key, value in summary.items():\n            print(f\"{key}: {value}\")\n\n# プロファイラーを使用したデモ\nprofiler = AsyncProfiler()\n\n@profiler.profile_task(\"データベース検索\")\nasync def database_query(query: str) -&gt; str:\n    \"\"\"データベースクエリをシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(0.5, 2.0))\n    if random.random() &lt; 0.1:  # 10%の確率で失敗\n        raise Exception(\"データベース接続エラー\")\n    return f\"クエリ結果: {query}\"\n\n@profiler.profile_task(\"API呼び出し\")\nasync def api_call(endpoint: str) -&gt; str:\n    \"\"\"API呼び出しをシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(1.0, 3.0))\n    if random.random() &lt; 0.15:  # 15%の確率で失敗\n        raise Exception(\"API応答エラー\")\n    return f\"API応答: {endpoint}\"\n\n@profiler.profile_task(\"ファイル処理\")\nasync def file_processing(filename: str) -&gt; str:\n    \"\"\"ファイル処理をシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(0.3, 1.5))\n    return f\"処理済み: {filename}\"\n\nasync def run_performance_demo():\n    \"\"\"パフォーマンス監視デモ\"\"\"\n    print(\"=== パフォーマンス監視デモ開始 ===\")\n    \n    # 複数のタスクを並行実行\n    tasks = []\n    \n    # データベースクエリタスク\n    for i in range(5):\n        tasks.append(database_query(f\"SELECT * FROM table_{i}\"))\n    \n    # API呼び出しタスク\n    endpoints = [\"users\", \"products\", \"orders\", \"payments\"]\n    for endpoint in endpoints:\n        tasks.append(api_call(endpoint))\n    \n    # ファイル処理タスク\n    files = [\"data1.csv\", \"data2.json\", \"report.pdf\"]\n    for filename in files:\n        tasks.append(file_processing(filename))\n    \n    # すべてのタスクを実行\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    \n    # 結果の分析\n    successful_results = [r for r in results if not isinstance(r, Exception)]\n    failed_results = [r for r in results if isinstance(r, Exception)]\n    \n    print(f\"\\n=== 実行結果 ===\")\n    print(f\"成功: {len(successful_results)}\")\n    print(f\"失敗: {len(failed_results)}\")\n    \n    # 詳細レポートを表示\n    profiler.print_detailed_report()\n\n# 実行\nawait run_performance_demo()\n\nこの章では、Pythonにおける非同期プログラミングの基本概念から実践的な応用まで学習しました。非同期プログラミングを適切に使用することで、I/Oバウンドなタスクのパフォーマンスを大幅に向上させることができます。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html",
    "href": "book/13-multiprocessing.html",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "",
    "text": "13.1 マルチプロセッシングの基本概念\nマルチプロセッシングは、複数のCPUコアを活用してCPU集約的なタスクを並列実行することで、プログラムのパフォーマンスを大幅に向上させる技術です。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#マルチプロセッシングの基本概念",
    "href": "book/13-multiprocessing.html#マルチプロセッシングの基本概念",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "",
    "text": "13.1.1 シングルプロセス vs マルチプロセス\n\nimport time\nimport multiprocessing as mp\nfrom typing import List\n\ndef cpu_intensive_task(n: int) -&gt; int:\n    \"\"\"CPU集約的なタスクをシミュレート（素数計算）\"\"\"\n    def is_prime(num):\n        if num &lt; 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    \n    return count\n\ndef sequential_processing(numbers: List[int]) -&gt; List[int]:\n    \"\"\"順次処理\"\"\"\n    print(\"=== 順次処理 ===\")\n    start_time = time.time()\n    \n    results = []\n    for i, n in enumerate(numbers, 1):\n        print(f\"タスク {i}/{len(numbers)} 処理中...\")\n        result = cpu_intensive_task(n)\n        results.append(result)\n    \n    end_time = time.time()\n    print(f\"順次処理時間: {end_time - start_time:.2f}秒\")\n    return results\n\ndef parallel_processing(numbers: List[int]) -&gt; List[int]:\n    \"\"\"並列処理\"\"\"\n    print(\"\\n=== 並列処理 ===\")\n    start_time = time.time()\n    \n    # CPUコア数を取得\n    num_cores = mp.cpu_count()\n    print(f\"利用可能CPUコア数: {num_cores}\")\n    \n    # プロセスプールを使用して並列実行\n    with mp.Pool(processes=num_cores) as pool:\n        results = pool.map(cpu_intensive_task, numbers)\n    \n    end_time = time.time()\n    print(f\"並列処理時間: {end_time - start_time:.2f}秒\")\n    return results\n\n# 性能比較デモ\ndef performance_comparison():\n    \"\"\"性能比較デモ\"\"\"\n    # テストデータ（素数計算の範囲）\n    test_numbers = [10000, 15000, 20000, 25000]\n    \n    print(\"CPU集約的タスクの性能比較\")\n    print(f\"テストデータ: {test_numbers}\")\n    \n    # 順次処理\n    seq_results = sequential_processing(test_numbers)\n    \n    # 並列処理\n    par_results = parallel_processing(test_numbers)\n    \n    # 結果の検証\n    print(f\"\\n=== 結果比較 ===\")\n    for i, (seq, par) in enumerate(zip(seq_results, par_results)):\n        print(f\"データ{i+1}: 順次={seq}, 並列={par}, 一致={seq==par}\")\n\n# 実行\nperformance_comparison()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#プロセス間通信",
    "href": "book/13-multiprocessing.html#プロセス間通信",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.2 プロセス間通信",
    "text": "13.2 プロセス間通信\n\n13.2.1 Queue を使った通信\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom queue import Empty\n\ndef producer(queue: mp.Queue, producer_id: int, item_count: int):\n    \"\"\"データを生成してキューに送信\"\"\"\n    print(f\"プロデューサー {producer_id} 開始\")\n    \n    for i in range(item_count):\n        # データ生成をシミュレート\n        time.sleep(random.uniform(0.1, 0.5))\n        \n        item = {\n            \"id\": f\"P{producer_id}-{i+1}\",\n            \"data\": f\"データ from プロデューサー{producer_id}\",\n            \"value\": random.randint(1, 100),\n            \"timestamp\": time.time()\n        }\n        \n        queue.put(item)\n        print(f\"プロデューサー {producer_id}: {item['id']} 送信\")\n    \n    # 終了シグナル\n    queue.put(None)\n    print(f\"プロデューサー {producer_id} 終了\")\n\ndef consumer(queue: mp.Queue, consumer_id: int, result_queue: mp.Queue):\n    \"\"\"キューからデータを受信して処理\"\"\"\n    print(f\"コンシューマー {consumer_id} 開始\")\n    processed_count = 0\n    \n    while True:\n        try:\n            # タイムアウト付きでアイテムを取得\n            item = queue.get(timeout=2)\n            \n            if item is None:\n                # 終了シグナルを受信\n                print(f\"コンシューマー {consumer_id}: 終了シグナル受信\")\n                queue.put(None)  # 他のコンシューマーのために再送\n                break\n            \n            # データ処理をシミュレート\n            processing_time = random.uniform(0.2, 0.8)\n            time.sleep(processing_time)\n            \n            # 処理結果\n            result = {\n                \"consumer_id\": consumer_id,\n                \"original_id\": item[\"id\"],\n                \"processed_value\": item[\"value\"] * 2,\n                \"processing_time\": processing_time\n            }\n            \n            result_queue.put(result)\n            processed_count += 1\n            \n            print(f\"コンシューマー {consumer_id}: {item['id']} 処理完了\")\n            \n        except Empty:\n            print(f\"コンシューマー {consumer_id}: タイムアウト\")\n            break\n    \n    print(f\"コンシューマー {consumer_id} 終了 (処理数: {processed_count})\")\n\ndef run_producer_consumer_demo():\n    \"\"\"プロデューサー・コンシューマーパターンのデモ\"\"\"\n    print(\"=== プロデューサー・コンシューマーパターン ===\")\n    \n    # キューを作成\n    data_queue = mp.Queue(maxsize=10)  # 最大10アイテム\n    result_queue = mp.Queue()\n    \n    # プロセスを作成\n    processes = []\n    \n    # プロデューサープロセス（2つ）\n    for i in range(2):\n        p = mp.Process(target=producer, args=(data_queue, i+1, 5))\n        processes.append(p)\n        p.start()\n    \n    # コンシューマープロセス（3つ）\n    for i in range(3):\n        p = mp.Process(target=consumer, args=(data_queue, i+1, result_queue))\n        processes.append(p)\n        p.start()\n    \n    # 全プロセスの完了を待機\n    for p in processes:\n        p.join()\n    \n    # 結果を収集\n    print(\"\\n=== 処理結果 ===\")\n    results = []\n    while not result_queue.empty():\n        try:\n            result = result_queue.get_nowait()\n            results.append(result)\n        except Empty:\n            break\n    \n    # 統計情報\n    print(f\"総処理数: {len(results)}\")\n    for consumer_id in range(1, 4):\n        consumer_results = [r for r in results if r['consumer_id'] == consumer_id]\n        print(f\"コンシューマー {consumer_id}: {len(consumer_results)}件処理\")\n\n# 実行\nrun_producer_consumer_demo()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#共有メモリとロック",
    "href": "book/13-multiprocessing.html#共有メモリとロック",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.3 共有メモリとロック",
    "text": "13.3 共有メモリとロック\n\n13.3.1 安全な共有リソースアクセス\n\nimport multiprocessing as mp\nimport time\nimport random\n\ndef unsafe_counter_worker(shared_counter, worker_id: int, iterations: int):\n    \"\"\"安全でない共有カウンター（競合状態の例）\"\"\"\n    print(f\"ワーカー {worker_id} 開始（安全でない版）\")\n    \n    for i in range(iterations):\n        # 現在の値を読み取り\n        current_value = shared_counter.value\n        \n        # 処理時間をシミュレート\n        time.sleep(random.uniform(0.001, 0.005))\n        \n        # 値を更新\n        shared_counter.value = current_value + 1\n        \n        if (i + 1) % 10 == 0:\n            print(f\"ワーカー {worker_id}: {i+1}/{iterations} 完了\")\n    \n    print(f\"ワーカー {worker_id} 終了\")\n\ndef safe_counter_worker(shared_counter, lock, worker_id: int, iterations: int):\n    \"\"\"安全な共有カウンター（ロック使用）\"\"\"\n    print(f\"ワーカー {worker_id} 開始（安全版）\")\n    \n    for i in range(iterations):\n        # ロックを取得してクリティカルセクションを保護\n        with lock:\n            current_value = shared_counter.value\n            time.sleep(random.uniform(0.001, 0.005))\n            shared_counter.value = current_value + 1\n        \n        if (i + 1) % 10 == 0:\n            print(f\"ワーカー {worker_id}: {i+1}/{iterations} 完了\")\n    \n    print(f\"ワーカー {worker_id} 終了\")\n\ndef demonstrate_race_condition():\n    \"\"\"競合状態のデモンストレーション\"\"\"\n    print(\"=== 競合状態のデモ ===\")\n    \n    # 安全でない共有カウンター\n    print(\"\\n1. 安全でない共有カウンター:\")\n    unsafe_counter = mp.Value('i', 0)\n    \n    processes = []\n    num_workers = 4\n    iterations_per_worker = 25\n    expected_total = num_workers * iterations_per_worker\n    \n    start_time = time.time()\n    \n    for i in range(num_workers):\n        p = mp.Process(target=unsafe_counter_worker, \n                      args=(unsafe_counter, i+1, iterations_per_worker))\n        processes.append(p)\n        p.start()\n    \n    for p in processes:\n        p.join()\n    \n    unsafe_result = unsafe_counter.value\n    unsafe_time = time.time() - start_time\n    \n    print(f\"期待値: {expected_total}\")\n    print(f\"実際の値: {unsafe_result}\")\n    print(f\"データ競合による損失: {expected_total - unsafe_result}\")\n    print(f\"実行時間: {unsafe_time:.2f}秒\")\n    \n    # 安全な共有カウンター\n    print(\"\\n2. 安全な共有カウンター（ロック使用）:\")\n    safe_counter = mp.Value('i', 0)\n    lock = mp.Lock()\n    \n    processes = []\n    start_time = time.time()\n    \n    for i in range(num_workers):\n        p = mp.Process(target=safe_counter_worker,\n                      args=(safe_counter, lock, i+1, iterations_per_worker))\n        processes.append(p)\n        p.start()\n    \n    for p in processes:\n        p.join()\n    \n    safe_result = safe_counter.value\n    safe_time = time.time() - start_time\n    \n    print(f\"期待値: {expected_total}\")\n    print(f\"実際の値: {safe_result}\")\n    print(f\"データ整合性: {'✅ 正確' if safe_result == expected_total else '❌ 不正確'}\")\n    print(f\"実行時間: {safe_time:.2f}秒\")\n\n# 実行\ndemonstrate_race_condition()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#実際のアプリケーション例",
    "href": "book/13-multiprocessing.html#実際のアプリケーション例",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.4 実際のアプリケーション例",
    "text": "13.4 実際のアプリケーション例\n\n13.4.1 画像処理の並列化\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom typing import List, Tuple\n\nclass ImageProcessor:\n    \"\"\"画像処理クラス（シミュレーション）\"\"\"\n    \n    @staticmethod\n    def process_image(image_info: Tuple[str, int, int]) -&gt; dict:\n        \"\"\"単一画像の処理\"\"\"\n        filename, width, height = image_info\n        print(f\"処理中: {filename} ({width}x{height})\")\n        \n        # 画像処理をシミュレート（サイズに比例した処理時間）\n        processing_time = (width * height) / 1000000  # 1M pixelで1秒\n        processing_time += random.uniform(0.1, 0.5)\n        time.sleep(processing_time)\n        \n        # 処理結果\n        result = {\n            \"filename\": filename,\n            \"original_size\": (width, height),\n            \"processed_size\": (width // 2, height // 2),  # リサイズ\n            \"processing_time\": processing_time,\n            \"file_size_kb\": (width * height * 3) // 1024,  # RGB仮定\n            \"status\": \"completed\"\n        }\n        \n        print(f\"完了: {filename} ({processing_time:.2f}秒)\")\n        return result\n    \n    @staticmethod\n    def process_batch_sequential(images: List[Tuple[str, int, int]]) -&gt; List[dict]:\n        \"\"\"逐次処理\"\"\"\n        print(\"=== 逐次画像処理 ===\")\n        start_time = time.time()\n        \n        results = []\n        for i, image in enumerate(images, 1):\n            print(f\"進捗: {i}/{len(images)}\")\n            result = ImageProcessor.process_image(image)\n            results.append(result)\n        \n        total_time = time.time() - start_time\n        print(f\"逐次処理完了: {total_time:.2f}秒\")\n        return results\n    \n    @staticmethod\n    def process_batch_parallel(images: List[Tuple[str, int, int]], num_processes: int = None) -&gt; List[dict]:\n        \"\"\"並列処理\"\"\"\n        if num_processes is None:\n            num_processes = mp.cpu_count()\n        \n        print(f\"=== 並列画像処理 (プロセス数: {num_processes}) ===\")\n        start_time = time.time()\n        \n        with mp.Pool(processes=num_processes) as pool:\n            results = pool.map(ImageProcessor.process_image, images)\n        \n        total_time = time.time() - start_time\n        print(f\"並列処理完了: {total_time:.2f}秒\")\n        return results\n\ndef batch_processing_demo():\n    \"\"\"バッチ処理のデモ\"\"\"\n    # テスト用画像データ\n    test_images = [\n        (\"photo1.jpg\", 4000, 3000),\n        (\"photo2.jpg\", 6000, 4000), \n        (\"photo3.jpg\", 3000, 2000),\n        (\"photo4.jpg\", 5000, 3500),\n        (\"photo5.jpg\", 4500, 3000),\n        (\"photo6.jpg\", 3500, 2500),\n    ]\n    \n    print(\"画像処理バッチ処理デモ\")\n    print(f\"処理対象: {len(test_images)}枚の画像\")\n    \n    # 逐次処理\n    sequential_results = ImageProcessor.process_batch_sequential(test_images)\n    \n    print(\"\\n\" + \"=\"*50)\n    \n    # 並列処理\n    parallel_results = ImageProcessor.process_batch_parallel(test_images)\n    \n    # パフォーマンス分析\n    seq_total_time = sum(r[\"processing_time\"] for r in sequential_results)\n    par_total_time = sum(r[\"processing_time\"] for r in parallel_results)\n    \n    print(f\"\\n=== パフォーマンス分析 ===\")\n    print(f\"逐次処理時間: {seq_total_time:.2f}秒\")\n    print(f\"並列処理時間: {par_total_time:.2f}秒\")\n    \n    if seq_total_time &gt; 0:\n        speedup = seq_total_time / par_total_time\n        print(f\"速度向上: {speedup:.2f}倍\")\n\n# データ分析の並列化\nclass DataAnalyzer:\n    \"\"\"データ分析クラス\"\"\"\n    \n    @staticmethod\n    def analyze_chunk(data_chunk: List[int]) -&gt; dict:\n        \"\"\"データチャンクの分析\"\"\"\n        chunk_id = id(data_chunk) % 1000  # チャンクID\n        print(f\"チャンク {chunk_id} 分析中... (サイズ: {len(data_chunk)})\")\n        \n        # 重い計算をシミュレート\n        time.sleep(0.5)\n        \n        result = {\n            \"chunk_id\": chunk_id,\n            \"size\": len(data_chunk),\n            \"sum\": sum(data_chunk),\n            \"avg\": sum(data_chunk) / len(data_chunk) if data_chunk else 0,\n            \"min\": min(data_chunk) if data_chunk else 0,\n            \"max\": max(data_chunk) if data_chunk else 0,\n            \"std\": 0  # 簡略化\n        }\n        \n        print(f\"チャンク {chunk_id} 分析完了\")\n        return result\n    \n    @staticmethod\n    def parallel_analyze(data: List[int], chunk_size: int = 1000) -&gt; dict:\n        \"\"\"大規模データの並列分析\"\"\"\n        print(f\"=== 大規模データ並列分析 ===\")\n        print(f\"データサイズ: {len(data):,} 要素\")\n        print(f\"チャンクサイズ: {chunk_size:,} 要素\")\n        \n        # データをチャンクに分割\n        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]\n        print(f\"チャンク数: {len(chunks)}\")\n        \n        start_time = time.time()\n        \n        # 並列分析実行\n        with mp.Pool(processes=mp.cpu_count()) as pool:\n            chunk_results = pool.map(DataAnalyzer.analyze_chunk, chunks)\n        \n        processing_time = time.time() - start_time\n        \n        # 結果を統合\n        total_sum = sum(r[\"sum\"] for r in chunk_results)\n        total_count = sum(r[\"size\"] for r in chunk_results)\n        overall_avg = total_sum / total_count if total_count &gt; 0 else 0\n        overall_min = min(r[\"min\"] for r in chunk_results if r[\"size\"] &gt; 0)\n        overall_max = max(r[\"max\"] for r in chunk_results if r[\"size\"] &gt; 0)\n        \n        final_result = {\n            \"total_elements\": total_count,\n            \"processing_time\": processing_time,\n            \"chunks_processed\": len(chunk_results),\n            \"sum\": total_sum,\n            \"average\": overall_avg,\n            \"minimum\": overall_min,\n            \"maximum\": overall_max\n        }\n        \n        print(f\"\\n=== 分析結果 ===\")\n        for key, value in final_result.items():\n            if isinstance(value, float):\n                print(f\"{key}: {value:.2f}\")\n            else:\n                print(f\"{key}: {value:,}\" if isinstance(value, int) else f\"{key}: {value}\")\n        \n        return final_result\n\ndef data_analysis_demo():\n    \"\"\"データ分析デモ\"\"\"\n    # 大規模データセットを生成\n    data_size = 50000\n    test_data = [random.randint(1, 1000) for _ in range(data_size)]\n    \n    print(\"大規模データ分析デモ\")\n    \n    # 並列分析実行\n    result = DataAnalyzer.parallel_analyze(test_data, chunk_size=5000)\n\n# 実行\nprint(\"=== マルチプロセッシングデモ ===\\n\")\n\n# 1. 画像処理デモ\nbatch_processing_demo()\n\nprint(\"\\n\" + \"=\"*70 + \"\\n\")\n\n# 2. データ分析デモ  \ndata_analysis_demo()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#プロセスプールとワーカー管理",
    "href": "book/13-multiprocessing.html#プロセスプールとワーカー管理",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.5 プロセスプールとワーカー管理",
    "text": "13.5 プロセスプールとワーカー管理\n\n13.5.1 高度なプロセス管理\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom typing import List, Callable, Any\n\nclass ProcessManager:\n    \"\"\"プロセス管理クラス\"\"\"\n    \n    def __init__(self, max_workers: int = None):\n        self.max_workers = max_workers or mp.cpu_count()\n        self.completed_tasks = 0\n        self.failed_tasks = 0\n        self.total_processing_time = 0\n    \n    def execute_with_progress(self, func: Callable, tasks: List[Any]) -&gt; List[Any]:\n        \"\"\"進捗表示付きでタスクを実行\"\"\"\n        print(f\"=== プロセスプール実行 ===\")\n        print(f\"ワーカー数: {self.max_workers}\")\n        print(f\"タスク数: {len(tasks)}\")\n        \n        results = []\n        start_time = time.time()\n        \n        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n            # 全タスクを送信\n            future_to_task = {executor.submit(func, task): task for task in tasks}\n            \n            # 完了順に結果を処理\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                \n                try:\n                    result = future.result()\n                    results.append(result)\n                    self.completed_tasks += 1\n                    \n                    print(f\"完了: {self.completed_tasks}/{len(tasks)} \"\n                          f\"({(self.completed_tasks/len(tasks)*100):.1f}%)\")\n                    \n                except Exception as e:\n                    self.failed_tasks += 1\n                    print(f\"エラー: タスク {task} - {e}\")\n                    results.append(None)\n        \n        self.total_processing_time = time.time() - start_time\n        \n        print(f\"\\n=== 実行完了 ===\")\n        print(f\"成功: {self.completed_tasks}\")\n        print(f\"失敗: {self.failed_tasks}\")\n        print(f\"総時間: {self.total_processing_time:.2f}秒\")\n        \n        return results\n\ndef complex_calculation(params: dict) -&gt; dict:\n    \"\"\"複雑な計算タスク\"\"\"\n    task_id = params[\"id\"]\n    complexity = params[\"complexity\"]\n    \n    print(f\"タスク {task_id} 開始 (複雑度: {complexity})\")\n    \n    # 計算の複雑さに応じた処理時間\n    processing_time = complexity * random.uniform(0.1, 0.3)\n    time.sleep(processing_time)\n    \n    # ランダムに失敗\n    if random.random() &lt; 0.1:  # 10%の確率で失敗\n        raise Exception(f\"タスク {task_id} で計算エラー\")\n    \n    result = {\n        \"task_id\": task_id,\n        \"result\": complexity ** 2,\n        \"processing_time\": processing_time,\n        \"worker_pid\": mp.current_process().pid\n    }\n    \n    print(f\"タスク {task_id} 完了\")\n    return result\n\ndef advanced_process_management_demo():\n    \"\"\"高度なプロセス管理デモ\"\"\"\n    # タスクリストを生成\n    tasks = [\n        {\"id\": i, \"complexity\": random.randint(1, 10)}\n        for i in range(20)\n    ]\n    \n    # プロセス管理器を作成\n    manager = ProcessManager(max_workers=4)\n    \n    # タスクを実行\n    results = manager.execute_with_progress(complex_calculation, tasks)\n    \n    # 成功した結果のみを分析\n    successful_results = [r for r in results if r is not None]\n    \n    if successful_results:\n        print(f\"\\n=== 結果分析 ===\")\n        total_result = sum(r[\"result\"] for r in successful_results)\n        avg_processing_time = sum(r[\"processing_time\"] for r in successful_results) / len(successful_results)\n        \n        # ワーカーごとの統計\n        worker_stats = {}\n        for result in successful_results:\n            pid = result[\"worker_pid\"]\n            if pid not in worker_stats:\n                worker_stats[pid] = {\"count\": 0, \"total_time\": 0}\n            worker_stats[pid][\"count\"] += 1\n            worker_stats[pid][\"total_time\"] += result[\"processing_time\"]\n        \n        print(f\"合計結果: {total_result}\")\n        print(f\"平均処理時間: {avg_processing_time:.2f}秒\")\n        print(f\"ワーカー統計:\")\n        for pid, stats in worker_stats.items():\n            avg_time = stats[\"total_time\"] / stats[\"count\"]\n            print(f\"  PID {pid}: {stats['count']}タスク, 平均{avg_time:.2f}秒\")\n\n# 実行\nadvanced_process_management_demo()\n\nこの章では、Pythonにおけるマルチプロセッシングの基本概念から実践的な応用まで学習しました。適切にマルチプロセッシングを活用することで、CPU集約的なタスクのパフォーマンスを大幅に向上させることができます。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html",
    "href": "book/14-data-science.html",
    "title": "14  データサイエンスとPython",
    "section": "",
    "text": "14.1 データサイエンスの基本ライブラリ\nPythonはデータサイエンスの分野で最も人気のある言語の一つです。豊富なライブラリエコシステムにより、データの収集、処理、分析、可視化まで一貫して行うことができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#データサイエンスの基本ライブラリ",
    "href": "book/14-data-science.html#データサイエンスの基本ライブラリ",
    "title": "14  データサイエンスとPython",
    "section": "",
    "text": "14.1.1 NumPy - 数値計算の基盤\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# NumPyの基本操作\nprint(\"=== NumPy基本操作 ===\")\n\n# 配列の作成\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(f\"1次元配列: {arr1}\")\nprint(f\"2次元配列:\\n{arr2}\")\nprint(f\"配列の形状: {arr2.shape}\")\nprint(f\"データ型: {arr2.dtype}\")\n\n# 特殊な配列の作成\nzeros = np.zeros((3, 4))\nones = np.ones((2, 3))\nrandom_arr = np.random.random((3, 3))\n\nprint(f\"\\nゼロ配列:\\n{zeros}\")\nprint(f\"ランダム配列:\\n{random_arr}\")\n\n# 数学的操作\ndata = np.array([1, 4, 9, 16, 25])\nprint(f\"\\n元のデータ: {data}\")\nprint(f\"平方根: {np.sqrt(data)}\")\nprint(f\"対数: {np.log(data)}\")\nprint(f\"合計: {np.sum(data)}\")\nprint(f\"平均: {np.mean(data)}\")\nprint(f\"標準偏差: {np.std(data)}\")\n\n\n\n14.1.2 Pandas - データ操作と分析\n\n# サンプルデータの作成\nprint(\"=== Pandas基本操作 ===\")\n\n# DataFrame の作成\nsales_data = {\n    '日付': pd.date_range('2024-01-01', periods=10, freq='D'),\n    '売上': [120, 150, 98, 200, 175, 160, 210, 185, 145, 190],\n    '商品': ['A', 'B', 'A', 'C', 'B', 'A', 'C', 'B', 'A', 'C'],\n    '地域': ['東京', '大阪', '東京', '福岡', '大阪', '東京', '福岡', '大阪', '東京', '福岡']\n}\n\ndf = pd.DataFrame(sales_data)\nprint(\"売上データ:\")\nprint(df)\n\n# 基本的な統計情報\nprint(f\"\\n基本統計:\")\nprint(df.describe())\n\n# グループ化と集計\nprint(f\"\\n商品別売上:\")\nproduct_sales = df.groupby('商品')['売上'].agg(['sum', 'mean', 'count'])\nprint(product_sales)\n\nprint(f\"\\n地域別売上:\")\nregion_sales = df.groupby('地域')['売上'].sum().sort_values(ascending=False)\nprint(region_sales)\n\n# データフィルタリング\nhigh_sales = df[df['売上'] &gt; 150]\nprint(f\"\\n高売上データ (&gt;150):\")\nprint(high_sales)\n\n\n\n14.1.3 データ可視化\n\n# matplotlib と seaborn を使った可視化\nprint(\"=== データ可視化 ===\")\n\n# 図のサイズとスタイルを設定\nplt.style.use('seaborn-v0_8')\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# 1. 売上の時系列グラフ\naxes[0, 0].plot(df['日付'], df['売上'], marker='o', linewidth=2)\naxes[0, 0].set_title('日別売上推移')\naxes[0, 0].set_xlabel('日付')\naxes[0, 0].set_ylabel('売上')\naxes[0, 0].tick_params(axis='x', rotation=45)\n\n# 2. 商品別売上の棒グラフ\nproduct_totals = df.groupby('商品')['売上'].sum()\naxes[0, 1].bar(product_totals.index, product_totals.values, color=['skyblue', 'lightgreen', 'lightcoral'])\naxes[0, 1].set_title('商品別総売上')\naxes[0, 1].set_xlabel('商品')\naxes[0, 1].set_ylabel('総売上')\n\n# 3. 地域別売上の円グラフ\nregion_totals = df.groupby('地域')['売上'].sum()\naxes[1, 0].pie(region_totals.values, labels=region_totals.index, autopct='%1.1f%%', startangle=90)\naxes[1, 0].set_title('地域別売上割合')\n\n# 4. 売上分布のヒストグラム\naxes[1, 1].hist(df['売上'], bins=6, color='orange', alpha=0.7, edgecolor='black')\naxes[1, 1].set_title('売上分布')\naxes[1, 1].set_xlabel('売上')\naxes[1, 1].set_ylabel('頻度')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"グラフを表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#実際のデータ分析プロジェクト",
    "href": "book/14-data-science.html#実際のデータ分析プロジェクト",
    "title": "14  データサイエンスとPython",
    "section": "14.2 実際のデータ分析プロジェクト",
    "text": "14.2 実際のデータ分析プロジェクト\n\n14.2.1 顧客データ分析\n\n# 模擬顧客データの作成\nnp.random.seed(42)\n\ncustomer_data = {\n    '顧客ID': range(1, 1001),\n    '年齢': np.random.normal(40, 15, 1000).astype(int),\n    '年収': np.random.normal(500, 150, 1000).astype(int),\n    '購入金額': np.random.normal(100, 30, 1000),\n    '購入回数': np.random.poisson(3, 1000),\n    '性別': np.random.choice(['男性', '女性'], 1000),\n    '地域': np.random.choice(['東京', '大阪', '名古屋', '福岡'], 1000, p=[0.4, 0.3, 0.2, 0.1])\n}\n\n# 年齢を現実的な範囲に調整\ncustomer_data['年齢'] = np.clip(customer_data['年齢'], 18, 80)\ncustomer_data['年収'] = np.clip(customer_data['年収'], 200, 1500)\ncustomer_data['購入金額'] = np.clip(customer_data['購入金額'], 10, 500)\n\ncustomers_df = pd.DataFrame(customer_data)\n\nprint(\"=== 顧客データ分析 ===\")\nprint(f\"データ形状: {customers_df.shape}\")\nprint(f\"\\n最初の5行:\")\nprint(customers_df.head())\n\n# データの基本統計\nprint(f\"\\n基本統計情報:\")\nprint(customers_df.describe())\n\n# 性別別分析\nprint(f\"\\n性別別統計:\")\ngender_stats = customers_df.groupby('性別').agg({\n    '年齢': ['mean', 'std'],\n    '年収': ['mean', 'std'], \n    '購入金額': ['mean', 'std'],\n    '購入回数': ['mean', 'std']\n}).round(2)\nprint(gender_stats)\n\n# 地域別分析\nprint(f\"\\n地域別統計:\")\nregion_stats = customers_df.groupby('地域').agg({\n    '購入金額': ['count', 'mean', 'sum'],\n    '購入回数': 'mean'\n}).round(2)\nprint(region_stats)\n\n\n\n14.2.2 相関分析と機械学習の基礎\n\n# 相関分析\nprint(\"=== 相関分析 ===\")\n\n# 数値データの相関マトリックス\nnumeric_columns = ['年齢', '年収', '購入金額', '購入回数']\ncorrelation_matrix = customers_df[numeric_columns].corr()\n\nprint(\"相関マトリックス:\")\nprint(correlation_matrix.round(3))\n\n# 可視化\nplt.figure(figsize=(10, 8))\n\n# 相関マトリックスのヒートマップ\nplt.subplot(2, 2, 1)\nsns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)\nplt.title('変数間の相関')\n\n# 年収と購入金額の散布図\nplt.subplot(2, 2, 2)\nplt.scatter(customers_df['年収'], customers_df['購入金額'], alpha=0.6)\nplt.xlabel('年収')\nplt.ylabel('購入金額')\nplt.title('年収 vs 購入金額')\n\n# 年齢別購入金額の箱ひげ図\nplt.subplot(2, 2, 3)\nage_groups = pd.cut(customers_df['年齢'], bins=[0, 30, 50, 100], labels=['若年', '中年', 'シニア'])\ncustomers_df['年齢層'] = age_groups\nsns.boxplot(data=customers_df, x='年齢層', y='購入金額')\nplt.title('年齢層別購入金額分布')\n\n# 地域別購入金額の棒グラフ\nplt.subplot(2, 2, 4)\nregion_avg = customers_df.groupby('地域')['購入金額'].mean().sort_values(ascending=False)\nplt.bar(region_avg.index, region_avg.values, color=['red', 'blue', 'green', 'orange'])\nplt.title('地域別平均購入金額')\nplt.ylabel('平均購入金額')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"相関分析の可視化を表示しました\")\n\n\n\n14.2.3 機械学習入門\n\n# 簡単な機械学習の例（線形回帰）\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\n\nprint(\"=== 機械学習入門 ===\")\n\n# 特徴量とターゲットの準備\nX = customers_df[['年齢', '年収', '購入回数']]  # 特徴量\ny = customers_df['購入金額']  # 予測対象\n\n# データを訓練用とテスト用に分割\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 線形回帰モデルの作成と訓練\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# 予測の実行\ny_pred = model.predict(X_test)\n\n# モデルの評価\nmse = mean_squared_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\n\nprint(f\"モデル評価:\")\nprint(f\"平均二乗誤差 (MSE): {mse:.2f}\")\nprint(f\"決定係数 (R²): {r2:.3f}\")\n\n# 特徴量の重要度\nfeature_importance = pd.DataFrame({\n    '特徴量': X.columns,\n    '係数': model.coef_,\n    '重要度': np.abs(model.coef_)\n}).sort_values('重要度', ascending=False)\n\nprint(f\"\\n特徴量の重要度:\")\nprint(feature_importance)\n\n# 予測結果の可視化\nplt.figure(figsize=(10, 6))\n\nplt.subplot(1, 2, 1)\nplt.scatter(y_test, y_pred, alpha=0.6)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)\nplt.xlabel('実際の購入金額')\nplt.ylabel('予測購入金額')\nplt.title(f'予測精度 (R² = {r2:.3f})')\n\nplt.subplot(1, 2, 2)\nresiduals = y_test - y_pred\nplt.scatter(y_pred, residuals, alpha=0.6)\nplt.axhline(y=0, color='r', linestyle='--')\nplt.xlabel('予測値')\nplt.ylabel('残差')\nplt.title('残差プロット')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"機械学習結果の可視化を表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#時系列データ分析",
    "href": "book/14-data-science.html#時系列データ分析",
    "title": "14  データサイエンスとPython",
    "section": "14.3 時系列データ分析",
    "text": "14.3 時系列データ分析\n\n14.3.1 トレンド分析と予測\n\n# 時系列データの作成\nprint(\"=== 時系列データ分析 ===\")\n\n# 月次売上データを作成\ndate_range = pd.date_range('2022-01-01', '2024-12-31', freq='M')\nnp.random.seed(42)\n\n# トレンドとノイズを含む売上データ\ntrend = np.linspace(1000, 1500, len(date_range))\nseasonal = 200 * np.sin(2 * np.pi * np.arange(len(date_range)) / 12)\nnoise = np.random.normal(0, 50, len(date_range))\nsales = trend + seasonal + noise\n\ntime_series_df = pd.DataFrame({\n    '日付': date_range,\n    '売上': sales\n})\n\nprint(f\"時系列データ形状: {time_series_df.shape}\")\nprint(f\"期間: {time_series_df['日付'].min()} から {time_series_df['日付'].max()}\")\n\n# 基本統計\nprint(f\"\\n売上統計:\")\nprint(f\"平均: {time_series_df['売上'].mean():.2f}\")\nprint(f\"最小: {time_series_df['売上'].min():.2f}\")\nprint(f\"最大: {time_series_df['売上'].max():.2f}\")\n\n# 移動平均の計算\ntime_series_df['移動平均_3M'] = time_series_df['売上'].rolling(window=3).mean()\ntime_series_df['移動平均_12M'] = time_series_df['売上'].rolling(window=12).mean()\n\n# 前年同月比の計算\ntime_series_df['前年同月比'] = time_series_df['売上'].pct_change(periods=12) * 100\n\n# 時系列の可視化\nplt.figure(figsize=(15, 10))\n\n# 売上推移\nplt.subplot(3, 1, 1)\nplt.plot(time_series_df['日付'], time_series_df['売上'], label='実際の売上', alpha=0.7)\nplt.plot(time_series_df['日付'], time_series_df['移動平均_3M'], label='3か月移動平均', linewidth=2)\nplt.plot(time_series_df['日付'], time_series_df['移動平均_12M'], label='12か月移動平均', linewidth=2)\nplt.title('月次売上推移')\nplt.ylabel('売上')\nplt.legend()\nplt.grid(True, alpha=0.3)\n\n# 季節性の分析\nplt.subplot(3, 1, 2)\nmonthly_avg = time_series_df.groupby(time_series_df['日付'].dt.month)['売上'].mean()\nplt.bar(monthly_avg.index, monthly_avg.values, color='lightblue', edgecolor='navy')\nplt.title('月別平均売上（季節性）')\nplt.xlabel('月')\nplt.ylabel('平均売上')\nplt.xticks(range(1, 13))\nplt.grid(True, alpha=0.3)\n\n# 前年同月比\nplt.subplot(3, 1, 3)\nplt.plot(time_series_df['日付'], time_series_df['前年同月比'], marker='o', linewidth=2, color='green')\nplt.axhline(y=0, color='red', linestyle='--', alpha=0.7)\nplt.title('前年同月比')\nplt.xlabel('日付')\nplt.ylabel('成長率 (%)')\nplt.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\nprint(\"時系列分析の可視化を表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#データサイエンスプロジェクトの実践例",
    "href": "book/14-data-science.html#データサイエンスプロジェクトの実践例",
    "title": "14  データサイエンスとPython",
    "section": "14.4 データサイエンスプロジェクトの実践例",
    "text": "14.4 データサイエンスプロジェクトの実践例\n\n14.4.1 A/Bテスト分析\n\n# A/Bテストのシミュレーション\nprint(\"=== A/Bテスト分析 ===\")\n\nnp.random.seed(42)\n\n# A/Bテストデータの作成\nn_users_a = 1000\nn_users_b = 1000\n\n# グループAとBのコンバージョン率\nconversion_rate_a = 0.12  # 12%\nconversion_rate_b = 0.15  # 15%\n\n# テストデータ生成\ngroup_a = np.random.binomial(1, conversion_rate_a, n_users_a)\ngroup_b = np.random.binomial(1, conversion_rate_b, n_users_b)\n\nab_test_df = pd.DataFrame({\n    'グループ': ['A'] * n_users_a + ['B'] * n_users_b,\n    'コンバージョン': np.concatenate([group_a, group_b])\n})\n\n# 基本統計\nresults = ab_test_df.groupby('グループ')['コンバージョン'].agg(['count', 'sum', 'mean']).round(4)\nresults.columns = ['ユーザー数', 'コンバージョン数', 'コンバージョン率']\n\nprint(\"A/Bテスト結果:\")\nprint(results)\n\n# 統計的有意性検定（カイ二乗検定）\nfrom scipy.stats import chi2_contingency\n\ncontingency_table = pd.crosstab(ab_test_df['グループ'], ab_test_df['コンバージョン'])\nchi2, p_value, dof, expected = chi2_contingency(contingency_table)\n\nprint(f\"\\n統計的検定結果:\")\nprint(f\"カイ二乗統計量: {chi2:.4f}\")\nprint(f\"p値: {p_value:.4f}\")\nprint(f\"有意水準0.05で{'有意' if p_value &lt; 0.05 else '有意でない'}な差\")\n\n# 効果の可視化\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nconversion_rates = results['コンバージョン率']\ncolors = ['lightblue', 'lightgreen']\nbars = plt.bar(conversion_rates.index, conversion_rates.values, color=colors, edgecolor='navy')\nplt.title('グループ別コンバージョン率')\nplt.ylabel('コンバージョン率')\nplt.ylim(0, max(conversion_rates.values) * 1.2)\n\n# 数値をバーの上に表示\nfor bar, rate in zip(bars, conversion_rates.values):\n    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.005, \n             f'{rate:.1%}', ha='center', va='bottom', fontweight='bold')\n\nplt.subplot(1, 2, 2)\nimprovement = (results.loc['B', 'コンバージョン率'] - results.loc['A', 'コンバージョン率']) / results.loc['A', 'コンバージョン率'] * 100\nplt.bar(['改善率'], [improvement], color='orange', edgecolor='red')\nplt.title(f'グループBの改善率')\nplt.ylabel('改善率 (%)')\nplt.text(0, improvement + 1, f'{improvement:.1f}%', ha='center', va='bottom', fontweight='bold')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"グループBはグループAより{improvement:.1f}%改善\")\n\n\n\n14.4.2 コホート分析\n\n# コホート分析（顧客のリテンション分析）\nprint(\"=== コホート分析 ===\")\n\n# サンプルデータの作成\nnp.random.seed(42)\n\n# 顧客の初回購入月と再購入データを生成\ncohort_data = []\nfor month in range(12):  # 12か月分\n    n_customers = np.random.randint(80, 120)  # 月ごとの新規顧客数\n    \n    for customer in range(n_customers):\n        customer_id = f\"C{month:02d}_{customer:03d}\"\n        first_purchase = pd.Timestamp('2024-01-01') + pd.DateOffset(months=month)\n        \n        # リテンション率をシミュレート（月が経つにつれて減少）\n        for future_month in range(6):  # 6か月先まで追跡\n            retention_prob = 0.8 * (0.85 ** future_month)  # 指数的減衰\n            if np.random.random() &lt; retention_prob:\n                purchase_date = first_purchase + pd.DateOffset(months=future_month)\n                cohort_data.append({\n                    '顧客ID': customer_id,\n                    '初回購入月': first_purchase,\n                    '購入月': purchase_date,\n                    '経過月数': future_month\n                })\n\ncohort_df = pd.DataFrame(cohort_data)\n\n# コホートテーブルの作成\ncohort_table = cohort_df.pivot_table(\n    index='初回購入月',\n    columns='経過月数', \n    values='顧客ID',\n    aggfunc='nunique'\n).fillna(0)\n\n# リテンション率の計算\ncohort_sizes = cohort_df.groupby('初回購入月')['顧客ID'].nunique()\nretention_table = cohort_table.divide(cohort_sizes, axis=0)\n\nprint(\"コホートリテンション率:\")\nprint(retention_table.round(3))\n\n# 可視化\nplt.figure(figsize=(15, 8))\n\nplt.subplot(2, 1, 1)\nsns.heatmap(retention_table, annot=True, fmt='.2%', cmap='YlOrRd', cbar_kws={'label': 'リテンション率'})\nplt.title('コホート別リテンション率')\nplt.ylabel('初回購入月')\nplt.xlabel('経過月数')\n\nplt.subplot(2, 1, 2)\navg_retention = retention_table.mean()\nplt.plot(avg_retention.index, avg_retention.values, marker='o', linewidth=3, markersize=8)\nplt.title('平均リテンション率の推移')\nplt.xlabel('経過月数')\nplt.ylabel('平均リテンション率')\nplt.grid(True, alpha=0.3)\nplt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: '{:.0%}'.format(y)))\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"平均リテンション率:\")\nfor month, rate in avg_retention.items():\n    print(f\"  {month}か月後: {rate:.1%}\")\n\nこの章では、Pythonを使ったデータサイエンスの基本から実践的な分析手法まで学習しました。NumPy、Pandas、Matplotlibなどの主要ライブラリを活用することで、データの収集、処理、分析、可視化を効率的に行うことができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html",
    "href": "book/15-applications.html",
    "title": "15  実践的なPythonアプリケーション",
    "section": "",
    "text": "15.1 タスク管理システム\nPythonの豊富なライブラリエコシステムを活用して、実際のビジネスや日常生活で役立つアプリケーションを構築する方法を学習します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#タスク管理システム",
    "href": "book/15-applications.html#タスク管理システム",
    "title": "15  実践的なPythonアプリケーション",
    "section": "",
    "text": "15.1.1 完全機能のタスクマネージャー\n\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nfrom enum import Enum\nimport json\n\nclass Priority(Enum):\n    \"\"\"タスクの優先度\"\"\"\n    LOW = \"低\"\n    MEDIUM = \"中\"\n    HIGH = \"高\"\n    URGENT = \"緊急\"\n\nclass Status(Enum):\n    \"\"\"タスクのステータス\"\"\"\n    TODO = \"未着手\"\n    IN_PROGRESS = \"進行中\"\n    COMPLETED = \"完了\"\n    CANCELLED = \"キャンセル\"\n\nclass Task:\n    \"\"\"個別タスククラス\"\"\"\n    \n    def __init__(self, title: str, description: str = \"\", priority: Priority = Priority.MEDIUM):\n        self.id = id(self)  # 簡易ID\n        self.title = title\n        self.description = description\n        self.priority = priority\n        self.status = Status.TODO\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n        self.due_date: Optional[datetime] = None\n        self.completed_at: Optional[datetime] = None\n        self.tags: List[str] = []\n    \n    def set_due_date(self, due_date: datetime):\n        \"\"\"期限を設定\"\"\"\n        self.due_date = due_date\n        self.updated_at = datetime.now()\n    \n    def add_tag(self, tag: str):\n        \"\"\"タグを追加\"\"\"\n        if tag not in self.tags:\n            self.tags.append(tag)\n            self.updated_at = datetime.now()\n    \n    def remove_tag(self, tag: str):\n        \"\"\"タグを削除\"\"\"\n        if tag in self.tags:\n            self.tags.remove(tag)\n            self.updated_at = datetime.now()\n    \n    def update_status(self, status: Status):\n        \"\"\"ステータスを更新\"\"\"\n        self.status = status\n        self.updated_at = datetime.now()\n        \n        if status == Status.COMPLETED:\n            self.completed_at = datetime.now()\n        elif self.completed_at:\n            self.completed_at = None\n    \n    def is_overdue(self) -&gt; bool:\n        \"\"\"期限切れかチェック\"\"\"\n        if not self.due_date or self.status == Status.COMPLETED:\n            return False\n        return datetime.now() &gt; self.due_date\n    \n    def days_until_due(self) -&gt; Optional[int]:\n        \"\"\"期限までの日数\"\"\"\n        if not self.due_date:\n            return None\n        delta = self.due_date - datetime.now()\n        return delta.days\n    \n    def to_dict(self) -&gt; Dict:\n        \"\"\"辞書形式に変換\"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority.value,\n            \"status\": self.status.value,\n            \"created_at\": self.created_at.isoformat(),\n            \"updated_at\": self.updated_at.isoformat(),\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n    \n    def __str__(self):\n        status_icon = {\n            Status.TODO: \"⏳\",\n            Status.IN_PROGRESS: \"🔄\", \n            Status.COMPLETED: \"✅\",\n            Status.CANCELLED: \"❌\"\n        }\n        \n        priority_icon = {\n            Priority.LOW: \"🔵\",\n            Priority.MEDIUM: \"🟡\",\n            Priority.HIGH: \"🟠\", \n            Priority.URGENT: \"🔴\"\n        }\n        \n        due_info = \"\"\n        if self.due_date:\n            days = self.days_until_due()\n            if days is not None:\n                if days &lt; 0:\n                    due_info = f\" (期限切れ: {abs(days)}日)\"\n                elif days == 0:\n                    due_info = \" (今日が期限)\"\n                else:\n                    due_info = f\" (あと{days}日)\"\n        \n        return f\"{status_icon[self.status]} {priority_icon[self.priority]} {self.title}{due_info}\"\n\nclass TaskManager:\n    \"\"\"タスク管理システム\"\"\"\n    \n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def create_task(self, title: str, description: str = \"\", priority: Priority = Priority.MEDIUM) -&gt; Task:\n        \"\"\"新しいタスクを作成\"\"\"\n        task = Task(title, description, priority)\n        self.tasks.append(task)\n        print(f\"✅ タスクを作成しました: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -&gt; Optional[Task]:\n        \"\"\"IDでタスクを取得\"\"\"\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def delete_task(self, task_id: int) -&gt; bool:\n        \"\"\"タスクを削除\"\"\"\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            print(f\"🗑️ タスクを削除しました: {task.title}\")\n            return True\n        return False\n    \n    def list_tasks(self, status_filter: Optional[Status] = None, priority_filter: Optional[Priority] = None) -&gt; List[Task]:\n        \"\"\"タスク一覧を取得\"\"\"\n        filtered_tasks = self.tasks\n        \n        if status_filter:\n            filtered_tasks = [t for t in filtered_tasks if t.status == status_filter]\n        \n        if priority_filter:\n            filtered_tasks = [t for t in filtered_tasks if t.priority == priority_filter]\n        \n        # 優先度とステータスでソート\n        priority_order = {Priority.URGENT: 0, Priority.HIGH: 1, Priority.MEDIUM: 2, Priority.LOW: 3}\n        status_order = {Status.IN_PROGRESS: 0, Status.TODO: 1, Status.COMPLETED: 2, Status.CANCELLED: 3}\n        \n        return sorted(filtered_tasks, key=lambda t: (status_order[t.status], priority_order[t.priority]))\n    \n    def get_overdue_tasks(self) -&gt; List[Task]:\n        \"\"\"期限切れタスクを取得\"\"\"\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def get_upcoming_tasks(self, days: int = 7) -&gt; List[Task]:\n        \"\"\"指定日数以内に期限が来るタスクを取得\"\"\"\n        upcoming = []\n        for task in self.tasks:\n            if task.due_date and task.status != Status.COMPLETED:\n                days_until = task.days_until_due()\n                if days_until is not None and 0 &lt;= days_until &lt;= days:\n                    upcoming.append(task)\n        return sorted(upcoming, key=lambda t: t.due_date)\n    \n    def get_statistics(self) -&gt; Dict:\n        \"\"\"統計情報を取得\"\"\"\n        total = len(self.tasks)\n        if total == 0:\n            return {\"message\": \"タスクがありません\"}\n        \n        completed = len([t for t in self.tasks if t.status == Status.COMPLETED])\n        in_progress = len([t for t in self.tasks if t.status == Status.IN_PROGRESS])\n        overdue = len(self.get_overdue_tasks())\n        \n        return {\n            \"総タスク数\": total,\n            \"完了済み\": completed,\n            \"進行中\": in_progress,\n            \"期限切れ\": overdue,\n            \"完了率\": f\"{(completed/total*100):.1f}%\" if total &gt; 0 else \"0%\"\n        }\n    \n    def export_to_json(self, filename: str):\n        \"\"\"JSONファイルにエクスポート\"\"\"\n        data = [task.to_dict() for task in self.tasks]\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n        print(f\"📄 {filename}にエクスポートしました\")\n\n# タスク管理システムのデモ\ndef demo_task_manager():\n    \"\"\"タスク管理システムのデモンストレーション\"\"\"\n    print(\"=== タスク管理システムデモ ===\")\n    \n    # タスクマネージャーを作成\n    tm = TaskManager()\n    \n    # サンプルタスクを作成\n    task1 = tm.create_task(\"プレゼン資料作成\", \"来週の会議用資料\", Priority.HIGH)\n    task2 = tm.create_task(\"買い物\", \"食材と日用品\", Priority.LOW)\n    task3 = tm.create_task(\"レポート提出\", \"月次売上レポート\", Priority.URGENT)\n    task4 = tm.create_task(\"システム更新\", \"セキュリティパッチ適用\", Priority.MEDIUM)\n    \n    # 期限を設定\n    task1.set_due_date(datetime.now() + timedelta(days=3))\n    task2.set_due_date(datetime.now() + timedelta(days=1))\n    task3.set_due_date(datetime.now() + timedelta(days=-1))  # 期限切れ\n    task4.set_due_date(datetime.now() + timedelta(days=7))\n    \n    # タグを追加\n    task1.add_tag(\"仕事\")\n    task1.add_tag(\"プレゼン\")\n    task2.add_tag(\"個人\")\n    task3.add_tag(\"仕事\")\n    task3.add_tag(\"緊急\")\n    task4.add_tag(\"IT\")\n    \n    # いくつかのタスクのステータスを更新\n    task2.update_status(Status.IN_PROGRESS)\n    task4.update_status(Status.COMPLETED)\n    \n    print(f\"\\n📋 全タスク一覧:\")\n    for task in tm.list_tasks():\n        print(f\"  {task}\")\n    \n    print(f\"\\n⚠️ 期限切れタスク:\")\n    for task in tm.get_overdue_tasks():\n        print(f\"  {task}\")\n    \n    print(f\"\\n📅 今後7日間の期限タスク:\")\n    for task in tm.get_upcoming_tasks(7):\n        print(f\"  {task}\")\n    \n    print(f\"\\n📊 統計情報:\")\n    stats = tm.get_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n\n# 実行\ndemo_task_manager()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#ファイル管理システム",
    "href": "book/15-applications.html#ファイル管理システム",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.2 ファイル管理システム",
    "text": "15.2 ファイル管理システム\n\n15.2.1 自動ファイル整理ツール\n\nimport os\nimport shutil\nfrom pathlib import Path\nfrom collections import defaultdict\nimport mimetypes\n\nclass FileOrganizer:\n    \"\"\"ファイル自動整理クラス\"\"\"\n    \n    def __init__(self, source_directory: str):\n        self.source_dir = Path(source_directory)\n        self.file_types = {\n            'images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'],\n            'documents': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt'],\n            'spreadsheets': ['.xls', '.xlsx', '.csv', '.ods'],\n            'presentations': ['.ppt', '.pptx', '.odp'],\n            'videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'],\n            'audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a'],\n            'archives': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2'],\n            'code': ['.py', '.js', '.html', '.css', '.java', '.cpp', '.c', '.php'],\n            'executables': ['.exe', '.msi', '.deb', '.rpm', '.dmg', '.app']\n        }\n        \n        self.stats = defaultdict(int)\n    \n    def get_file_category(self, file_path: Path) -&gt; str:\n        \"\"\"ファイルのカテゴリを判定\"\"\"\n        extension = file_path.suffix.lower()\n        \n        for category, extensions in self.file_types.items():\n            if extension in extensions:\n                return category\n        \n        return 'others'\n    \n    def create_directory_structure(self, target_dir: Path):\n        \"\"\"整理用ディレクトリ構造を作成\"\"\"\n        categories = list(self.file_types.keys()) + ['others']\n        \n        for category in categories:\n            category_dir = target_dir / category\n            category_dir.mkdir(parents=True, exist_ok=True)\n        \n        print(f\"📁 ディレクトリ構造を作成しました: {target_dir}\")\n    \n    def organize_files(self, target_directory: str, copy_mode: bool = True):\n        \"\"\"ファイルを整理\"\"\"\n        target_dir = Path(target_directory)\n        \n        if not self.source_dir.exists():\n            print(f\"❌ ソースディレクトリが存在しません: {self.source_dir}\")\n            return\n        \n        # ターゲットディレクトリを作成\n        target_dir.mkdir(parents=True, exist_ok=True)\n        self.create_directory_structure(target_dir)\n        \n        print(f\"🔄 ファイル整理開始...\")\n        print(f\"  ソース: {self.source_dir}\")\n        print(f\"  ターゲット: {target_dir}\")\n        print(f\"  モード: {'コピー' if copy_mode else '移動'}\")\n        \n        # ファイルを処理\n        for file_path in self.source_dir.rglob('*'):\n            if file_path.is_file():\n                self._process_file(file_path, target_dir, copy_mode)\n        \n        self._print_statistics()\n    \n    def _process_file(self, file_path: Path, target_dir: Path, copy_mode: bool):\n        \"\"\"個別ファイルを処理\"\"\"\n        category = self.get_file_category(file_path)\n        category_dir = target_dir / category\n        \n        # 同名ファイルがある場合の処理\n        target_file = category_dir / file_path.name\n        counter = 1\n        while target_file.exists():\n            name_parts = file_path.stem, counter, file_path.suffix\n            target_file = category_dir / f\"{name_parts[0]}_{name_parts[1]}{name_parts[2]}\"\n            counter += 1\n        \n        try:\n            if copy_mode:\n                shutil.copy2(file_path, target_file)\n                action = \"コピー\"\n            else:\n                shutil.move(str(file_path), str(target_file))\n                action = \"移動\"\n            \n            self.stats[category] += 1\n            self.stats['total'] += 1\n            \n            print(f\"  ✅ {action}: {file_path.name} → {category}/\")\n            \n        except Exception as e:\n            print(f\"  ❌ エラー: {file_path.name} - {e}\")\n            self.stats['errors'] += 1\n    \n    def _print_statistics(self):\n        \"\"\"統計情報を表示\"\"\"\n        print(f\"\\n📊 整理結果:\")\n        print(f\"  総ファイル数: {self.stats['total']}\")\n        \n        for category in self.file_types.keys():\n            if self.stats[category] &gt; 0:\n                print(f\"  {category}: {self.stats[category]}ファイル\")\n        \n        if self.stats['others'] &gt; 0:\n            print(f\"  その他: {self.stats['others']}ファイル\")\n        \n        if self.stats['errors'] &gt; 0:\n            print(f\"  エラー: {self.stats['errors']}ファイル\")\n    \n    def analyze_directory(self) -&gt; Dict:\n        \"\"\"ディレクトリを分析\"\"\"\n        if not self.source_dir.exists():\n            return {\"error\": \"ディレクトリが存在しません\"}\n        \n        analysis = {\n            'total_files': 0,\n            'total_size': 0,\n            'categories': defaultdict(list),\n            'largest_files': [],\n            'file_extensions': defaultdict(int)\n        }\n        \n        all_files = []\n        \n        for file_path in self.source_dir.rglob('*'):\n            if file_path.is_file():\n                file_size = file_path.stat().st_size\n                category = self.get_file_category(file_path)\n                extension = file_path.suffix.lower()\n                \n                analysis['total_files'] += 1\n                analysis['total_size'] += file_size\n                analysis['categories'][category].append({\n                    'name': file_path.name,\n                    'size': file_size,\n                    'path': str(file_path)\n                })\n                analysis['file_extensions'][extension] += 1\n                \n                all_files.append((file_path, file_size))\n        \n        # 最大ファイルトップ5\n        all_files.sort(key=lambda x: x[1], reverse=True)\n        analysis['largest_files'] = [\n            {'name': f.name, 'size': s, 'size_mb': s/(1024*1024)}\n            for f, s in all_files[:5]\n        ]\n        \n        return dict(analysis)\n\n# ファイル整理システムのデモ\ndef demo_file_organizer():\n    \"\"\"ファイル整理システムのデモ\"\"\"\n    print(\"=== ファイル整理システムデモ ===\")\n    \n    # テスト用のファイル構造を作成（シミュレーション）\n    test_files = [\n        \"report.pdf\", \"presentation.pptx\", \"photo1.jpg\", \"photo2.png\",\n        \"music.mp3\", \"video.mp4\", \"script.py\", \"data.csv\", \n        \"archive.zip\", \"document.docx\", \"image.gif\", \"code.js\"\n    ]\n    \n    print(f\"📁 テストファイル構造:\")\n    for file in test_files:\n        print(f\"  📄 {file}\")\n    \n    # ファイル分析のシミュレーション\n    organizer = FileOrganizer(\"./test_directory\")\n    \n    # 各ファイルタイプの分析\n    print(f\"\\n🔍 ファイルタイプ分析:\")\n    category_counts = defaultdict(int)\n    \n    for file in test_files:\n        file_path = Path(file)\n        category = organizer.get_file_category(file_path)\n        category_counts[category] += 1\n    \n    for category, count in category_counts.items():\n        print(f\"  {category}: {count}ファイル\")\n    \n    print(f\"\\n📋 推奨整理構造:\")\n    for category in organizer.file_types.keys():\n        if category_counts[category] &gt; 0:\n            print(f\"  📁 {category}/ ({category_counts[category]}ファイル)\")\n    \n    if category_counts['others'] &gt; 0:\n        print(f\"  📁 others/ ({category_counts['others']}ファイル)\")\n\ndemo_file_organizer()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#webスクレイピングツール",
    "href": "book/15-applications.html#webスクレイピングツール",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.3 Webスクレイピングツール",
    "text": "15.3 Webスクレイピングツール\n\n15.3.1 自動データ収集システム\n\nimport requests\nfrom urllib.parse import urljoin, urlparse\nimport time\nimport csv\nfrom typing import List, Dict\nimport json\n\nclass WebScraper:\n    \"\"\"Webスクレイピングクラス\"\"\"\n    \n    def __init__(self, delay: float = 1.0):\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        })\n        self.delay = delay\n        self.scraped_data = []\n    \n    def get_page(self, url: str) -&gt; requests.Response:\n        \"\"\"ページを取得\"\"\"\n        try:\n            print(f\"🌐 取得中: {url}\")\n            response = self.session.get(url)\n            response.raise_for_status()\n            time.sleep(self.delay)  # レート制限\n            return response\n        except requests.RequestException as e:\n            print(f\"❌ エラー: {url} - {e}\")\n            raise\n    \n    def extract_text_content(self, html: str, selectors: List[str]) -&gt; Dict[str, str]:\n        \"\"\"HTMLからテキストコンテンツを抽出（BeautifulSoupの代替として簡略化）\"\"\"\n        # 実際の実装ではBeautifulSoupを使用\n        # ここでは簡略化したデモ用の実装\n        extracted = {}\n        \n        # 模擬的な抽出（実際にはHTML解析が必要）\n        for selector in selectors:\n            if selector == 'title':\n                extracted['title'] = f\"サンプルタイトル from {html[:20]}...\"\n            elif selector == 'price':\n                extracted['price'] = \"¥1,000\"\n            elif selector == 'description':\n                extracted['description'] = \"サンプル商品説明\"\n        \n        return extracted\n    \n    def scrape_product_data(self, urls: List[str]) -&gt; List[Dict]:\n        \"\"\"商品データをスクレイピング\"\"\"\n        print(f\"🛒 商品データスクレイピング開始 ({len(urls)}件)\")\n        \n        products = []\n        selectors = ['title', 'price', 'description']\n        \n        for i, url in enumerate(urls, 1):\n            try:\n                print(f\"進捗: {i}/{len(urls)}\")\n                \n                # ページを取得（実際の実装）\n                # response = self.get_page(url)\n                # extracted = self.extract_text_content(response.text, selectors)\n                \n                # デモ用の模擬データ\n                extracted = {\n                    'url': url,\n                    'title': f\"商品 {i}\",\n                    'price': f\"¥{1000 + i * 100:,}\",\n                    'description': f\"高品質な商品{i}の詳細説明\",\n                    'scraped_at': time.strftime('%Y-%m-%d %H:%M:%S')\n                }\n                \n                products.append(extracted)\n                print(f\"  ✅ {extracted['title']} - {extracted['price']}\")\n                \n                # レート制限\n                time.sleep(self.delay)\n                \n            except Exception as e:\n                print(f\"  ❌ スキップ: {url} - {e}\")\n                continue\n        \n        self.scraped_data = products\n        print(f\"✨ スクレイピング完了: {len(products)}件\")\n        return products\n    \n    def save_to_csv(self, filename: str):\n        \"\"\"CSVファイルに保存\"\"\"\n        if not self.scraped_data:\n            print(\"❌ 保存するデータがありません\")\n            return\n        \n        with open(filename, 'w', newline='', encoding='utf-8') as f:\n            writer = csv.DictWriter(f, fieldnames=self.scraped_data[0].keys())\n            writer.writeheader()\n            writer.writerows(self.scraped_data)\n        \n        print(f\"💾 {filename}に保存しました ({len(self.scraped_data)}件)\")\n    \n    def save_to_json(self, filename: str):\n        \"\"\"JSONファイルに保存\"\"\"\n        if not self.scraped_data:\n            print(\"❌ 保存するデータがありません\")\n            return\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(self.scraped_data, f, ensure_ascii=False, indent=2)\n        \n        print(f\"💾 {filename}に保存しました ({len(self.scraped_data)}件)\")\n    \n    def get_statistics(self) -&gt; Dict:\n        \"\"\"統計情報を取得\"\"\"\n        if not self.scraped_data:\n            return {\"message\": \"データがありません\"}\n        \n        # 価格統計（¥記号と,を除去して数値化）\n        prices = []\n        for item in self.scraped_data:\n            try:\n                price_str = item['price'].replace('¥', '').replace(',', '')\n                prices.append(int(price_str))\n            except (ValueError, KeyError):\n                continue\n        \n        stats = {\n            \"総データ数\": len(self.scraped_data),\n            \"価格データ数\": len(prices)\n        }\n        \n        if prices:\n            stats.update({\n                \"平均価格\": f\"¥{sum(prices)//len(prices):,}\",\n                \"最低価格\": f\"¥{min(prices):,}\",\n                \"最高価格\": f\"¥{max(prices):,}\"\n            })\n        \n        return stats\n\n# ニュース記事スクレイパー\nclass NewsArticleScraper(WebScraper):\n    \"\"\"ニュース記事専用スクレイパー\"\"\"\n    \n    def scrape_news_articles(self, rss_urls: List[str]) -&gt; List[Dict]:\n        \"\"\"ニュース記事をスクレイピング\"\"\"\n        print(f\"📰 ニュース記事スクレイピング開始\")\n        \n        articles = []\n        \n        # デモ用の模擬記事データ\n        sample_articles = [\n            {\n                \"title\": \"Python 3.12の新機能発表\",\n                \"summary\": \"Pythonの最新バージョンに追加された新機能について\",\n                \"category\": \"テクノロジー\",\n                \"published_date\": \"2024-01-15\"\n            },\n            {\n                \"title\": \"AIとプログラミング教育の未来\", \n                \"summary\": \"人工知能技術がプログラミング教育に与える影響\",\n                \"category\": \"教育\",\n                \"published_date\": \"2024-01-14\"\n            },\n            {\n                \"title\": \"データサイエンス市場の成長\",\n                \"summary\": \"データサイエンス分野の市場規模と将来展望\",\n                \"category\": \"ビジネス\", \n                \"published_date\": \"2024-01-13\"\n            }\n        ]\n        \n        for i, article in enumerate(sample_articles, 1):\n            article['id'] = i\n            article['scraped_at'] = time.strftime('%Y-%m-%d %H:%M:%S')\n            articles.append(article)\n            print(f\"  📄 {article['title']}\")\n            time.sleep(0.5)  # デモ用の遅延\n        \n        self.scraped_data = articles\n        return articles\n    \n    def filter_by_category(self, category: str) -&gt; List[Dict]:\n        \"\"\"カテゴリでフィルタリング\"\"\"\n        return [article for article in self.scraped_data \n                if article.get('category') == category]\n    \n    def get_recent_articles(self, days: int = 7) -&gt; List[Dict]:\n        \"\"\"最近の記事を取得\"\"\"\n        # 簡略化: 全記事を返す\n        return self.scraped_data\n\n# Webスクレイピングデモ\ndef demo_web_scraping():\n    \"\"\"Webスクレイピングデモ\"\"\"\n    print(\"=== Webスクレイピングデモ ===\")\n    \n    # 1. 商品データスクレイピング\n    product_scraper = WebScraper(delay=0.5)\n    \n    sample_urls = [\n        \"https://example-shop.com/product1\",\n        \"https://example-shop.com/product2\", \n        \"https://example-shop.com/product3\",\n        \"https://example-shop.com/product4\"\n    ]\n    \n    products = product_scraper.scrape_product_data(sample_urls)\n    \n    print(f\"\\n📊 商品データ統計:\")\n    stats = product_scraper.get_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # 2. ニュース記事スクレイピング\n    print(f\"\\n\" + \"=\"*50)\n    \n    news_scraper = NewsArticleScraper(delay=0.3)\n    articles = news_scraper.scrape_news_articles([])\n    \n    print(f\"\\n📰 取得した記事:\")\n    for article in articles:\n        print(f\"  📄 [{article['category']}] {article['title']}\")\n        print(f\"      {article['summary']}\")\n        print(f\"      📅 {article['published_date']}\")\n        print()\n    \n    # カテゴリ別フィルタリング\n    tech_articles = news_scraper.filter_by_category(\"テクノロジー\")\n    print(f\"🔧 テクノロジー記事: {len(tech_articles)}件\")\n\ndemo_web_scraping()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#システム監視ツール",
    "href": "book/15-applications.html#システム監視ツール",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.4 システム監視ツール",
    "text": "15.4 システム監視ツール\n\n15.4.1 パフォーマンス監視システム\n\nimport psutil\nimport time\nfrom datetime import datetime\nfrom typing import Dict, List\nimport json\n\nclass SystemMonitor:\n    \"\"\"システム監視クラス\"\"\"\n    \n    def __init__(self):\n        self.monitoring_data = []\n        self.alerts = []\n        self.thresholds = {\n            'cpu_percent': 80.0,\n            'memory_percent': 85.0,\n            'disk_percent': 90.0\n        }\n    \n    def get_system_info(self) -&gt; Dict:\n        \"\"\"システム基本情報を取得\"\"\"\n        info = {\n            'timestamp': datetime.now().isoformat(),\n            'cpu': {\n                'percent': psutil.cpu_percent(interval=1),\n                'count': psutil.cpu_count(),\n                'freq': psutil.cpu_freq()._asdict() if psutil.cpu_freq() else None\n            },\n            'memory': {\n                'total': psutil.virtual_memory().total,\n                'available': psutil.virtual_memory().available, \n                'percent': psutil.virtual_memory().percent,\n                'used': psutil.virtual_memory().used\n            },\n            'disk': {\n                'total': psutil.disk_usage('/').total,\n                'used': psutil.disk_usage('/').used,\n                'free': psutil.disk_usage('/').free,\n                'percent': psutil.disk_usage('/').percent\n            },\n            'network': psutil.net_io_counters()._asdict(),\n            'processes': len(psutil.pids())\n        }\n        \n        return info\n    \n    def format_bytes(self, bytes_value: int) -&gt; str:\n        \"\"\"バイト数を読みやすい形式に変換\"\"\"\n        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n            if bytes_value &lt; 1024.0:\n                return f\"{bytes_value:.2f} {unit}\"\n            bytes_value /= 1024.0\n        return f\"{bytes_value:.2f} PB\"\n    \n    def check_alerts(self, system_info: Dict):\n        \"\"\"アラートをチェック\"\"\"\n        alerts = []\n        \n        if system_info['cpu']['percent'] &gt; self.thresholds['cpu_percent']:\n            alerts.append({\n                'type': 'CPU',\n                'level': '警告',\n                'message': f\"CPU使用率が高いです: {system_info['cpu']['percent']:.1f}%\",\n                'timestamp': system_info['timestamp']\n            })\n        \n        if system_info['memory']['percent'] &gt; self.thresholds['memory_percent']:\n            alerts.append({\n                'type': 'Memory',\n                'level': '警告', \n                'message': f\"メモリ使用率が高いです: {system_info['memory']['percent']:.1f}%\",\n                'timestamp': system_info['timestamp']\n            })\n        \n        if system_info['disk']['percent'] &gt; self.thresholds['disk_percent']:\n            alerts.append({\n                'type': 'Disk',\n                'level': '警告',\n                'message': f\"ディスク使用率が高いです: {system_info['disk']['percent']:.1f}%\", \n                'timestamp': system_info['timestamp']\n            })\n        \n        self.alerts.extend(alerts)\n        return alerts\n    \n    def display_system_status(self):\n        \"\"\"システム状態を表示\"\"\"\n        info = self.get_system_info()\n        \n        print(f\"🖥️ システム監視レポート - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"{'='*60}\")\n        \n        # CPU情報\n        print(f\"💻 CPU\")\n        print(f\"  使用率: {info['cpu']['percent']:.1f}%\")\n        print(f\"  コア数: {info['cpu']['count']}\")\n        if info['cpu']['freq']:\n            print(f\"  周波数: {info['cpu']['freq']['current']:.0f} MHz\")\n        \n        # メモリ情報\n        print(f\"\\n🧠 メモリ\")\n        print(f\"  使用率: {info['memory']['percent']:.1f}%\")\n        print(f\"  総容量: {self.format_bytes(info['memory']['total'])}\")\n        print(f\"  使用量: {self.format_bytes(info['memory']['used'])}\")\n        print(f\"  利用可能: {self.format_bytes(info['memory']['available'])}\")\n        \n        # ディスク情報\n        print(f\"\\n💾 ディスク\")\n        print(f\"  使用率: {info['disk']['percent']:.1f}%\")\n        print(f\"  総容量: {self.format_bytes(info['disk']['total'])}\")\n        print(f\"  使用量: {self.format_bytes(info['disk']['used'])}\")\n        print(f\"  空き容量: {self.format_bytes(info['disk']['free'])}\")\n        \n        # ネットワーク情報\n        print(f\"\\n🌐 ネットワーク\")\n        print(f\"  送信: {self.format_bytes(info['network']['bytes_sent'])}\")\n        print(f\"  受信: {self.format_bytes(info['network']['bytes_recv'])}\")\n        \n        # プロセス情報\n        print(f\"\\n⚙️ プロセス数: {info['processes']}\")\n        \n        # アラートチェック\n        alerts = self.check_alerts(info)\n        if alerts:\n            print(f\"\\n⚠️ アラート:\")\n            for alert in alerts:\n                print(f\"  {alert['level']}: {alert['message']}\")\n        else:\n            print(f\"\\n✅ システム正常\")\n        \n        return info\n    \n    def monitor_continuous(self, duration: int = 60, interval: int = 5):\n        \"\"\"継続監視\"\"\"\n        print(f\"🔄 システム監視開始 (継続時間: {duration}秒, 間隔: {interval}秒)\")\n        \n        start_time = time.time()\n        iteration = 0\n        \n        while time.time() - start_time &lt; duration:\n            iteration += 1\n            print(f\"\\n--- 監視サイクル {iteration} ---\")\n            \n            system_info = self.display_system_status()\n            self.monitoring_data.append(system_info)\n            \n            # 次の監視まで待機\n            if time.time() - start_time &lt; duration:\n                print(f\"\\n⏳ {interval}秒後に次の監視...\")\n                time.sleep(interval)\n        \n        print(f\"\\n✅ 監視完了\")\n        self._generate_summary_report()\n    \n    def _generate_summary_report(self):\n        \"\"\"サマリーレポートを生成\"\"\"\n        if not self.monitoring_data:\n            return\n        \n        print(f\"\\n📊 監視サマリーレポート\")\n        print(f\"{'='*60}\")\n        print(f\"監視期間: {len(self.monitoring_data)} サイクル\")\n        \n        # CPU統計\n        cpu_usage = [data['cpu']['percent'] for data in self.monitoring_data]\n        print(f\"\\n💻 CPU使用率統計:\")\n        print(f\"  平均: {sum(cpu_usage)/len(cpu_usage):.1f}%\")\n        print(f\"  最大: {max(cpu_usage):.1f}%\")\n        print(f\"  最小: {min(cpu_usage):.1f}%\")\n        \n        # メモリ統計\n        memory_usage = [data['memory']['percent'] for data in self.monitoring_data]\n        print(f\"\\n🧠 メモリ使用率統計:\")\n        print(f\"  平均: {sum(memory_usage)/len(memory_usage):.1f}%\")\n        print(f\"  最大: {max(memory_usage):.1f}%\")\n        print(f\"  最小: {min(memory_usage):.1f}%\")\n        \n        # アラート統計\n        if self.alerts:\n            print(f\"\\n⚠️ アラート統計:\")\n            alert_types = {}\n            for alert in self.alerts:\n                alert_types[alert['type']] = alert_types.get(alert['type'], 0) + 1\n            \n            for alert_type, count in alert_types.items():\n                print(f\"  {alert_type}: {count}回\")\n        else:\n            print(f\"\\n✅ アラートなし\")\n    \n    def get_top_processes(self, limit: int = 5) -&gt; List[Dict]:\n        \"\"\"CPU/メモリ使用率上位プロセスを取得\"\"\"\n        processes = []\n        \n        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):\n            try:\n                processes.append(proc.info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                pass\n        \n        # CPU使用率でソート\n        processes.sort(key=lambda x: x['cpu_percent'] or 0, reverse=True)\n        \n        return processes[:limit]\n    \n    def display_top_processes(self):\n        \"\"\"上位プロセスを表示\"\"\"\n        print(f\"\\n🔝 CPU使用率上位プロセス:\")\n        top_processes = self.get_top_processes()\n        \n        for i, proc in enumerate(top_processes, 1):\n            cpu = proc['cpu_percent'] or 0\n            memory = proc['memory_percent'] or 0\n            print(f\"  {i}. {proc['name']} (PID: {proc['pid']})\")\n            print(f\"     CPU: {cpu:.1f}%, メモリ: {memory:.1f}%\")\n\n# システム監視デモ\ndef demo_system_monitor():\n    \"\"\"システム監視デモ\"\"\"\n    print(\"=== システム監視デモ ===\")\n    \n    monitor = SystemMonitor()\n    \n    # 単発監視\n    print(\"🔍 現在のシステム状態:\")\n    monitor.display_system_status()\n    \n    # 上位プロセス表示\n    monitor.display_top_processes()\n    \n    print(f\"\\n\" + \"=\"*50)\n    print(\"📈 継続監視のシミュレーション (15秒間、5秒間隔)\")\n    print(\"実際の環境では以下のコマンドで長期監視できます:\")\n    print(\"monitor.monitor_continuous(duration=300, interval=10)\")\n    \n    # 短時間の監視デモ\n    monitor.monitor_continuous(duration=15, interval=5)\n\ndemo_system_monitor()\n\nこの章では、Pythonを使って実際のビジネスや日常生活で役立つアプリケーションを構築する方法を学習しました。タスク管理、ファイル整理、Webスクレイピング、システム監視など、様々な用途に応用できる実践的なスキルを身につけることができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html",
    "href": "book/16-iot-connectivity.html",
    "title": "16  IoT接続とハードウェア制御",
    "section": "",
    "text": "16.1 IoT基礎とPython\nPythonを使用してIoTデバイスやハードウェアと連携し、実世界のデータを収集・制御する方法を学習します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#iot基礎とpython",
    "href": "book/16-iot-connectivity.html#iot基礎とpython",
    "title": "16  IoT接続とハードウェア制御",
    "section": "",
    "text": "16.1.1 IoTシステムの概要\n\nimport time\nimport random\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass SensorType(Enum):\n    \"\"\"センサータイプ\"\"\"\n    TEMPERATURE = \"温度\"\n    HUMIDITY = \"湿度\"\n    PRESSURE = \"気圧\"\n    LIGHT = \"光\"\n    MOTION = \"動作\"\n    SOUND = \"音\"\n    GAS = \"ガス\"\n\n@dataclass\nclass SensorReading:\n    \"\"\"センサー読み取り値\"\"\"\n    sensor_id: str\n    sensor_type: SensorType\n    value: float\n    unit: str\n    timestamp: datetime\n    location: str = \"\"\n    \n    def to_dict(self) -&gt; Dict:\n        return {\n            \"sensor_id\": self.sensor_id,\n            \"sensor_type\": self.sensor_type.value,\n            \"value\": self.value,\n            \"unit\": self.unit,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"location\": self.location\n        }\n\nclass IoTDevice:\n    \"\"\"IoTデバイス基底クラス\"\"\"\n    \n    def __init__(self, device_id: str, name: str, location: str = \"\"):\n        self.device_id = device_id\n        self.name = name\n        self.location = location\n        self.is_connected = False\n        self.last_seen = None\n        self.readings_history: List[SensorReading] = []\n    \n    def connect(self) -&gt; bool:\n        \"\"\"デバイスに接続\"\"\"\n        print(f\"🔌 デバイス接続中: {self.name} ({self.device_id})\")\n        # 実際の実装では、WiFi、Bluetooth、シリアル通信などを使用\n        self.is_connected = True\n        self.last_seen = datetime.now()\n        print(f\"✅ 接続成功: {self.name}\")\n        return True\n    \n    def disconnect(self):\n        \"\"\"デバイスから切断\"\"\"\n        print(f\"🔌 デバイス切断: {self.name}\")\n        self.is_connected = False\n    \n    def read_sensor(self, sensor_type: SensorType) -&gt; Optional[SensorReading]:\n        \"\"\"センサー値を読み取り\"\"\"\n        if not self.is_connected:\n            print(f\"❌ デバイス未接続: {self.name}\")\n            return None\n        \n        # センサー値のシミュレーション\n        value, unit = self._simulate_sensor_reading(sensor_type)\n        \n        reading = SensorReading(\n            sensor_id=f\"{self.device_id}_{sensor_type.name}\",\n            sensor_type=sensor_type,\n            value=value,\n            unit=unit,\n            timestamp=datetime.now(),\n            location=self.location\n        )\n        \n        self.readings_history.append(reading)\n        self.last_seen = datetime.now()\n        \n        print(f\"📊 {self.name}: {sensor_type.value} = {value}{unit}\")\n        return reading\n    \n    def _simulate_sensor_reading(self, sensor_type: SensorType) -&gt; tuple:\n        \"\"\"センサー読み取り値をシミュレート\"\"\"\n        if sensor_type == SensorType.TEMPERATURE:\n            return round(random.uniform(18.0, 30.0), 1), \"°C\"\n        elif sensor_type == SensorType.HUMIDITY:\n            return round(random.uniform(40.0, 80.0), 1), \"%\"\n        elif sensor_type == SensorType.PRESSURE:\n            return round(random.uniform(1000.0, 1030.0), 1), \"hPa\"\n        elif sensor_type == SensorType.LIGHT:\n            return round(random.uniform(0.0, 1000.0), 0), \"lux\"\n        elif sensor_type == SensorType.MOTION:\n            return random.choice([0, 1]), \"\"\n        elif sensor_type == SensorType.SOUND:\n            return round(random.uniform(30.0, 80.0), 1), \"dB\"\n        elif sensor_type == SensorType.GAS:\n            return round(random.uniform(0.0, 100.0), 1), \"ppm\"\n        else:\n            return 0.0, \"\"\n    \n    def get_status(self) -&gt; Dict:\n        \"\"\"デバイス状態を取得\"\"\"\n        return {\n            \"device_id\": self.device_id,\n            \"name\": self.name,\n            \"location\": self.location,\n            \"is_connected\": self.is_connected,\n            \"last_seen\": self.last_seen.isoformat() if self.last_seen else None,\n            \"total_readings\": len(self.readings_history)\n        }\n\n# 具体的なIoTデバイス\nclass WeatherStation(IoTDevice):\n    \"\"\"気象観測ステーション\"\"\"\n    \n    def __init__(self, device_id: str, location: str = \"\"):\n        super().__init__(device_id, \"気象観測ステーション\", location)\n        self.supported_sensors = [\n            SensorType.TEMPERATURE,\n            SensorType.HUMIDITY, \n            SensorType.PRESSURE\n        ]\n    \n    def read_all_sensors(self) -&gt; List[SensorReading]:\n        \"\"\"全センサーの値を読み取り\"\"\"\n        readings = []\n        for sensor_type in self.supported_sensors:\n            reading = self.read_sensor(sensor_type)\n            if reading:\n                readings.append(reading)\n        return readings\n    \n    def get_weather_summary(self) -&gt; Dict:\n        \"\"\"天気サマリーを取得\"\"\"\n        if not self.readings_history:\n            return {\"message\": \"データがありません\"}\n        \n        # 最新の読み取り値を取得\n        latest_readings = {}\n        for reading in reversed(self.readings_history):\n            if reading.sensor_type not in latest_readings:\n                latest_readings[reading.sensor_type] = reading\n            \n            # 全センサーの値が揃ったら終了\n            if len(latest_readings) == len(self.supported_sensors):\n                break\n        \n        summary = {\n            \"location\": self.location,\n            \"timestamp\": datetime.now().isoformat(),\n            \"readings\": {}\n        }\n        \n        for sensor_type, reading in latest_readings.items():\n            summary[\"readings\"][sensor_type.value] = {\n                \"value\": reading.value,\n                \"unit\": reading.unit\n            }\n        \n        return summary\n\nclass SmartHome(IoTDevice):\n    \"\"\"スマートホームデバイス\"\"\"\n    \n    def __init__(self, device_id: str, room: str = \"\"):\n        super().__init__(device_id, \"スマートホームハブ\", room)\n        self.room = room\n        self.devices = {}\n        self.automation_rules = []\n    \n    def add_device(self, device_name: str, device_type: str):\n        \"\"\"デバイスを追加\"\"\"\n        self.devices[device_name] = {\n            \"type\": device_type,\n            \"status\": \"off\",\n            \"last_updated\": datetime.now()\n        }\n        print(f\"🏠 デバイス追加: {device_name} ({device_type}) @ {self.room}\")\n    \n    def control_device(self, device_name: str, command: str) -&gt; bool:\n        \"\"\"デバイスを制御\"\"\"\n        if device_name not in self.devices:\n            print(f\"❌ デバイスが見つかりません: {device_name}\")\n            return False\n        \n        valid_commands = [\"on\", \"off\", \"toggle\", \"dim\", \"bright\"]\n        if command not in valid_commands:\n            print(f\"❌ 無効なコマンド: {command}\")\n            return False\n        \n        device = self.devices[device_name]\n        \n        if command == \"on\":\n            device[\"status\"] = \"on\"\n        elif command == \"off\":\n            device[\"status\"] = \"off\"\n        elif command == \"toggle\":\n            device[\"status\"] = \"on\" if device[\"status\"] == \"off\" else \"off\"\n        elif command in [\"dim\", \"bright\"]:\n            device[\"status\"] = command\n        \n        device[\"last_updated\"] = datetime.now()\n        \n        print(f\"🎛️ {device_name} を {command} に設定しました\")\n        return True\n    \n    def add_automation_rule(self, condition: str, action: str):\n        \"\"\"自動化ルールを追加\"\"\"\n        rule = {\n            \"id\": len(self.automation_rules) + 1,\n            \"condition\": condition,\n            \"action\": action,\n            \"created_at\": datetime.now(),\n            \"triggered_count\": 0\n        }\n        self.automation_rules.append(rule)\n        print(f\"🤖 自動化ルール追加: {condition} → {action}\")\n    \n    def check_automation(self, sensor_reading: SensorReading):\n        \"\"\"自動化ルールをチェック\"\"\"\n        for rule in self.automation_rules:\n            if self._evaluate_condition(rule[\"condition\"], sensor_reading):\n                self._execute_action(rule[\"action\"])\n                rule[\"triggered_count\"] += 1\n                print(f\"🤖 自動化実行: {rule['condition']} → {rule['action']}\")\n    \n    def _evaluate_condition(self, condition: str, reading: SensorReading) -&gt; bool:\n        \"\"\"条件を評価（簡略化）\"\"\"\n        # 実際の実装ではより複雑な条件解析が必要\n        if \"温度\" in condition and reading.sensor_type == SensorType.TEMPERATURE:\n            if \"25度以上\" in condition:\n                return reading.value &gt;= 25.0\n            elif \"20度以下\" in condition:\n                return reading.value &lt;= 20.0\n        elif \"湿度\" in condition and reading.sensor_type == SensorType.HUMIDITY:\n            if \"70%以上\" in condition:\n                return reading.value &gt;= 70.0\n        return False\n    \n    def _execute_action(self, action: str):\n        \"\"\"アクションを実行（簡略化）\"\"\"\n        if \"エアコン\" in action:\n            if \"on\" in action:\n                self.control_device(\"エアコン\", \"on\")\n            elif \"off\" in action:\n                self.control_device(\"エアコン\", \"off\")\n        elif \"照明\" in action:\n            if \"on\" in action:\n                self.control_device(\"照明\", \"on\")\n            elif \"off\" in action:\n                self.control_device(\"照明\", \"off\")\n\n# IoTデバイス管理システム\nclass IoTManager:\n    \"\"\"IoTデバイス管理システム\"\"\"\n    \n    def __init__(self):\n        self.devices: Dict[str, IoTDevice] = {}\n        self.data_storage: List[SensorReading] = []\n        self.alerts = []\n    \n    def register_device(self, device: IoTDevice):\n        \"\"\"デバイスを登録\"\"\"\n        self.devices[device.device_id] = device\n        print(f\"📱 デバイス登録: {device.name} ({device.device_id})\")\n    \n    def connect_all_devices(self):\n        \"\"\"全デバイスに接続\"\"\"\n        print(\"🔌 全デバイス接続中...\")\n        for device in self.devices.values():\n            device.connect()\n        print(\"✅ 全デバイス接続完了\")\n    \n    def collect_data_from_all(self):\n        \"\"\"全デバイスからデータ収集\"\"\"\n        print(\"📊 データ収集開始...\")\n        \n        for device in self.devices.values():\n            if device.is_connected:\n                if isinstance(device, WeatherStation):\n                    readings = device.read_all_sensors()\n                    self.data_storage.extend(readings)\n                else:\n                    # 基本センサー読み取り\n                    reading = device.read_sensor(SensorType.TEMPERATURE)\n                    if reading:\n                        self.data_storage.append(reading)\n        \n        print(f\"📈 データ収集完了: {len(self.data_storage)}件\")\n    \n    def get_device_summary(self) -&gt; Dict:\n        \"\"\"デバイスサマリーを取得\"\"\"\n        connected = sum(1 for d in self.devices.values() if d.is_connected)\n        total = len(self.devices)\n        \n        return {\n            \"total_devices\": total,\n            \"connected_devices\": connected,\n            \"total_readings\": len(self.data_storage),\n            \"device_types\": list(set(type(d).__name__ for d in self.devices.values()))\n        }\n    \n    def export_data(self, filename: str):\n        \"\"\"データをJSONファイルにエクスポート\"\"\"\n        data = [reading.to_dict() for reading in self.data_storage]\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n        print(f\"💾 データエクスポート完了: {filename}\")\n\n# IoTシステムデモ\ndef demo_iot_system():\n    \"\"\"IoTシステムデモ\"\"\"\n    print(\"=== IoTシステムデモ ===\")\n    \n    # IoT管理システムを作成\n    iot_manager = IoTManager()\n    \n    # 気象観測ステーションを作成\n    weather_station = WeatherStation(\"WS001\", \"屋上\")\n    iot_manager.register_device(weather_station)\n    \n    # スマートホームハブを作成\n    smart_home = SmartHome(\"SH001\", \"リビング\")\n    smart_home.add_device(\"エアコン\", \"空調\")\n    smart_home.add_device(\"照明\", \"照明\")\n    smart_home.add_device(\"扇風機\", \"扇風機\")\n    iot_manager.register_device(smart_home)\n    \n    # 自動化ルールを追加\n    smart_home.add_automation_rule(\"温度25度以上\", \"エアコンon\")\n    smart_home.add_automation_rule(\"湿度70%以上\", \"扇風機on\")\n    \n    # 全デバイスに接続\n    iot_manager.connect_all_devices()\n    \n    print(f\"\\n\" + \"=\"*50)\n    print(\"📊 センサーデータ収集シミュレーション\")\n    \n    # データ収集を複数回実行\n    for cycle in range(3):\n        print(f\"\\n--- サイクル {cycle + 1} ---\")\n        \n        # 気象データを読み取り\n        weather_readings = weather_station.read_all_sensors()\n        \n        # スマートホーム制御\n        for reading in weather_readings:\n            smart_home.check_automation(reading)\n        \n        # データをマネージャーに保存\n        iot_manager.data_storage.extend(weather_readings)\n        \n        # 天気サマリーを表示\n        weather_summary = weather_station.get_weather_summary()\n        print(f\"🌤️ 気象情報: {weather_summary}\")\n        \n        time.sleep(1)  # シミュレーション用の待機\n    \n    # システムサマリー\n    print(f\"\\n📋 システムサマリー:\")\n    summary = iot_manager.get_device_summary()\n    for key, value in summary.items():\n        print(f\"  {key}: {value}\")\n\ndemo_iot_system()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#シリアル通信とセンサー制御",
    "href": "book/16-iot-connectivity.html#シリアル通信とセンサー制御",
    "title": "16  IoT接続とハードウェア制御",
    "section": "16.2 シリアル通信とセンサー制御",
    "text": "16.2 シリアル通信とセンサー制御\n\n16.2.1 Arduino・Raspberry Pi連携\n\nimport serial\nimport time\nimport threading\nfrom queue import Queue\nfrom typing import Callable, Optional\n\nclass SerialCommunicator:\n    \"\"\"シリアル通信クラス\"\"\"\n    \n    def __init__(self, port: str = \"COM3\", baudrate: int = 9600):\n        self.port = port\n        self.baudrate = baudrate\n        self.serial_connection: Optional[serial.Serial] = None\n        self.is_connected = False\n        self.read_thread: Optional[threading.Thread] = None\n        self.message_queue = Queue()\n        self.callbacks = []\n    \n    def connect(self) -&gt; bool:\n        \"\"\"シリアルポートに接続\"\"\"\n        try:\n            print(f\"🔌 シリアル接続中: {self.port} @ {self.baudrate}\")\n            \n            # 実際の環境では以下のコードを使用\n            # self.serial_connection = serial.Serial(self.port, self.baudrate, timeout=1)\n            # self.is_connected = True\n            \n            # デモ用のシミュレーション\n            self.is_connected = True\n            print(f\"✅ シリアル接続成功\")\n            \n            # 読み取りスレッドを開始\n            self.start_reading_thread()\n            return True\n            \n        except Exception as e:\n            print(f\"❌ シリアル接続エラー: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"シリアル接続を切断\"\"\"\n        self.is_connected = False\n        \n        if self.read_thread and self.read_thread.is_alive():\n            self.read_thread.join(timeout=2)\n        \n        if self.serial_connection:\n            self.serial_connection.close()\n        \n        print(\"🔌 シリアル接続を切断しました\")\n    \n    def send_command(self, command: str) -&gt; bool:\n        \"\"\"コマンドを送信\"\"\"\n        if not self.is_connected:\n            print(\"❌ シリアル未接続\")\n            return False\n        \n        try:\n            # 実際の環境では以下のコードを使用\n            # self.serial_connection.write((command + '\\n').encode())\n            \n            # デモ用のシミュレーション\n            print(f\"📤 送信: {command}\")\n            \n            # 模擬応答を生成\n            self._simulate_response(command)\n            return True\n            \n        except Exception as e:\n            print(f\"❌ 送信エラー: {e}\")\n            return False\n    \n    def _simulate_response(self, command: str):\n        \"\"\"模擬応答を生成\"\"\"\n        if command.startswith(\"READ_SENSORS\"):\n            response = \"TEMP:25.3,HUMID:65.2\"\n        elif command.startswith(\"LED_ON\"):\n            response = \"LED:ON\"\n        elif command.startswith(\"LED_OFF\"):\n            response = \"LED:OFF\"\n        elif command.startswith(\"MOTOR\"):\n            response = \"MOTOR:RUNNING\"\n        else:\n            response = \"OK\"\n        \n        # 応答をキューに追加\n        self.message_queue.put(response)\n        \n        # コールバック関数を呼び出し\n        for callback in self.callbacks:\n            callback(response)\n    \n    def start_reading_thread(self):\n        \"\"\"読み取りスレッドを開始\"\"\"\n        self.read_thread = threading.Thread(target=self._read_loop, daemon=True)\n        self.read_thread.start()\n    \n    def _read_loop(self):\n        \"\"\"読み取りループ\"\"\"\n        while self.is_connected:\n            try:\n                # 実際の環境では以下のコードを使用\n                # if self.serial_connection.in_waiting &gt; 0:\n                #     data = self.serial_connection.readline().decode().strip()\n                #     self.message_queue.put(data)\n                \n                # デモ用: 定期的にダミーデータを生成\n                time.sleep(2)\n                if self.is_connected:\n                    dummy_data = f\"SENSOR_DATA:TEMP:{20 + time.time() % 10:.1f}\"\n                    self.message_queue.put(dummy_data)\n                \n            except Exception as e:\n                print(f\"❌ 読み取りエラー: {e}\")\n                break\n    \n    def add_callback(self, callback: Callable[[str], None]):\n        \"\"\"メッセージ受信時のコールバック関数を追加\"\"\"\n        self.callbacks.append(callback)\n    \n    def get_messages(self) -&gt; list:\n        \"\"\"受信したメッセージを取得\"\"\"\n        messages = []\n        while not self.message_queue.empty():\n            messages.append(self.message_queue.get())\n        return messages\n\nclass ArduinoController:\n    \"\"\"Arduino制御クラス\"\"\"\n    \n    def __init__(self, port: str = \"COM3\"):\n        self.communicator = SerialCommunicator(port)\n        self.sensor_data = {}\n        self.led_status = False\n        \n        # コールバック関数を設定\n        self.communicator.add_callback(self._handle_response)\n    \n    def connect(self) -&gt; bool:\n        \"\"\"Arduinoに接続\"\"\"\n        return self.communicator.connect()\n    \n    def disconnect(self):\n        \"\"\"Arduino接続を切断\"\"\"\n        self.communicator.disconnect()\n    \n    def _handle_response(self, response: str):\n        \"\"\"Arduino応答を処理\"\"\"\n        print(f\"📥 受信: {response}\")\n        \n        if response.startswith(\"TEMP:\"):\n            # 温度データを解析\n            parts = response.split(\",\")\n            for part in parts:\n                if \"TEMP:\" in part:\n                    temp = float(part.split(\":\")[1])\n                    self.sensor_data[\"temperature\"] = temp\n                elif \"HUMID:\" in part:\n                    humid = float(part.split(\":\")[1])\n                    self.sensor_data[\"humidity\"] = humid\n    \n    def read_sensors(self) -&gt; Dict:\n        \"\"\"センサー値を読み取り\"\"\"\n        self.communicator.send_command(\"READ_SENSORS\")\n        time.sleep(0.1)  # 応答待機\n        return self.sensor_data.copy()\n    \n    def control_led(self, state: bool) -&gt; bool:\n        \"\"\"LEDを制御\"\"\"\n        command = \"LED_ON\" if state else \"LED_OFF\"\n        success = self.communicator.send_command(command)\n        \n        if success:\n            self.led_status = state\n            print(f\"💡 LED: {'点灯' if state else '消灯'}\")\n        \n        return success\n    \n    def control_motor(self, speed: int, direction: str = \"forward\") -&gt; bool:\n        \"\"\"モーターを制御\"\"\"\n        command = f\"MOTOR:{direction}:{speed}\"\n        success = self.communicator.send_command(command)\n        \n        if success:\n            print(f\"⚙️ モーター: {direction} 速度{speed}\")\n        \n        return success\n    \n    def get_status(self) -&gt; Dict:\n        \"\"\"デバイス状態を取得\"\"\"\n        return {\n            \"connected\": self.communicator.is_connected,\n            \"sensor_data\": self.sensor_data,\n            \"led_status\": self.led_status\n        }\n\n# Raspberry Pi GPIO制御（シミュレーション）\nclass RaspberryPiController:\n    \"\"\"Raspberry Pi GPIO制御クラス\"\"\"\n    \n    def __init__(self):\n        self.gpio_states = {}\n        self.pwm_channels = {}\n        print(\"🥧 Raspberry Pi制御器を初期化しました\")\n    \n    def setup_pin(self, pin: int, mode: str):\n        \"\"\"ピンを設定\"\"\"\n        self.gpio_states[pin] = {\"mode\": mode, \"value\": 0}\n        print(f\"📌 GPIO{pin}を{mode}モードに設定\")\n    \n    def digital_write(self, pin: int, value: int):\n        \"\"\"デジタル出力\"\"\"\n        if pin in self.gpio_states:\n            self.gpio_states[pin][\"value\"] = value\n            print(f\"📌 GPIO{pin} = {value}\")\n        else:\n            print(f\"❌ GPIO{pin}が設定されていません\")\n    \n    def digital_read(self, pin: int) -&gt; int:\n        \"\"\"デジタル入力読み取り\"\"\"\n        if pin in self.gpio_states:\n            # シミュレーション: ランダム値\n            value = random.choice([0, 1])\n            print(f\"📌 GPIO{pin}読み取り: {value}\")\n            return value\n        return 0\n    \n    def setup_pwm(self, pin: int, frequency: int):\n        \"\"\"PWM設定\"\"\"\n        self.pwm_channels[pin] = {\"frequency\": frequency, \"duty_cycle\": 0}\n        print(f\"🌊 GPIO{pin}をPWM {frequency}Hzに設定\")\n    \n    def set_pwm_duty_cycle(self, pin: int, duty_cycle: float):\n        \"\"\"PWMデューティサイクル設定\"\"\"\n        if pin in self.pwm_channels:\n            self.pwm_channels[pin][\"duty_cycle\"] = duty_cycle\n            print(f\"🌊 GPIO{pin} PWM: {duty_cycle}%\")\n        else:\n            print(f\"❌ GPIO{pin}のPWMが設定されていません\")\n\n# ハードウェア制御デモ\ndef demo_hardware_control():\n    \"\"\"ハードウェア制御デモ\"\"\"\n    print(\"=== ハードウェア制御デモ ===\")\n    \n    # Arduino制御デモ\n    print(\"🤖 Arduino制御デモ\")\n    arduino = ArduinoController(\"COM3\")\n    \n    if arduino.connect():\n        print(\"\\n📊 センサー読み取りテスト:\")\n        for i in range(3):\n            sensors = arduino.read_sensors()\n            print(f\"  サイクル {i+1}: {sensors}\")\n            time.sleep(1)\n        \n        print(\"\\n💡 LED制御テスト:\")\n        arduino.control_led(True)\n        time.sleep(1)\n        arduino.control_led(False)\n        \n        print(\"\\n⚙️ モーター制御テスト:\")\n        arduino.control_motor(100, \"forward\")\n        time.sleep(1)\n        arduino.control_motor(50, \"backward\")\n        \n        # 状態確認\n        status = arduino.get_status()\n        print(f\"\\n📋 Arduino状態: {status}\")\n        \n        arduino.disconnect()\n    \n    print(f\"\\n\" + \"=\"*50)\n    \n    # Raspberry Pi制御デモ\n    print(\"🥧 Raspberry Pi GPIO制御デモ\")\n    rpi = RaspberryPiController()\n    \n    # GPIO設定\n    rpi.setup_pin(18, \"OUTPUT\")  # LED用\n    rpi.setup_pin(24, \"INPUT\")   # センサー用\n    rpi.setup_pin(12, \"PWM\")     # PWM用\n    \n    # デジタル出力テスト\n    print(\"\\n💡 デジタル出力テスト:\")\n    rpi.digital_write(18, 1)\n    time.sleep(0.5)\n    rpi.digital_write(18, 0)\n    \n    # デジタル入力テスト\n    print(\"\\n📥 デジタル入力テスト:\")\n    for i in range(3):\n        value = rpi.digital_read(24)\n        print(f\"  読み取り {i+1}: {value}\")\n    \n    # PWM制御テスト\n    print(\"\\n🌊 PWM制御テスト:\")\n    rpi.setup_pwm(12, 1000)  # 1kHz\n    for duty in [0, 25, 50, 75, 100]:\n        rpi.set_pwm_duty_cycle(12, duty)\n        time.sleep(0.3)\n\ndemo_hardware_control()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#ネットワーク通信とクラウド連携",
    "href": "book/16-iot-connectivity.html#ネットワーク通信とクラウド連携",
    "title": "16  IoT接続とハードウェア制御",
    "section": "16.3 ネットワーク通信とクラウド連携",
    "text": "16.3 ネットワーク通信とクラウド連携\n\n16.3.1 MQTT通信とクラウドサービス\n\nimport json\nimport time\nimport threading\nfrom datetime import datetime\nfrom typing import Dict, List, Callable, Optional\nimport hashlib\n\nclass MQTTClient:\n    \"\"\"MQTTクライアント（シミュレーション）\"\"\"\n    \n    def __init__(self, broker_host: str = \"localhost\", port: int = 1883):\n        self.broker_host = broker_host\n        self.port = port\n        self.is_connected = False\n        self.subscriptions = {}\n        self.message_handlers = {}\n        self.published_messages = []\n    \n    def connect(self, client_id: str, username: str = None, password: str = None) -&gt; bool:\n        \"\"\"MQTTブローカーに接続\"\"\"\n        try:\n            print(f\"🌐 MQTT接続中: {client_id} @ {self.broker_host}:{self.port}\")\n            \n            # 実際の環境では以下のライブラリを使用:\n            # import paho.mqtt.client as mqtt\n            # self.client = mqtt.Client(client_id)\n            # if username and password:\n            #     self.client.username_pw_set(username, password)\n            # self.client.connect(self.broker_host, self.port, 60)\n            \n            # シミュレーション\n            self.client_id = client_id\n            self.is_connected = True\n            print(f\"✅ MQTT接続成功: {client_id}\")\n            return True\n            \n        except Exception as e:\n            print(f\"❌ MQTT接続エラー: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"MQTT接続を切断\"\"\"\n        self.is_connected = False\n        print(\"🌐 MQTT接続を切断しました\")\n    \n    def subscribe(self, topic: str, callback: Callable[[str, str], None]):\n        \"\"\"トピックをサブスクライブ\"\"\"\n        if not self.is_connected:\n            print(\"❌ MQTT未接続\")\n            return False\n        \n        self.subscriptions[topic] = True\n        self.message_handlers[topic] = callback\n        print(f\"📡 サブスクライブ: {topic}\")\n        return True\n    \n    def publish(self, topic: str, payload: str, qos: int = 0) -&gt; bool:\n        \"\"\"メッセージを発行\"\"\"\n        if not self.is_connected:\n            print(\"❌ MQTT未接続\")\n            return False\n        \n        message = {\n            \"topic\": topic,\n            \"payload\": payload,\n            \"qos\": qos,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        self.published_messages.append(message)\n        print(f\"📤 発行: {topic} -&gt; {payload}\")\n        \n        # シミュレーション: 自分のサブスクリプションをチェック\n        self._simulate_message_delivery(topic, payload)\n        return True\n    \n    def _simulate_message_delivery(self, topic: str, payload: str):\n        \"\"\"メッセージ配信をシミュレート\"\"\"\n        for subscribed_topic, callback in self.message_handlers.items():\n            if self._topic_matches(subscribed_topic, topic):\n                threading.Thread(\n                    target=callback,\n                    args=(topic, payload),\n                    daemon=True\n                ).start()\n    \n    def _topic_matches(self, pattern: str, topic: str) -&gt; bool:\n        \"\"\"トピックパターンマッチング\"\"\"\n        if pattern == topic:\n            return True\n        if pattern.endswith(\"#\"):\n            prefix = pattern[:-1]\n            return topic.startswith(prefix)\n        if \"+\" in pattern:\n            # 簡略化したワイルドカード処理\n            return True\n        return False\n\nclass IoTCloudPlatform:\n    \"\"\"IoTクラウドプラットフォーム\"\"\"\n    \n    def __init__(self, platform_name: str = \"IoT Platform\"):\n        self.platform_name = platform_name\n        self.mqtt_client = MQTTClient()\n        self.devices = {}\n        self.telemetry_data = []\n        self.alerts = []\n        self.is_running = False\n    \n    def connect(self, client_id: str) -&gt; bool:\n        \"\"\"クラウドプラットフォームに接続\"\"\"\n        success = self.mqtt_client.connect(client_id)\n        if success:\n            self._setup_subscriptions()\n        return success\n    \n    def _setup_subscriptions(self):\n        \"\"\"サブスクリプションを設定\"\"\"\n        # デバイステレメトリ\n        self.mqtt_client.subscribe(\"devices/+/telemetry\", self._handle_telemetry)\n        \n        # デバイスステータス\n        self.mqtt_client.subscribe(\"devices/+/status\", self._handle_device_status)\n        \n        # アラート\n        self.mqtt_client.subscribe(\"devices/+/alert\", self._handle_alert)\n    \n    def _handle_telemetry(self, topic: str, payload: str):\n        \"\"\"テレメトリデータを処理\"\"\"\n        try:\n            device_id = topic.split('/')[1]\n            data = json.loads(payload)\n            \n            telemetry_record = {\n                \"device_id\": device_id,\n                \"data\": data,\n                \"timestamp\": datetime.now().isoformat(),\n                \"topic\": topic\n            }\n            \n            self.telemetry_data.append(telemetry_record)\n            print(f\"📊 テレメトリ受信: {device_id} -&gt; {data}\")\n            \n            # データ分析とアラート生成\n            self._analyze_telemetry(telemetry_record)\n            \n        except Exception as e:\n            print(f\"❌ テレメトリ処理エラー: {e}\")\n    \n    def _handle_device_status(self, topic: str, payload: str):\n        \"\"\"デバイスステータスを処理\"\"\"\n        device_id = topic.split('/')[1]\n        status = payload\n        \n        if device_id not in self.devices:\n            self.devices[device_id] = {}\n        \n        self.devices[device_id][\"status\"] = status\n        self.devices[device_id][\"last_seen\"] = datetime.now().isoformat()\n        \n        print(f\"📱 デバイスステータス: {device_id} = {status}\")\n    \n    def _handle_alert(self, topic: str, payload: str):\n        \"\"\"アラートを処理\"\"\"\n        try:\n            device_id = topic.split('/')[1]\n            alert_data = json.loads(payload)\n            \n            alert = {\n                \"device_id\": device_id,\n                \"alert_data\": alert_data,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n            self.alerts.append(alert)\n            print(f\"🚨 アラート: {device_id} -&gt; {alert_data}\")\n            \n        except Exception as e:\n            print(f\"❌ アラート処理エラー: {e}\")\n    \n    def _analyze_telemetry(self, record: Dict):\n        \"\"\"テレメトリデータを分析\"\"\"\n        data = record[\"data\"]\n        device_id = record[\"device_id\"]\n        \n        # 温度アラート\n        if \"temperature\" in data:\n            temp = data[\"temperature\"]\n            if temp &gt; 30:\n                self._generate_alert(device_id, \"high_temperature\", \n                                   f\"高温警告: {temp}°C\")\n            elif temp &lt; 10:\n                self._generate_alert(device_id, \"low_temperature\", \n                                   f\"低温警告: {temp}°C\")\n        \n        # 湿度アラート\n        if \"humidity\" in data:\n            humidity = data[\"humidity\"]\n            if humidity &gt; 80:\n                self._generate_alert(device_id, \"high_humidity\", \n                                   f\"高湿度警告: {humidity}%\")\n    \n    def _generate_alert(self, device_id: str, alert_type: str, message: str):\n        \"\"\"アラートを生成\"\"\"\n        alert_payload = {\n            \"type\": alert_type,\n            \"message\": message,\n            \"severity\": \"warning\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        topic = f\"alerts/{device_id}\"\n        self.mqtt_client.publish(topic, json.dumps(alert_payload))\n    \n    def send_command(self, device_id: str, command: Dict) -&gt; bool:\n        \"\"\"デバイスにコマンドを送信\"\"\"\n        topic = f\"devices/{device_id}/commands\"\n        payload = json.dumps(command)\n        return self.mqtt_client.publish(topic, payload)\n    \n    def get_device_data(self, device_id: str, hours: int = 24) -&gt; List[Dict]:\n        \"\"\"デバイスデータを取得\"\"\"\n        return [record for record in self.telemetry_data \n                if record[\"device_id\"] == device_id]\n    \n    def get_platform_statistics(self) -&gt; Dict:\n        \"\"\"プラットフォーム統計を取得\"\"\"\n        return {\n            \"total_devices\": len(self.devices),\n            \"active_devices\": len([d for d in self.devices.values() \n                                 if d.get(\"status\") == \"online\"]),\n            \"total_telemetry_records\": len(self.telemetry_data),\n            \"total_alerts\": len(self.alerts),\n            \"recent_alerts\": len([a for a in self.alerts \n                                if (datetime.now() - datetime.fromisoformat(a[\"timestamp\"])).seconds &lt; 3600])\n        }\n\n# IoT仮想デバイス\nclass VirtualIoTDevice:\n    \"\"\"仮想IoTデバイス\"\"\"\n    \n    def __init__(self, device_id: str, device_type: str):\n        self.device_id = device_id\n        self.device_type = device_type\n        self.mqtt_client = MQTTClient()\n        self.is_running = False\n        self.telemetry_thread = None\n    \n    def connect_to_platform(self) -&gt; bool:\n        \"\"\"プラットフォームに接続\"\"\"\n        success = self.mqtt_client.connect(f\"device_{self.device_id}\")\n        if success:\n            self._setup_command_subscription()\n            self._send_status(\"online\")\n        return success\n    \n    def _setup_command_subscription(self):\n        \"\"\"コマンドサブスクリプションを設定\"\"\"\n        topic = f\"devices/{self.device_id}/commands\"\n        self.mqtt_client.subscribe(topic, self._handle_command)\n    \n    def _handle_command(self, topic: str, payload: str):\n        \"\"\"コマンドを処理\"\"\"\n        try:\n            command = json.loads(payload)\n            print(f\"📥 {self.device_id}: コマンド受信 -&gt; {command}\")\n            \n            # コマンド実行シミュレーション\n            if command.get(\"action\") == \"reboot\":\n                print(f\"🔄 {self.device_id}: 再起動中...\")\n            elif command.get(\"action\") == \"update_config\":\n                print(f\"⚙️ {self.device_id}: 設定更新中...\")\n            \n        except Exception as e:\n            print(f\"❌ コマンド処理エラー: {e}\")\n    \n    def start_telemetry(self, interval: int = 5):\n        \"\"\"テレメトリ送信を開始\"\"\"\n        self.is_running = True\n        self.telemetry_thread = threading.Thread(\n            target=self._telemetry_loop,\n            args=(interval,),\n            daemon=True\n        )\n        self.telemetry_thread.start()\n        print(f\"📊 {self.device_id}: テレメトリ送信開始 ({interval}秒間隔)\")\n    \n    def stop_telemetry(self):\n        \"\"\"テレメトリ送信を停止\"\"\"\n        self.is_running = False\n        self._send_status(\"offline\")\n        print(f\"📊 {self.device_id}: テレメトリ送信停止\")\n    \n    def _telemetry_loop(self, interval: int):\n        \"\"\"テレメトリ送信ループ\"\"\"\n        while self.is_running:\n            telemetry_data = self._generate_telemetry()\n            topic = f\"devices/{self.device_id}/telemetry\"\n            payload = json.dumps(telemetry_data)\n            \n            self.mqtt_client.publish(topic, payload)\n            time.sleep(interval)\n    \n    def _generate_telemetry(self) -&gt; Dict:\n        \"\"\"テレメトリデータを生成\"\"\"\n        base_data = {\n            \"device_id\": self.device_id,\n            \"device_type\": self.device_type,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        if self.device_type == \"weather_station\":\n            base_data.update({\n                \"temperature\": round(random.uniform(15, 35), 1),\n                \"humidity\": round(random.uniform(30, 90), 1),\n                \"pressure\": round(random.uniform(1000, 1030), 1)\n            })\n        elif self.device_type == \"air_quality\":\n            base_data.update({\n                \"pm25\": round(random.uniform(10, 100), 1),\n                \"co2\": round(random.uniform(400, 1000), 0),\n                \"temperature\": round(random.uniform(18, 28), 1)\n            })\n        \n        return base_data\n    \n    def _send_status(self, status: str):\n        \"\"\"ステータスを送信\"\"\"\n        topic = f\"devices/{self.device_id}/status\"\n        self.mqtt_client.publish(topic, status)\n\n# クラウド連携デモ\ndef demo_cloud_connectivity():\n    \"\"\"クラウド連携デモ\"\"\"\n    print(\"=== IoTクラウド連携デモ ===\")\n    \n    # クラウドプラットフォームを起動\n    platform = IoTCloudPlatform(\"スマートシティプラットフォーム\")\n    platform.connect(\"cloud_platform\")\n    \n    print(\"\\n🌐 仮想IoTデバイス作成・接続中...\")\n    \n    # 仮想デバイスを作成\n    weather_device = VirtualIoTDevice(\"WS001\", \"weather_station\")\n    air_quality_device = VirtualIoTDevice(\"AQ001\", \"air_quality\")\n    \n    # プラットフォームに接続\n    weather_device.connect_to_platform()\n    air_quality_device.connect_to_platform()\n    \n    # テレメトリ送信を開始\n    weather_device.start_telemetry(interval=3)\n    air_quality_device.start_telemetry(interval=4)\n    \n    print(\"\\n📊 データ収集中...\")\n    time.sleep(15)  # 15秒間データ収集\n    \n    # デバイスにコマンドを送信\n    print(\"\\n📤 デバイス制御コマンド送信...\")\n    platform.send_command(\"WS001\", {\"action\": \"reboot\", \"reason\": \"scheduled_maintenance\"})\n    platform.send_command(\"AQ001\", {\"action\": \"update_config\", \"config\": {\"sample_rate\": 60}})\n    \n    time.sleep(2)\n    \n    # 統計情報を表示\n    print(\"\\n📈 プラットフォーム統計:\")\n    stats = platform.get_platform_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # デバイス別データサマリー\n    print(\"\\n📊 デバイス別データサマリー:\")\n    for device_id in [\"WS001\", \"AQ001\"]:\n        device_data = platform.get_device_data(device_id)\n        if device_data:\n            latest = device_data[-1][\"data\"]\n            print(f\"  {device_id}: {latest}\")\n    \n    # テレメトリ送信を停止\n    weather_device.stop_telemetry()\n    air_quality_device.stop_telemetry()\n    \n    platform.mqtt_client.disconnect()\n    print(\"\\n✅ デモ完了\")\n\ndemo_cloud_connectivity()\n\nこの章では、PythonによるIoT開発の基本から実践的な応用まで学習しました。センサーデータの収集、ハードウェア制御、ネットワーク通信、クラウド連携など、IoTシステム開発に必要な技術を総合的に習得することができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html",
    "href": "book/99-self-review-1.html",
    "title": "17  自己評価: Python の基礎",
    "section": "",
    "text": "17.1 📝 学習内容の復習\nこの章では、これまで学習した Python の基礎概念を復習し、理解度を確認します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#学習内容の復習",
    "href": "book/99-self-review-1.html#学習内容の復習",
    "title": "17  自己評価: Python の基礎",
    "section": "",
    "text": "17.1.1 1. 環境構築とツール\n\nuv パッケージマネージャーの使用\nGit と GitHub でのバージョン管理\nVS Code での開発環境設定\n\n\n\n17.1.2 2. Python の基本構文\n\n変数と代入\nデータ型（文字列、数値、ブール値）\nインデントによるコードブロック\n\n\n\n17.1.3 3. データ型とコレクション\n\nリスト: 順序付きの要素のコレクション\n辞書: キーと値のペア\nセット: 重複のない要素のコレクション\nタプル: 不変の順序付きコレクション\n\n\n\n17.1.4 4. 制御フロー\n\n条件文: if、elif、else\nループ: for、while\nループ制御: break、continue\n\n\n\n17.1.5 5. 関数\n\n関数の定義と呼び出し\n引数とパラメータ\n戻り値\nスコープ\n\n\n\n17.1.6 6. エラー処理\n\ntry-except 文\n異なる例外の処理\nfinally ブロック\n\n\n\n17.1.7 7. モジュールとパッケージ\n\nモジュールのインポート\n標準ライブラリの使用\nカスタムモジュールの作成",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#理解度チェック問題",
    "href": "book/99-self-review-1.html#理解度チェック問題",
    "title": "17  自己評価: Python の基礎",
    "section": "17.2 🧪 理解度チェック問題",
    "text": "17.2 🧪 理解度チェック問題\n\n17.2.1 問題 1: 基本的なデータ操作\n\n# 課題: 学生の成績管理システム\nstudents = [\n    {\"名前\": \"田中太郎\", \"数学\": 85, \"英語\": 92, \"理科\": 78},\n    {\"名前\": \"佐藤花子\", \"数学\": 93, \"英語\": 87, \"理科\": 95},\n    {\"名前\": \"鈴木次郎\", \"数学\": 76, \"英語\": 84, \"理科\": 89}\n]\n\n# 1. 各学生の平均点を計算\nprint(\"=== 学生の平均点 ===\")\nfor student in students:\n    name = student[\"名前\"]\n    scores = [student[\"数学\"], student[\"英語\"], student[\"理科\"]]\n    average = sum(scores) / len(scores)\n    print(f\"{name}: {average:.1f}点\")\n\n# 2. 科目別の平均点を計算\nsubjects = [\"数学\", \"英語\", \"理科\"]\nprint(\"\\n=== 科目別平均点 ===\")\nfor subject in subjects:\n    total = sum(student[subject] for student in students)\n    average = total / len(students)\n    print(f\"{subject}: {average:.1f}点\")\n\n# 3. 最高点を取った学生を見つける\nprint(\"\\n=== 各科目の最高点 ===\")\nfor subject in subjects:\n    max_score = 0\n    top_student = \"\"\n    for student in students:\n        if student[subject] &gt; max_score:\n            max_score = student[subject]\n            top_student = student[\"名前\"]\n    print(f\"{subject}: {top_student} ({max_score}点)\")\n\n\n\n17.2.2 問題 2: 関数とエラー処理\n\ndef calculate_bmi(weight, height):\n    \"\"\"BMI (Body Mass Index) を計算する関数\"\"\"\n    try:\n        # BMI = 体重(kg) / 身長(m)^2\n        bmi = weight / (height ** 2)\n        return round(bmi, 2)\n    except ZeroDivisionError:\n        return \"エラー: 身長に0は指定できません\"\n    except TypeError:\n        return \"エラー: 数値を入力してください\"\n\ndef get_bmi_category(bmi):\n    \"\"\"BMI値から体型カテゴリを判定\"\"\"\n    if isinstance(bmi, str):  # エラーメッセージの場合\n        return bmi\n    \n    if bmi &lt; 18.5:\n        return \"やせ型\"\n    elif bmi &lt; 25:\n        return \"標準\"\n    elif bmi &lt; 30:\n        return \"肥満度1\"\n    else:\n        return \"肥満度2以上\"\n\n# テストデータ\ntest_data = [\n    {\"名前\": \"田中\", \"体重\": 70, \"身長\": 1.75},\n    {\"名前\": \"佐藤\", \"体重\": 55, \"身長\": 1.60},\n    {\"名前\": \"鈴木\", \"体重\": 85, \"身長\": 1.80},\n    {\"名前\": \"エラー例\", \"体重\": 70, \"身長\": 0},  # エラーケース\n]\n\nprint(\"=== BMI 計算結果 ===\")\nfor person in test_data:\n    name = person[\"名前\"]\n    weight = person[\"体重\"]\n    height = person[\"身長\"]\n    \n    bmi = calculate_bmi(weight, height)\n    category = get_bmi_category(bmi)\n    \n    if isinstance(bmi, str):  # エラーの場合\n        print(f\"{name}: {bmi}\")\n    else:\n        print(f\"{name}: BMI={bmi}, 判定={category}\")\n\n\n\n17.2.3 問題 3: ファイル処理とデータ分析\n\nimport json\nfrom datetime import datetime, timedelta\n\n# サンプルデータ（実際のファイルの代わり）\nsample_data = [\n    {\"日付\": \"2024-01-01\", \"売上\": 120000, \"顧客数\": 45},\n    {\"日付\": \"2024-01-02\", \"売上\": 98000, \"顧客数\": 38},\n    {\"日付\": \"2024-01-03\", \"売上\": 145000, \"顧客数\": 52},\n    {\"日付\": \"2024-01-04\", \"売上\": 87000, \"顧客数\": 33},\n    {\"日付\": \"2024-01-05\", \"売上\": 167000, \"顧客数\": 61},\n]\n\ndef analyze_sales_data(data):\n    \"\"\"売上データを分析する関数\"\"\"\n    if not data:\n        return {\"エラー\": \"データが空です\"}\n    \n    # 基本統計\n    total_sales = sum(day[\"売上\"] for day in data)\n    total_customers = sum(day[\"顧客数\"] for day in data)\n    average_sales = total_sales / len(data)\n    average_customers = total_customers / len(data)\n    \n    # 最高・最低売上日\n    best_day = max(data, key=lambda x: x[\"売上\"])\n    worst_day = min(data, key=lambda x: x[\"売上\"])\n    \n    # 顧客あたりの平均売上\n    customer_avg_spending = []\n    for day in data:\n        if day[\"顧客数\"] &gt; 0:\n            avg = day[\"売上\"] / day[\"顧客数\"]\n            customer_avg_spending.append(avg)\n    \n    overall_avg_spending = sum(customer_avg_spending) / len(customer_avg_spending)\n    \n    return {\n        \"分析期間\": f\"{data[0]['日付']} ～ {data[-1]['日付']}\",\n        \"総売上\": f\"{total_sales:,}円\",\n        \"総顧客数\": f\"{total_customers:,}人\",\n        \"日平均売上\": f\"{average_sales:,.0f}円\",\n        \"日平均顧客数\": f\"{average_customers:.1f}人\",\n        \"最高売上日\": f\"{best_day['日付']} ({best_day['売上']:,}円)\",\n        \"最低売上日\": f\"{worst_day['日付']} ({worst_day['売上']:,}円)\",\n        \"顧客あたり平均単価\": f\"{overall_avg_spending:,.0f}円\"\n    }\n\n# データ分析の実行\nanalysis = analyze_sales_data(sample_data)\n\nprint(\"=== 売上分析レポート ===\")\nfor key, value in analysis.items():\n    print(f\"{key}: {value}\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#実践課題",
    "href": "book/99-self-review-1.html#実践課題",
    "title": "17  自己評価: Python の基礎",
    "section": "17.3 🎯 実践課題",
    "text": "17.3 🎯 実践課題\n\n17.3.1 課題 1: 家計簿アプリケーション\n以下の機能を持つ簡単な家計簿プログラムを作成してください：\n\nclass HouseholdBudget:\n    \"\"\"家計簿管理クラス\"\"\"\n    \n    def __init__(self):\n        self.transactions = []\n        self.categories = {\n            \"収入\": [\"給与\", \"ボーナス\", \"その他収入\"],\n            \"支出\": [\"食費\", \"住居費\", \"交通費\", \"娯楽費\", \"その他支出\"]\n        }\n    \n    def add_transaction(self, date, category, amount, description=\"\"):\n        \"\"\"取引を追加\"\"\"\n        transaction = {\n            \"日付\": date,\n            \"カテゴリ\": category,\n            \"金額\": amount,\n            \"説明\": description,\n            \"ID\": len(self.transactions) + 1\n        }\n        self.transactions.append(transaction)\n        return f\"取引を追加しました: {description} ({amount:,}円)\"\n    \n    def get_balance(self):\n        \"\"\"収支を計算\"\"\"\n        income = sum(t[\"金額\"] for t in self.transactions \n                    if t[\"カテゴリ\"] in self.categories[\"収入\"])\n        expense = sum(t[\"金額\"] for t in self.transactions \n                     if t[\"カテゴリ\"] in self.categories[\"支出\"])\n        return income - expense\n    \n    def get_summary_by_category(self):\n        \"\"\"カテゴリ別集計\"\"\"\n        summary = {}\n        for transaction in self.transactions:\n            category = transaction[\"カテゴリ\"]\n            amount = transaction[\"金額\"]\n            if category in summary:\n                summary[category] += amount\n            else:\n                summary[category] = amount\n        return summary\n    \n    def get_monthly_report(self, year, month):\n        \"\"\"月次レポート\"\"\"\n        monthly_transactions = [\n            t for t in self.transactions \n            if t[\"日付\"].startswith(f\"{year}-{month:02d}\")\n        ]\n        \n        if not monthly_transactions:\n            return f\"{year}年{month}月のデータがありません\"\n        \n        income = sum(t[\"金額\"] for t in monthly_transactions \n                    if t[\"カテゴリ\"] in self.categories[\"収入\"])\n        expense = sum(t[\"金額\"] for t in monthly_transactions \n                     if t[\"カテゴリ\"] in self.categories[\"支出\"])\n        \n        return {\n            \"期間\": f\"{year}年{month}月\",\n            \"収入\": f\"{income:,}円\",\n            \"支出\": f\"{expense:,}円\",\n            \"収支\": f\"{income - expense:,}円\",\n            \"取引件数\": len(monthly_transactions)\n        }\n\n# 家計簿のテスト\nbudget = HouseholdBudget()\n\n# サンプルデータの追加\nprint(\"=== 取引データの追加 ===\")\nprint(budget.add_transaction(\"2024-01-01\", \"給与\", 300000, \"月給\"))\nprint(budget.add_transaction(\"2024-01-03\", \"食費\", -5000, \"スーパーでの買い物\"))\nprint(budget.add_transaction(\"2024-01-05\", \"住居費\", -80000, \"家賃\"))\nprint(budget.add_transaction(\"2024-01-10\", \"娯楽費\", -12000, \"映画・食事\"))\nprint(budget.add_transaction(\"2024-01-15\", \"その他収入\", 50000, \"副業\"))\n\n# 残高確認\nprint(f\"\\n現在の残高: {budget.get_balance():,}円\")\n\n# カテゴリ別集計\nprint(\"\\n=== カテゴリ別集計 ===\")\nsummary = budget.get_summary_by_category()\nfor category, amount in summary.items():\n    print(f\"{category}: {amount:,}円\")\n\n# 月次レポート\nprint(\"\\n=== 月次レポート ===\")\nreport = budget.get_monthly_report(2024, 1)\nif isinstance(report, dict):\n    for key, value in report.items():\n        print(f\"{key}: {value}\")\nelse:\n    print(report)",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#習熟度評価",
    "href": "book/99-self-review-1.html#習熟度評価",
    "title": "17  自己評価: Python の基礎",
    "section": "17.4 🏆 習熟度評価",
    "text": "17.4 🏆 習熟度評価\n\n17.4.1 レベル 1 (初心者)\n\n変数と基本データ型を理解している\n簡単な計算とprint文が使える\nリストと辞書の基本操作ができる\n\n\n\n17.4.2 レベル 2 (初級)\n\nif文とfor文を組み合わせて使える\n関数を定義して使える\n基本的なエラー処理ができる\n\n\n\n17.4.3 レベル 3 (中級)\n\n複雑なデータ構造を扱える\nモジュールを作成・利用できる\nクラスの基本概念を理解している\n\n\n\n17.4.4 レベル 4 (中上級)\n\n実践的なアプリケーションを作成できる\nデバッグとテストができる\nコードの可読性と保守性を意識できる",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#次のステップ",
    "href": "book/99-self-review-1.html#次のステップ",
    "title": "17  自己評価: Python の基礎",
    "section": "17.5 💡 次のステップ",
    "text": "17.5 💡 次のステップ\nこの自己評価で自信がついたら、次の分野に進みましょう：\n\nオブジェクト指向プログラミング: クラスと継承\n高度なトピック: 型ヒント、非同期プログラミング\n実践的な応用: Webアプリケーション、データサイエンス\nツールとライブラリ: pandas、requests、Flask など",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#お疲れさまでした",
    "href": "book/99-self-review-1.html#お疲れさまでした",
    "title": "17  自己評価: Python の基礎",
    "section": "17.6 🎉 お疲れさまでした！",
    "text": "17.6 🎉 お疲れさまでした！\nPython の基礎をしっかりと学習されました。これらの概念は今後のプログラミング学習の土台となります。継続的に練習し、実際のプロジェクトで応用してください。\n\n17.6.1 学習のコツ\n\n実際にコードを書く: 読むだけでなく、手を動かして練習\n小さなプロジェクトから始める: 身近な問題を解決するプログラムを作成\nコミュニティに参加: オンラインフォーラムや勉強会で交流\n継続的な学習: 新しい機能やライブラリを定期的に学ぶ\n\n頑張ってください！🚀",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  }
]