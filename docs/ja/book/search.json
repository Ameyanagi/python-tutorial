[
  {
    "objectID": "book/10-type-hints.html",
    "href": "book/10-type-hints.html",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "",
    "text": "11.1 型ヒントとは\n型ヒント（Type Hints）は Python 3.5 から導入された機能で、コードの可読性を向上させ、バグを事前に発見するのに役立ちます。\n型ヒントは、変数や関数の引数・戻り値の型を明示的に指定する仕組みです。\n# 型ヒントなし\ndef greet(name):\n    return f\"Hello, {name}!\"\n\n# 型ヒントあり\ndef greet_typed(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\n# 使用例\nmessage = greet_typed(\"太郎\")\nprint(message)",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#基本的な型の指定",
    "href": "book/10-type-hints.html#基本的な型の指定",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.2 基本的な型の指定",
    "text": "11.2 基本的な型の指定\n\n11.2.1 プリミティブ型\n\nfrom typing import List, Dict, Tuple, Optional\n\n# 基本型\nname: str = \"田中\"\nage: int = 25\nheight: float = 170.5\nis_student: bool = True\n\nprint(f\"名前: {name} ({type(name).__name__})\")\nprint(f\"年齢: {age} ({type(age).__name__})\")\nprint(f\"身長: {height} ({type(height).__name__})\")\nprint(f\"学生: {is_student} ({type(is_student).__name__})\")\n\n\n\n11.2.2 コレクション型\n\n# リスト型\nnumbers: List[int] = [1, 2, 3, 4, 5]\nnames: List[str] = [\"太郎\", \"花子\", \"次郎\"]\n\n# 辞書型\nstudent_ages: Dict[str, int] = {\n    \"太郎\": 20,\n    \"花子\": 22,\n    \"次郎\": 19\n}\n\n# タプル型\ncoordinates: Tuple[float, float] = (35.6762, 139.6503)\nrgb_color: Tuple[int, int, int] = (255, 128, 0)\n\nprint(f\"数値リスト: {numbers}\")\nprint(f\"名前リスト: {names}\")\nprint(f\"学生の年齢: {student_ages}\")\nprint(f\"座標: {coordinates}\")\nprint(f\"RGB色: {rgb_color}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#関数の型ヒント",
    "href": "book/10-type-hints.html#関数の型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.3 関数の型ヒント",
    "text": "11.3 関数の型ヒント\n\n11.3.1 基本的な関数\n\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"二つの数値を足し算する関数\"\"\"\n    return a + b\n\ndef calculate_average(numbers: List[float]) -&gt; float:\n    \"\"\"数値リストの平均を計算\"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)\n\ndef format_name(first: str, last: str, middle: str = \"\") -&gt; str:\n    \"\"\"名前をフォーマット\"\"\"\n    if middle:\n        return f\"{last} {first} {middle}\"\n    return f\"{last} {first}\"\n\n# 使用例\nresult = add_numbers(10, 20)\nprint(f\"10 + 20 = {result}\")\n\nscores = [85.5, 92.0, 78.5, 90.0]\navg = calculate_average(scores)\nprint(f\"平均点: {avg:.1f}\")\n\nfull_name = format_name(\"太郎\", \"田中\")\nprint(f\"フルネーム: {full_name}\")\n\n\n\n11.3.2 Optional と Union 型\n\nfrom typing import Optional, Union\n\ndef find_student(students: List[str], name: str) -&gt; Optional[int]:\n    \"\"\"学生のインデックスを検索（見つからない場合は None）\"\"\"\n    try:\n        return students.index(name)\n    except ValueError:\n        return None\n\ndef process_number(value: Union[int, float, str]) -&gt; float:\n    \"\"\"様々な型の数値を float に変換\"\"\"\n    if isinstance(value, str):\n        return float(value)\n    return float(value)\n\n# 使用例\nstudents = [\"太郎\", \"花子\", \"次郎\"]\n\nindex = find_student(students, \"花子\")\nif index is not None:\n    print(f\"花子は {index} 番目にいます\")\nelse:\n    print(\"花子が見つかりません\")\n\n# Union 型のテスト\nprint(f\"整数 42: {process_number(42)}\")\nprint(f\"浮動小数点 3.14: {process_number(3.14)}\")\nprint(f\"文字列 '123.45': {process_number('123.45')}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#クラスの型ヒント",
    "href": "book/10-type-hints.html#クラスの型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.4 クラスの型ヒント",
    "text": "11.4 クラスの型ヒント\n\nfrom typing import ClassVar\nfrom datetime import datetime\n\nclass Student:\n    \"\"\"学生クラス\"\"\"\n    \n    # クラス変数の型ヒント\n    school_name: ClassVar[str] = \"東京大学\"\n    \n    def __init__(self, name: str, age: int, grade: int) -&gt; None:\n        self.name: str = name\n        self.age: int = age\n        self.grade: int = grade\n        self.scores: List[float] = []\n    \n    def add_score(self, score: float) -&gt; None:\n        \"\"\"成績を追加\"\"\"\n        self.scores.append(score)\n    \n    def get_average_score(self) -&gt; Optional[float]:\n        \"\"\"平均点を取得\"\"\"\n        if not self.scores:\n            return None\n        return sum(self.scores) / len(self.scores)\n    \n    def get_info(self) -&gt; Dict[str, Union[str, int, float, None]]:\n        \"\"\"学生情報を辞書で返す\"\"\"\n        return {\n            \"name\": self.name,\n            \"age\": self.age,\n            \"grade\": self.grade,\n            \"average_score\": self.get_average_score()\n        }\n    \n    def __str__(self) -&gt; str:\n        return f\"学生: {self.name} ({self.age}歳, {self.grade}年生)\"\n\n# 使用例\nstudent = Student(\"田中太郎\", 20, 2)\nstudent.add_score(85.5)\nstudent.add_score(92.0)\nstudent.add_score(78.5)\n\nprint(student)\nprint(f\"平均点: {student.get_average_score():.1f}\")\nprint(f\"詳細情報: {student.get_info()}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#ジェネリック型",
    "href": "book/10-type-hints.html#ジェネリック型",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.5 ジェネリック型",
    "text": "11.5 ジェネリック型\n\nfrom typing import TypeVar, Generic, List\n\n# 型変数の定義\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    \"\"\"ジェネリックなスタッククラス\"\"\"\n    \n    def __init__(self) -&gt; None:\n        self._items: List[T] = []\n    \n    def push(self, item: T) -&gt; None:\n        \"\"\"要素をプッシュ\"\"\"\n        self._items.append(item)\n    \n    def pop(self) -&gt; Optional[T]:\n        \"\"\"要素をポップ\"\"\"\n        if self._items:\n            return self._items.pop()\n        return None\n    \n    def peek(self) -&gt; Optional[T]:\n        \"\"\"トップの要素を確認\"\"\"\n        if self._items:\n            return self._items[-1]\n        return None\n    \n    def is_empty(self) -&gt; bool:\n        \"\"\"スタックが空かどうか\"\"\"\n        return len(self._items) == 0\n    \n    def size(self) -&gt; int:\n        \"\"\"スタックのサイズ\"\"\"\n        return len(self._items)\n\n# 文字列スタック\nstring_stack: Stack[str] = Stack()\nstring_stack.push(\"最初\")\nstring_stack.push(\"二番目\")\nstring_stack.push(\"三番目\")\n\nprint(f\"スタックサイズ: {string_stack.size()}\")\nprint(f\"トップ要素: {string_stack.peek()}\")\nprint(f\"ポップ: {string_stack.pop()}\")\n\n# 数値スタック\nnumber_stack: Stack[int] = Stack()\nnumber_stack.push(10)\nnumber_stack.push(20)\nnumber_stack.push(30)\n\nprint(f\"数値スタックサイズ: {number_stack.size()}\")\nprint(f\"数値トップ: {number_stack.peek()}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#高度な型ヒント",
    "href": "book/10-type-hints.html#高度な型ヒント",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.6 高度な型ヒント",
    "text": "11.6 高度な型ヒント\n\n11.6.1 Callable 型\n\nfrom typing import Callable\n\ndef apply_operation(x: int, y: int, operation: Callable[[int, int], int]) -&gt; int:\n    \"\"\"二つの数値に演算を適用\"\"\"\n    return operation(x, y)\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\ndef multiply(a: int, b: int) -&gt; int:\n    return a * b\n\n# 使用例\nresult1 = apply_operation(10, 5, add)\nresult2 = apply_operation(10, 5, multiply)\n\nprint(f\"10 + 5 = {result1}\")\nprint(f\"10 × 5 = {result2}\")\n\n# ラムダ関数も使用可能\nresult3 = apply_operation(10, 5, lambda x, y: x - y)\nprint(f\"10 - 5 = {result3}\")\n\n\n\n11.6.2 Literal 型\n\nfrom typing import Literal\n\ndef set_color(color: Literal[\"red\", \"green\", \"blue\"]) -&gt; str:\n    \"\"\"指定された色を設定\"\"\"\n    return f\"色を {color} に設定しました\"\n\ndef calculate_shape_area(shape: Literal[\"circle\", \"square\", \"triangle\"], size: float) -&gt; float:\n    \"\"\"図形の面積を計算\"\"\"\n    import math\n    \n    if shape == \"circle\":\n        return math.pi * (size / 2) ** 2\n    elif shape == \"square\":\n        return size ** 2\n    elif shape == \"triangle\":\n        return (size ** 2) * math.sqrt(3) / 4\n    \n    return 0.0\n\n# 使用例\nprint(set_color(\"red\"))\nprint(set_color(\"blue\"))\n\narea1 = calculate_shape_area(\"circle\", 10)\narea2 = calculate_shape_area(\"square\", 10)\nprint(f\"円の面積 (直径10): {area1:.2f}\")\nprint(f\"正方形の面積 (辺10): {area2:.2f}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#型ヒントの検証",
    "href": "book/10-type-hints.html#型ヒントの検証",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.7 型ヒントの検証",
    "text": "11.7 型ヒントの検証\n\n11.7.1 mypy を使った静的型チェック\n\n# 以下は mypy でチェックできる例\n\ndef divide_numbers(a: int, b: int) -&gt; float:\n    \"\"\"数値を割り算する（型安全版）\"\"\"\n    if b == 0:\n        raise ValueError(\"ゼロで割ることはできません\")\n    return a / b\n\ndef process_user_data(data: Dict[str, Union[str, int]]) -&gt; str:\n    \"\"\"ユーザーデータを処理\"\"\"\n    name = data.get(\"name\", \"未知\")\n    age = data.get(\"age\", 0)\n    \n    if not isinstance(name, str):\n        name = str(name)\n    if not isinstance(age, int):\n        age = int(age) if str(age).isdigit() else 0\n    \n    return f\"{name} ({age}歳)\"\n\n# 正しい使用例\nresult = divide_numbers(10, 3)\nprint(f\"10 ÷ 3 = {result:.2f}\")\n\nuser = {\"name\": \"田中太郎\", \"age\": 25}\ninfo = process_user_data(user)\nprint(f\"ユーザー情報: {info}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#実践的な例タスク管理システム",
    "href": "book/10-type-hints.html#実践的な例タスク管理システム",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.8 実践的な例：タスク管理システム",
    "text": "11.8 実践的な例：タスク管理システム\n\nfrom typing import NamedTuple\nfrom enum import Enum\nfrom datetime import datetime, date\n\nclass Priority(Enum):\n    \"\"\"タスクの優先度\"\"\"\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    URGENT = 4\n\nclass Task(NamedTuple):\n    \"\"\"タスクデータ構造\"\"\"\n    id: int\n    title: str\n    description: str\n    priority: Priority\n    due_date: Optional[date]\n    completed: bool = False\n\nclass TaskManager:\n    \"\"\"タスク管理システム\"\"\"\n    \n    def __init__(self) -&gt; None:\n        self._tasks: Dict[int, Task] = {}\n        self._next_id: int = 1\n    \n    def create_task(\n        self, \n        title: str, \n        description: str, \n        priority: Priority = Priority.MEDIUM,\n        due_date: Optional[date] = None\n    ) -&gt; Task:\n        \"\"\"新しいタスクを作成\"\"\"\n        task = Task(\n            id=self._next_id,\n            title=title,\n            description=description,\n            priority=priority,\n            due_date=due_date\n        )\n        self._tasks[self._next_id] = task\n        self._next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -&gt; Optional[Task]:\n        \"\"\"IDでタスクを取得\"\"\"\n        return self._tasks.get(task_id)\n    \n    def get_tasks_by_priority(self, priority: Priority) -&gt; List[Task]:\n        \"\"\"優先度でタスクをフィルタ\"\"\"\n        return [task for task in self._tasks.values() if task.priority == priority]\n    \n    def complete_task(self, task_id: int) -&gt; bool:\n        \"\"\"タスクを完了にマーク\"\"\"\n        if task_id in self._tasks:\n            old_task = self._tasks[task_id]\n            self._tasks[task_id] = old_task._replace(completed=True)\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -&gt; List[Task]:\n        \"\"\"期限切れのタスクを取得\"\"\"\n        today = date.today()\n        return [\n            task for task in self._tasks.values()\n            if task.due_date and task.due_date &lt; today and not task.completed\n        ]\n\n# 使用例\nmanager = TaskManager()\n\n# タスクの作成\ntask1 = manager.create_task(\n    \"レポート作成\", \n    \"Python チュートリアルのレポートを書く\",\n    Priority.HIGH,\n    date(2024, 12, 31)\n)\n\ntask2 = manager.create_task(\n    \"買い物\", \n    \"食材を買いに行く\",\n    Priority.MEDIUM\n)\n\ntask3 = manager.create_task(\n    \"メール返信\", \n    \"重要なメールに返信する\",\n    Priority.URGENT,\n    date(2024, 1, 15)\n)\n\nprint(f\"作成されたタスク: {task1}\")\nprint(f\"高優先度タスク数: {len(manager.get_tasks_by_priority(Priority.HIGH))}\")\n\n# タスクの完了\nsuccess = manager.complete_task(task2.id)\nprint(f\"タスク完了: {success}\")\n\n# 期限切れタスクのチェック\noverdue = manager.get_overdue_tasks()\nprint(f\"期限切れタスク数: {len(overdue)}\")",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#型ヒントのベストプラクティス",
    "href": "book/10-type-hints.html#型ヒントのベストプラクティス",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.9 型ヒントのベストプラクティス",
    "text": "11.9 型ヒントのベストプラクティス\n\n11.9.1 1. 段階的な導入\n\n# 始めは重要な関数から\ndef important_function(data: List[str]) -&gt; Dict[str, int]:\n    \"\"\"重要な処理を行う関数\"\"\"\n    result = {}\n    for item in data:\n        result[item] = len(item)\n    return result\n\n# 徐々に全体に拡張\n\n\n\n11.9.2 2. 複雑な型の簡略化\n\nfrom typing import TypeAlias, Any\n\n# 複雑な型を別名で定義\nUserData: TypeAlias = Dict[str, Union[str, int, List[str]]]\nProcessResult: TypeAlias = Tuple[bool, str, Optional[Dict[str, Any]]]\n\ndef process_user(data: UserData) -&gt; ProcessResult:\n    \"\"\"ユーザーデータを処理\"\"\"\n    try:\n        # 処理ロジック\n        return True, \"成功\", {\"processed\": True}\n    except Exception as e:\n        return False, str(e), None",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#まとめ",
    "href": "book/10-type-hints.html#まとめ",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.10 まとめ",
    "text": "11.10 まとめ\n型ヒントは以下の利点を提供します：\n\nコードの可読性向上: 関数の期待する入力と出力が明確\nIDE サポート: より良い自動補完とエラー検出\nバグの早期発見: 型チェッカーによる静的解析\nドキュメント: コード自体が型情報を含む\nリファクタリング支援: 型安全な変更が可能\n\n\n11.10.1 推奨事項\n\n新しいプロジェクトでは積極的に使用\n既存コードは段階的に追加\nmypy や pyright などの型チェッカーを活用\n複雑な型は TypeAlias で簡略化\nジェネリック型で再利用性を向上\n\n型ヒントは Python をより堅牢で保守性の高い言語にする重要な機能です。モダンな Python 開発では必須のスキルとなっています。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/10-type-hints.html#次の章",
    "href": "book/10-type-hints.html#次の章",
    "title": "11  型ヒント - モダンな Python 開発",
    "section": "11.11 次の章",
    "text": "11.11 次の章\n次は非同期プログラミングについて学び、並行処理の基礎を理解しましょう。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>型ヒント - モダンな Python 開発</span>"
    ]
  },
  {
    "objectID": "book/12-async.html",
    "href": "book/12-async.html",
    "title": "12  非同期プログラミングと並行性",
    "section": "",
    "text": "12.1 非同期プログラミングの理解\n非同期プログラミングを使用すると、ブロックすることなく複数のタスクを効率的に処理できる並行コードを記述できます。これは、Webリクエスト、ファイル操作、データベースクエリなどのI/Oバウンドな操作に最適です。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#非同期プログラミングの理解",
    "href": "book/12-async.html#非同期プログラミングの理解",
    "title": "12  非同期プログラミングと並行性",
    "section": "",
    "text": "12.1.1 同期 vs 非同期\n\nimport time\nimport asyncio\n\n# 同期的なアプローチ - ブロッキング\ndef sync_task(name: str, duration: int) -&gt; str:\n    \"\"\"時間のかかるタスクを同期的にシミュレート\"\"\"\n    print(f\"{name}を開始...\")\n    time.sleep(duration)  # プログラム全体をブロック\n    print(f\"{name}を完了\")\n    return f\"{name}からの結果\"\n\ndef run_sync_tasks():\n    \"\"\"複数のタスクを同期的に実行\"\"\"\n    print(\"=== 同期実行 ===\")\n    start_time = time.time()\n    \n    result1 = sync_task(\"タスク1\", 2)\n    result2 = sync_task(\"タスク2\", 2)\n    result3 = sync_task(\"タスク3\", 2)\n    \n    end_time = time.time()\n    print(f\"合計時間: {end_time - start_time:.2f}秒\")\n    return [result1, result2, result3]\n\n# 非同期的なアプローチ - ノンブロッキング\nasync def async_task(name: str, duration: int) -&gt; str:\n    \"\"\"時間のかかるタスクを非同期的にシミュレート\"\"\"\n    print(f\"{name}を開始...\")\n    await asyncio.sleep(duration)  # ノンブロッキングな待機\n    print(f\"{name}を完了\")\n    return f\"{name}からの結果\"\n\nasync def run_async_tasks():\n    \"\"\"複数のタスクを非同期的に実行\"\"\"\n    print(\"\\n=== 非同期実行 ===\")\n    start_time = time.time()\n    \n    # タスクを並行実行\n    results = await asyncio.gather(\n        async_task(\"タスク1\", 2),\n        async_task(\"タスク2\", 2),\n        async_task(\"タスク3\", 2)\n    )\n    \n    end_time = time.time()\n    print(f\"合計時間: {end_time - start_time:.2f}秒\")\n    return results\n\n# 実行比較\nprint(\"同期と非同期の実行時間比較:\")\nsync_results = run_sync_tasks()\n\n# 非同期の実行\nasync_results = await run_async_tasks()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#基本的な非同期パターン",
    "href": "book/12-async.html#基本的な非同期パターン",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.2 基本的な非同期パターン",
    "text": "12.2 基本的な非同期パターン\n\n12.2.1 async/await の基本\n\nimport asyncio\nimport random\n\nasync def fetch_data(url: str) -&gt; str:\n    \"\"\"Webからデータを取得する模擬関数\"\"\"\n    print(f\"データを取得中: {url}\")\n    \n    # ランダムな遅延で実際のHTTPリクエストをシミュレート\n    delay = random.uniform(1, 3)\n    await asyncio.sleep(delay)\n    \n    print(f\"データ取得完了: {url}\")\n    return f\"{url}からのデータ\"\n\nasync def process_data(data: str) -&gt; str:\n    \"\"\"データを処理する模擬関数\"\"\"\n    print(f\"データ処理中: {data}\")\n    \n    # 処理時間をシミュレート\n    await asyncio.sleep(1)\n    \n    processed = f\"処理済み: {data}\"\n    print(f\"データ処理完了: {processed}\")\n    return processed\n\nasync def fetch_and_process(url: str) -&gt; str:\n    \"\"\"データの取得と処理を順序実行\"\"\"\n    # 段階的な処理\n    raw_data = await fetch_data(url)\n    processed_data = await process_data(raw_data)\n    return processed_data\n\n# 複数URLの並行処理\nasync def main():\n    urls = [\n        \"https://api.example1.com\",\n        \"https://api.example2.com\", \n        \"https://api.example3.com\"\n    ]\n    \n    print(\"=== 複数URLの並行処理 ===\")\n    start_time = time.time()\n    \n    results = await asyncio.gather(\n        *[fetch_and_process(url) for url in urls]\n    )\n    \n    end_time = time.time()\n    print(f\"\\n処理完了！合計時間: {end_time - start_time:.2f}秒\")\n    \n    for i, result in enumerate(results, 1):\n        print(f\"結果{i}: {result}\")\n\n# 実行\nawait main()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#コルーチンとタスク",
    "href": "book/12-async.html#コルーチンとタスク",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.3 コルーチンとタスク",
    "text": "12.3 コルーチンとタスク\n\n12.3.1 Task の作成と管理\n\nimport asyncio\nfrom typing import List\n\nasync def download_file(filename: str, size_mb: int) -&gt; str:\n    \"\"\"ファイルダウンロードをシミュレート\"\"\"\n    print(f\"ダウンロード開始: {filename} ({size_mb}MB)\")\n    \n    # サイズに比例したダウンロード時間\n    download_time = size_mb * 0.5\n    await asyncio.sleep(download_time)\n    \n    print(f\"ダウンロード完了: {filename}\")\n    return f\"{filename} (サイズ: {size_mb}MB)\"\n\nasync def monitor_downloads():\n    \"\"\"ダウンロード監視\"\"\"\n    for i in range(5):\n        print(f\"監視中... ({i+1}/5)\")\n        await asyncio.sleep(1)\n    print(\"監視終了\")\n\nasync def manage_downloads():\n    \"\"\"ダウンロードタスクの管理\"\"\"\n    print(\"=== ダウンロード管理システム ===\")\n    \n    # ダウンロードタスクを作成\n    download_tasks = [\n        asyncio.create_task(download_file(\"document.pdf\", 10)),\n        asyncio.create_task(download_file(\"video.mp4\", 25)), \n        asyncio.create_task(download_file(\"image.jpg\", 5)),\n        asyncio.create_task(download_file(\"software.zip\", 15))\n    ]\n    \n    # 監視タスクを作成\n    monitor_task = asyncio.create_task(monitor_downloads())\n    \n    # すべてのダウンロードが完了するまで待機\n    print(\"ダウンロード開始...\")\n    completed_downloads = await asyncio.gather(*download_tasks)\n    \n    # 監視タスクをキャンセル（必要に応じて）\n    if not monitor_task.done():\n        monitor_task.cancel()\n        try:\n            await monitor_task\n        except asyncio.CancelledError:\n            print(\"監視タスクをキャンセルしました\")\n    \n    print(\"\\nすべてのダウンロードが完了:\")\n    for download in completed_downloads:\n        print(f\"  - {download}\")\n\n# 実行\nawait manage_downloads()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#エラーハンドリングとタイムアウト",
    "href": "book/12-async.html#エラーハンドリングとタイムアウト",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.4 エラーハンドリングとタイムアウト",
    "text": "12.4 エラーハンドリングとタイムアウト\n\n12.4.1 堅牢な非同期処理\n\nimport asyncio\nimport random\n\nasync def unreliable_api_call(api_name: str) -&gt; str:\n    \"\"\"不安定なAPIコールをシミュレート\"\"\"\n    print(f\"API呼び出し中: {api_name}\")\n    \n    # ランダムな遅延\n    delay = random.uniform(1, 5)\n    await asyncio.sleep(delay)\n    \n    # ランダムに失敗する\n    if random.random() &lt; 0.3:  # 30%の確率で失敗\n        raise Exception(f\"{api_name}でエラーが発生しました\")\n    \n    print(f\"API呼び出し成功: {api_name}\")\n    return f\"{api_name}からの応答データ\"\n\nasync def safe_api_call(api_name: str, timeout: float = 3.0, retries: int = 3) -&gt; str:\n    \"\"\"タイムアウトとリトライ機能付きのAPIコール\"\"\"\n    \n    for attempt in range(retries):\n        try:\n            print(f\"試行 {attempt + 1}/{retries}: {api_name}\")\n            \n            # タイムアウト付きで実行\n            result = await asyncio.wait_for(\n                unreliable_api_call(api_name),\n                timeout=timeout\n            )\n            \n            return result\n            \n        except asyncio.TimeoutError:\n            print(f\"タイムアウト: {api_name} (試行 {attempt + 1}/{retries})\")\n            if attempt == retries - 1:\n                raise Exception(f\"{api_name}: {retries}回すべてタイムアウト\")\n            \n        except Exception as e:\n            print(f\"エラー: {api_name} - {e} (試行 {attempt + 1}/{retries})\")\n            if attempt == retries - 1:\n                raise e\n            \n            # 指数バックオフでリトライ間隔を調整\n            await asyncio.sleep(2 ** attempt)\n    \n    raise Exception(f\"{api_name}: 予期しないエラー\")\n\nasync def batch_api_calls():\n    \"\"\"複数のAPIコールを並行実行（エラーハンドリング付き）\"\"\"\n    apis = [\"UserAPI\", \"ProductAPI\", \"OrderAPI\", \"PaymentAPI\"]\n    \n    results = []\n    errors = []\n    \n    # すべてのAPIコールを並行実行\n    tasks = [safe_api_call(api) for api in apis]\n    \n    # as_completed で完了順に処理\n    print(\"=== 並行APIコール（エラーハンドリング付き） ===\")\n    for completed_task in asyncio.as_completed(tasks):\n        try:\n            result = await completed_task\n            results.append(result)\n            print(f\"✅ 成功: {result}\")\n        except Exception as e:\n            errors.append(str(e))\n            print(f\"❌ 失敗: {e}\")\n    \n    print(f\"\\n結果: 成功 {len(results)}, 失敗 {len(errors)}\")\n    return results, errors\n\n# 実行\nawait batch_api_calls()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#実際のアプリケーション例",
    "href": "book/12-async.html#実際のアプリケーション例",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.5 実際のアプリケーション例",
    "text": "12.5 実際のアプリケーション例\n\n12.5.1 非同期Webスクレイピング\n\nimport asyncio\nimport time\nfrom typing import Dict, List\n\nclass AsyncWebScraper:\n    \"\"\"非同期Webスクレイピングクラス\"\"\"\n    \n    def __init__(self, max_concurrent: int = 5):\n        self.max_concurrent = max_concurrent\n        self.semaphore = asyncio.Semaphore(max_concurrent)\n        self.session_active = False\n    \n    async def fetch_page(self, url: str) -&gt; Dict:\n        \"\"\"単一ページの取得\"\"\"\n        async with self.semaphore:  # 同時リクエスト数を制限\n            print(f\"取得中: {url}\")\n            \n            # HTTPリクエストをシミュレート\n            delay = random.uniform(0.5, 2.0)\n            await asyncio.sleep(delay)\n            \n            # 模擬レスポンス\n            response = {\n                \"url\": url,\n                \"title\": f\"ページタイトル from {url}\",\n                \"content_length\": random.randint(1000, 10000),\n                \"load_time\": delay\n            }\n            \n            print(f\"完了: {url} ({delay:.2f}秒)\")\n            return response\n    \n    async def scrape_multiple(self, urls: List[str]) -&gt; List[Dict]:\n        \"\"\"複数ページの並行取得\"\"\"\n        print(f\"=== 非同期スクレイピング開始 ===\")\n        print(f\"対象URL数: {len(urls)}, 最大同時接続数: {self.max_concurrent}\")\n        \n        start_time = time.time()\n        \n        # すべてのタスクを作成\n        tasks = [self.fetch_page(url) for url in urls]\n        \n        # 完了順に結果を収集\n        results = []\n        for completed_task in asyncio.as_completed(tasks):\n            try:\n                result = await completed_task\n                results.append(result)\n                print(f\"進捗: {len(results)}/{len(urls)}\")\n            except Exception as e:\n                print(f\"エラー: {e}\")\n        \n        end_time = time.time()\n        total_time = end_time - start_time\n        \n        print(f\"\\n=== スクレイピング完了 ===\")\n        print(f\"総時間: {total_time:.2f}秒\")\n        print(f\"平均時間/URL: {total_time/len(urls):.2f}秒\")\n        \n        return results\n\n# チャット応答システム\nclass AsyncChatBot:\n    \"\"\"非同期チャットボット\"\"\"\n    \n    def __init__(self):\n        self.conversation_history = []\n        self.processing_queue = asyncio.Queue()\n        self.response_cache = {}\n    \n    async def process_message(self, user_id: str, message: str) -&gt; str:\n        \"\"\"メッセージを処理して応答を生成\"\"\"\n        print(f\"ユーザー{user_id}: {message}\")\n        \n        # キャッシュをチェック\n        cache_key = message.lower().strip()\n        if cache_key in self.response_cache:\n            print(f\"キャッシュから応答: {cache_key}\")\n            return self.response_cache[cache_key]\n        \n        # 処理時間をシミュレート\n        thinking_time = random.uniform(1, 3)\n        await asyncio.sleep(thinking_time)\n        \n        # 模擬応答生成\n        responses = [\n            f\"「{message}」について考えています...\",\n            f\"それは興味深い質問ですね。{message}について説明します。\",\n            f\"{message}に関する情報をお調べしました。\",\n            f\"ご質問の{message}についてお答えします。\"\n        ]\n        \n        response = random.choice(responses)\n        \n        # キャッシュに保存\n        self.response_cache[cache_key] = response\n        \n        # 会話履歴に追加\n        self.conversation_history.append({\n            \"user_id\": user_id,\n            \"message\": message,\n            \"response\": response,\n            \"timestamp\": time.time()\n        })\n        \n        print(f\"ボット → ユーザー{user_id}: {response}\")\n        return response\n    \n    async def handle_multiple_users(self, messages: List[tuple]) -&gt; List[str]:\n        \"\"\"複数ユーザーからのメッセージを並行処理\"\"\"\n        print(\"=== マルチユーザーチャット処理 ===\")\n        \n        tasks = [\n            self.process_message(user_id, message) \n            for user_id, message in messages\n        ]\n        \n        responses = await asyncio.gather(*tasks)\n        \n        print(f\"\\n処理完了: {len(responses)}件のメッセージ\")\n        return responses\n\n# 使用例\nasync def demo_applications():\n    \"\"\"実際のアプリケーション例のデモ\"\"\"\n    \n    # 1. Webスクレイピングのデモ\n    scraper = AsyncWebScraper(max_concurrent=3)\n    urls = [\n        \"https://example1.com\",\n        \"https://example2.com\", \n        \"https://example3.com\",\n        \"https://example4.com\",\n        \"https://example5.com\"\n    ]\n    \n    scraping_results = await scraper.scrape_multiple(urls)\n    \n    print(f\"\\nスクレイピング結果: {len(scraping_results)}ページ取得\")\n    \n    # 2. チャットボットのデモ  \n    print(\"\\n\" + \"=\"*50)\n    \n    chatbot = AsyncChatBot()\n    user_messages = [\n        (\"001\", \"Pythonについて教えて\"),\n        (\"002\", \"非同期プログラミングとは何ですか？\"),\n        (\"003\", \"Pythonについて教えて\"),  # キャッシュされる\n        (\"004\", \"AIの将来について\"),\n        (\"001\", \"ありがとうございます\")\n    ]\n    \n    chat_responses = await chatbot.handle_multiple_users(user_messages)\n    \n    print(f\"\\nチャット処理完了: {len(chat_responses)}件の応答\")\n\n# 実行\nawait demo_applications()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/12-async.html#パフォーマンス監視と最適化",
    "href": "book/12-async.html#パフォーマンス監視と最適化",
    "title": "12  非同期プログラミングと並行性",
    "section": "12.6 パフォーマンス監視と最適化",
    "text": "12.6 パフォーマンス監視と最適化\n\n12.6.1 非同期プログラムの監視\n\nimport asyncio\nimport time\nfrom dataclasses import dataclass\nfrom typing import Callable, Any\n\n@dataclass\nclass TaskMetrics:\n    \"\"\"タスクのメトリクス\"\"\"\n    name: str\n    start_time: float\n    end_time: float = 0\n    duration: float = 0\n    status: str = \"running\"\n    result: Any = None\n    error: str = None\n\nclass AsyncProfiler:\n    \"\"\"非同期処理のプロファイラー\"\"\"\n    \n    def __init__(self):\n        self.metrics = {}\n        self.start_time = time.time()\n    \n    def profile_task(self, name: str):\n        \"\"\"タスクのプロファイリングデコレータ\"\"\"\n        def decorator(func: Callable):\n            async def wrapper(*args, **kwargs):\n                task_id = f\"{name}_{id(asyncio.current_task())}\"\n                \n                # メトリクス開始\n                self.metrics[task_id] = TaskMetrics(\n                    name=name,\n                    start_time=time.time()\n                )\n                \n                try:\n                    result = await func(*args, **kwargs)\n                    \n                    # 成功時のメトリクス更新\n                    metric = self.metrics[task_id]\n                    metric.end_time = time.time()\n                    metric.duration = metric.end_time - metric.start_time\n                    metric.status = \"completed\"\n                    metric.result = result\n                    \n                    return result\n                    \n                except Exception as e:\n                    # エラー時のメトリクス更新\n                    metric = self.metrics[task_id]\n                    metric.end_time = time.time()\n                    metric.duration = metric.end_time - metric.start_time\n                    metric.status = \"failed\"\n                    metric.error = str(e)\n                    \n                    raise e\n            \n            return wrapper\n        return decorator\n    \n    def get_summary(self) -&gt; dict:\n        \"\"\"実行サマリーを取得\"\"\"\n        if not self.metrics:\n            return {\"message\": \"メトリクスがありません\"}\n        \n        completed = [m for m in self.metrics.values() if m.status == \"completed\"]\n        failed = [m for m in self.metrics.values() if m.status == \"failed\"]\n        running = [m for m in self.metrics.values() if m.status == \"running\"]\n        \n        total_duration = time.time() - self.start_time\n        \n        summary = {\n            \"総実行時間\": f\"{total_duration:.2f}秒\",\n            \"総タスク数\": len(self.metrics),\n            \"完了\": len(completed),\n            \"失敗\": len(failed), \n            \"実行中\": len(running)\n        }\n        \n        if completed:\n            durations = [m.duration for m in completed]\n            summary.update({\n                \"平均実行時間\": f\"{sum(durations)/len(durations):.2f}秒\",\n                \"最短実行時間\": f\"{min(durations):.2f}秒\",\n                \"最長実行時間\": f\"{max(durations):.2f}秒\"\n            })\n        \n        return summary\n    \n    def print_detailed_report(self):\n        \"\"\"詳細レポートを表示\"\"\"\n        print(\"=== 非同期処理詳細レポート ===\")\n        \n        for task_id, metric in self.metrics.items():\n            status_emoji = {\n                \"completed\": \"✅\",\n                \"failed\": \"❌\", \n                \"running\": \"🔄\"\n            }.get(metric.status, \"❓\")\n            \n            print(f\"{status_emoji} {metric.name}\")\n            print(f\"   時間: {metric.duration:.2f}秒\")\n            print(f\"   ステータス: {metric.status}\")\n            \n            if metric.error:\n                print(f\"   エラー: {metric.error}\")\n            print()\n        \n        summary = self.get_summary()\n        print(\"=== サマリー ===\")\n        for key, value in summary.items():\n            print(f\"{key}: {value}\")\n\n# プロファイラーを使用したデモ\nprofiler = AsyncProfiler()\n\n@profiler.profile_task(\"データベース検索\")\nasync def database_query(query: str) -&gt; str:\n    \"\"\"データベースクエリをシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(0.5, 2.0))\n    if random.random() &lt; 0.1:  # 10%の確率で失敗\n        raise Exception(\"データベース接続エラー\")\n    return f\"クエリ結果: {query}\"\n\n@profiler.profile_task(\"API呼び出し\")\nasync def api_call(endpoint: str) -&gt; str:\n    \"\"\"API呼び出しをシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(1.0, 3.0))\n    if random.random() &lt; 0.15:  # 15%の確率で失敗\n        raise Exception(\"API応答エラー\")\n    return f\"API応答: {endpoint}\"\n\n@profiler.profile_task(\"ファイル処理\")\nasync def file_processing(filename: str) -&gt; str:\n    \"\"\"ファイル処理をシミュレート\"\"\"\n    await asyncio.sleep(random.uniform(0.3, 1.5))\n    return f\"処理済み: {filename}\"\n\nasync def run_performance_demo():\n    \"\"\"パフォーマンス監視デモ\"\"\"\n    print(\"=== パフォーマンス監視デモ開始 ===\")\n    \n    # 複数のタスクを並行実行\n    tasks = []\n    \n    # データベースクエリタスク\n    for i in range(5):\n        tasks.append(database_query(f\"SELECT * FROM table_{i}\"))\n    \n    # API呼び出しタスク\n    endpoints = [\"users\", \"products\", \"orders\", \"payments\"]\n    for endpoint in endpoints:\n        tasks.append(api_call(endpoint))\n    \n    # ファイル処理タスク\n    files = [\"data1.csv\", \"data2.json\", \"report.pdf\"]\n    for filename in files:\n        tasks.append(file_processing(filename))\n    \n    # すべてのタスクを実行\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    \n    # 結果の分析\n    successful_results = [r for r in results if not isinstance(r, Exception)]\n    failed_results = [r for r in results if isinstance(r, Exception)]\n    \n    print(f\"\\n=== 実行結果 ===\")\n    print(f\"成功: {len(successful_results)}\")\n    print(f\"失敗: {len(failed_results)}\")\n    \n    # 詳細レポートを表示\n    profiler.print_detailed_report()\n\n# 実行\nawait run_performance_demo()\n\nこの章では、Pythonにおける非同期プログラミングの基本概念から実践的な応用まで学習しました。非同期プログラミングを適切に使用することで、I/Oバウンドなタスクのパフォーマンスを大幅に向上させることができます。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>非同期プログラミングと並行性</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html",
    "href": "book/13-multiprocessing.html",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "",
    "text": "13.1 マルチプロセッシングの基本概念\nマルチプロセッシングは、複数のCPUコアを活用してCPU集約的なタスクを並列実行することで、プログラムのパフォーマンスを大幅に向上させる技術です。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#マルチプロセッシングの基本概念",
    "href": "book/13-multiprocessing.html#マルチプロセッシングの基本概念",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "",
    "text": "13.1.1 シングルプロセス vs マルチプロセス\n\nimport time\nimport multiprocessing as mp\nfrom typing import List\n\ndef cpu_intensive_task(n: int) -&gt; int:\n    \"\"\"CPU集約的なタスクをシミュレート（素数計算）\"\"\"\n    def is_prime(num):\n        if num &lt; 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    \n    return count\n\ndef sequential_processing(numbers: List[int]) -&gt; List[int]:\n    \"\"\"順次処理\"\"\"\n    print(\"=== 順次処理 ===\")\n    start_time = time.time()\n    \n    results = []\n    for i, n in enumerate(numbers, 1):\n        print(f\"タスク {i}/{len(numbers)} 処理中...\")\n        result = cpu_intensive_task(n)\n        results.append(result)\n    \n    end_time = time.time()\n    print(f\"順次処理時間: {end_time - start_time:.2f}秒\")\n    return results\n\ndef parallel_processing(numbers: List[int]) -&gt; List[int]:\n    \"\"\"並列処理\"\"\"\n    print(\"\\n=== 並列処理 ===\")\n    start_time = time.time()\n    \n    # CPUコア数を取得\n    num_cores = mp.cpu_count()\n    print(f\"利用可能CPUコア数: {num_cores}\")\n    \n    # プロセスプールを使用して並列実行\n    with mp.Pool(processes=num_cores) as pool:\n        results = pool.map(cpu_intensive_task, numbers)\n    \n    end_time = time.time()\n    print(f\"並列処理時間: {end_time - start_time:.2f}秒\")\n    return results\n\n# 性能比較デモ\ndef performance_comparison():\n    \"\"\"性能比較デモ\"\"\"\n    # テストデータ（素数計算の範囲）\n    test_numbers = [10000, 15000, 20000, 25000]\n    \n    print(\"CPU集約的タスクの性能比較\")\n    print(f\"テストデータ: {test_numbers}\")\n    \n    # 順次処理\n    seq_results = sequential_processing(test_numbers)\n    \n    # 並列処理\n    par_results = parallel_processing(test_numbers)\n    \n    # 結果の検証\n    print(f\"\\n=== 結果比較 ===\")\n    for i, (seq, par) in enumerate(zip(seq_results, par_results)):\n        print(f\"データ{i+1}: 順次={seq}, 並列={par}, 一致={seq==par}\")\n\n# 実行\nperformance_comparison()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#プロセス間通信",
    "href": "book/13-multiprocessing.html#プロセス間通信",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.2 プロセス間通信",
    "text": "13.2 プロセス間通信\n\n13.2.1 Queue を使った通信\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom queue import Empty\n\ndef producer(queue: mp.Queue, producer_id: int, item_count: int):\n    \"\"\"データを生成してキューに送信\"\"\"\n    print(f\"プロデューサー {producer_id} 開始\")\n    \n    for i in range(item_count):\n        # データ生成をシミュレート\n        time.sleep(random.uniform(0.1, 0.5))\n        \n        item = {\n            \"id\": f\"P{producer_id}-{i+1}\",\n            \"data\": f\"データ from プロデューサー{producer_id}\",\n            \"value\": random.randint(1, 100),\n            \"timestamp\": time.time()\n        }\n        \n        queue.put(item)\n        print(f\"プロデューサー {producer_id}: {item['id']} 送信\")\n    \n    # 終了シグナル\n    queue.put(None)\n    print(f\"プロデューサー {producer_id} 終了\")\n\ndef consumer(queue: mp.Queue, consumer_id: int, result_queue: mp.Queue):\n    \"\"\"キューからデータを受信して処理\"\"\"\n    print(f\"コンシューマー {consumer_id} 開始\")\n    processed_count = 0\n    \n    while True:\n        try:\n            # タイムアウト付きでアイテムを取得\n            item = queue.get(timeout=2)\n            \n            if item is None:\n                # 終了シグナルを受信\n                print(f\"コンシューマー {consumer_id}: 終了シグナル受信\")\n                queue.put(None)  # 他のコンシューマーのために再送\n                break\n            \n            # データ処理をシミュレート\n            processing_time = random.uniform(0.2, 0.8)\n            time.sleep(processing_time)\n            \n            # 処理結果\n            result = {\n                \"consumer_id\": consumer_id,\n                \"original_id\": item[\"id\"],\n                \"processed_value\": item[\"value\"] * 2,\n                \"processing_time\": processing_time\n            }\n            \n            result_queue.put(result)\n            processed_count += 1\n            \n            print(f\"コンシューマー {consumer_id}: {item['id']} 処理完了\")\n            \n        except Empty:\n            print(f\"コンシューマー {consumer_id}: タイムアウト\")\n            break\n    \n    print(f\"コンシューマー {consumer_id} 終了 (処理数: {processed_count})\")\n\ndef run_producer_consumer_demo():\n    \"\"\"プロデューサー・コンシューマーパターンのデモ\"\"\"\n    print(\"=== プロデューサー・コンシューマーパターン ===\")\n    \n    # キューを作成\n    data_queue = mp.Queue(maxsize=10)  # 最大10アイテム\n    result_queue = mp.Queue()\n    \n    # プロセスを作成\n    processes = []\n    \n    # プロデューサープロセス（2つ）\n    for i in range(2):\n        p = mp.Process(target=producer, args=(data_queue, i+1, 5))\n        processes.append(p)\n        p.start()\n    \n    # コンシューマープロセス（3つ）\n    for i in range(3):\n        p = mp.Process(target=consumer, args=(data_queue, i+1, result_queue))\n        processes.append(p)\n        p.start()\n    \n    # 全プロセスの完了を待機\n    for p in processes:\n        p.join()\n    \n    # 結果を収集\n    print(\"\\n=== 処理結果 ===\")\n    results = []\n    while not result_queue.empty():\n        try:\n            result = result_queue.get_nowait()\n            results.append(result)\n        except Empty:\n            break\n    \n    # 統計情報\n    print(f\"総処理数: {len(results)}\")\n    for consumer_id in range(1, 4):\n        consumer_results = [r for r in results if r['consumer_id'] == consumer_id]\n        print(f\"コンシューマー {consumer_id}: {len(consumer_results)}件処理\")\n\n# 実行\nrun_producer_consumer_demo()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#共有メモリとロック",
    "href": "book/13-multiprocessing.html#共有メモリとロック",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.3 共有メモリとロック",
    "text": "13.3 共有メモリとロック\n\n13.3.1 安全な共有リソースアクセス\n\nimport multiprocessing as mp\nimport time\nimport random\n\ndef unsafe_counter_worker(shared_counter, worker_id: int, iterations: int):\n    \"\"\"安全でない共有カウンター（競合状態の例）\"\"\"\n    print(f\"ワーカー {worker_id} 開始（安全でない版）\")\n    \n    for i in range(iterations):\n        # 現在の値を読み取り\n        current_value = shared_counter.value\n        \n        # 処理時間をシミュレート\n        time.sleep(random.uniform(0.001, 0.005))\n        \n        # 値を更新\n        shared_counter.value = current_value + 1\n        \n        if (i + 1) % 10 == 0:\n            print(f\"ワーカー {worker_id}: {i+1}/{iterations} 完了\")\n    \n    print(f\"ワーカー {worker_id} 終了\")\n\ndef safe_counter_worker(shared_counter, lock, worker_id: int, iterations: int):\n    \"\"\"安全な共有カウンター（ロック使用）\"\"\"\n    print(f\"ワーカー {worker_id} 開始（安全版）\")\n    \n    for i in range(iterations):\n        # ロックを取得してクリティカルセクションを保護\n        with lock:\n            current_value = shared_counter.value\n            time.sleep(random.uniform(0.001, 0.005))\n            shared_counter.value = current_value + 1\n        \n        if (i + 1) % 10 == 0:\n            print(f\"ワーカー {worker_id}: {i+1}/{iterations} 完了\")\n    \n    print(f\"ワーカー {worker_id} 終了\")\n\ndef demonstrate_race_condition():\n    \"\"\"競合状態のデモンストレーション\"\"\"\n    print(\"=== 競合状態のデモ ===\")\n    \n    # 安全でない共有カウンター\n    print(\"\\n1. 安全でない共有カウンター:\")\n    unsafe_counter = mp.Value('i', 0)\n    \n    processes = []\n    num_workers = 4\n    iterations_per_worker = 25\n    expected_total = num_workers * iterations_per_worker\n    \n    start_time = time.time()\n    \n    for i in range(num_workers):\n        p = mp.Process(target=unsafe_counter_worker, \n                      args=(unsafe_counter, i+1, iterations_per_worker))\n        processes.append(p)\n        p.start()\n    \n    for p in processes:\n        p.join()\n    \n    unsafe_result = unsafe_counter.value\n    unsafe_time = time.time() - start_time\n    \n    print(f\"期待値: {expected_total}\")\n    print(f\"実際の値: {unsafe_result}\")\n    print(f\"データ競合による損失: {expected_total - unsafe_result}\")\n    print(f\"実行時間: {unsafe_time:.2f}秒\")\n    \n    # 安全な共有カウンター\n    print(\"\\n2. 安全な共有カウンター（ロック使用）:\")\n    safe_counter = mp.Value('i', 0)\n    lock = mp.Lock()\n    \n    processes = []\n    start_time = time.time()\n    \n    for i in range(num_workers):\n        p = mp.Process(target=safe_counter_worker,\n                      args=(safe_counter, lock, i+1, iterations_per_worker))\n        processes.append(p)\n        p.start()\n    \n    for p in processes:\n        p.join()\n    \n    safe_result = safe_counter.value\n    safe_time = time.time() - start_time\n    \n    print(f\"期待値: {expected_total}\")\n    print(f\"実際の値: {safe_result}\")\n    print(f\"データ整合性: {'✅ 正確' if safe_result == expected_total else '❌ 不正確'}\")\n    print(f\"実行時間: {safe_time:.2f}秒\")\n\n# 実行\ndemonstrate_race_condition()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#実際のアプリケーション例",
    "href": "book/13-multiprocessing.html#実際のアプリケーション例",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.4 実際のアプリケーション例",
    "text": "13.4 実際のアプリケーション例\n\n13.4.1 画像処理の並列化\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom typing import List, Tuple\n\nclass ImageProcessor:\n    \"\"\"画像処理クラス（シミュレーション）\"\"\"\n    \n    @staticmethod\n    def process_image(image_info: Tuple[str, int, int]) -&gt; dict:\n        \"\"\"単一画像の処理\"\"\"\n        filename, width, height = image_info\n        print(f\"処理中: {filename} ({width}x{height})\")\n        \n        # 画像処理をシミュレート（サイズに比例した処理時間）\n        processing_time = (width * height) / 1000000  # 1M pixelで1秒\n        processing_time += random.uniform(0.1, 0.5)\n        time.sleep(processing_time)\n        \n        # 処理結果\n        result = {\n            \"filename\": filename,\n            \"original_size\": (width, height),\n            \"processed_size\": (width // 2, height // 2),  # リサイズ\n            \"processing_time\": processing_time,\n            \"file_size_kb\": (width * height * 3) // 1024,  # RGB仮定\n            \"status\": \"completed\"\n        }\n        \n        print(f\"完了: {filename} ({processing_time:.2f}秒)\")\n        return result\n    \n    @staticmethod\n    def process_batch_sequential(images: List[Tuple[str, int, int]]) -&gt; List[dict]:\n        \"\"\"逐次処理\"\"\"\n        print(\"=== 逐次画像処理 ===\")\n        start_time = time.time()\n        \n        results = []\n        for i, image in enumerate(images, 1):\n            print(f\"進捗: {i}/{len(images)}\")\n            result = ImageProcessor.process_image(image)\n            results.append(result)\n        \n        total_time = time.time() - start_time\n        print(f\"逐次処理完了: {total_time:.2f}秒\")\n        return results\n    \n    @staticmethod\n    def process_batch_parallel(images: List[Tuple[str, int, int]], num_processes: int = None) -&gt; List[dict]:\n        \"\"\"並列処理\"\"\"\n        if num_processes is None:\n            num_processes = mp.cpu_count()\n        \n        print(f\"=== 並列画像処理 (プロセス数: {num_processes}) ===\")\n        start_time = time.time()\n        \n        with mp.Pool(processes=num_processes) as pool:\n            results = pool.map(ImageProcessor.process_image, images)\n        \n        total_time = time.time() - start_time\n        print(f\"並列処理完了: {total_time:.2f}秒\")\n        return results\n\ndef batch_processing_demo():\n    \"\"\"バッチ処理のデモ\"\"\"\n    # テスト用画像データ\n    test_images = [\n        (\"photo1.jpg\", 4000, 3000),\n        (\"photo2.jpg\", 6000, 4000), \n        (\"photo3.jpg\", 3000, 2000),\n        (\"photo4.jpg\", 5000, 3500),\n        (\"photo5.jpg\", 4500, 3000),\n        (\"photo6.jpg\", 3500, 2500),\n    ]\n    \n    print(\"画像処理バッチ処理デモ\")\n    print(f\"処理対象: {len(test_images)}枚の画像\")\n    \n    # 逐次処理\n    sequential_results = ImageProcessor.process_batch_sequential(test_images)\n    \n    print(\"\\n\" + \"=\"*50)\n    \n    # 並列処理\n    parallel_results = ImageProcessor.process_batch_parallel(test_images)\n    \n    # パフォーマンス分析\n    seq_total_time = sum(r[\"processing_time\"] for r in sequential_results)\n    par_total_time = sum(r[\"processing_time\"] for r in parallel_results)\n    \n    print(f\"\\n=== パフォーマンス分析 ===\")\n    print(f\"逐次処理時間: {seq_total_time:.2f}秒\")\n    print(f\"並列処理時間: {par_total_time:.2f}秒\")\n    \n    if seq_total_time &gt; 0:\n        speedup = seq_total_time / par_total_time\n        print(f\"速度向上: {speedup:.2f}倍\")\n\n# データ分析の並列化\nclass DataAnalyzer:\n    \"\"\"データ分析クラス\"\"\"\n    \n    @staticmethod\n    def analyze_chunk(data_chunk: List[int]) -&gt; dict:\n        \"\"\"データチャンクの分析\"\"\"\n        chunk_id = id(data_chunk) % 1000  # チャンクID\n        print(f\"チャンク {chunk_id} 分析中... (サイズ: {len(data_chunk)})\")\n        \n        # 重い計算をシミュレート\n        time.sleep(0.5)\n        \n        result = {\n            \"chunk_id\": chunk_id,\n            \"size\": len(data_chunk),\n            \"sum\": sum(data_chunk),\n            \"avg\": sum(data_chunk) / len(data_chunk) if data_chunk else 0,\n            \"min\": min(data_chunk) if data_chunk else 0,\n            \"max\": max(data_chunk) if data_chunk else 0,\n            \"std\": 0  # 簡略化\n        }\n        \n        print(f\"チャンク {chunk_id} 分析完了\")\n        return result\n    \n    @staticmethod\n    def parallel_analyze(data: List[int], chunk_size: int = 1000) -&gt; dict:\n        \"\"\"大規模データの並列分析\"\"\"\n        print(f\"=== 大規模データ並列分析 ===\")\n        print(f\"データサイズ: {len(data):,} 要素\")\n        print(f\"チャンクサイズ: {chunk_size:,} 要素\")\n        \n        # データをチャンクに分割\n        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]\n        print(f\"チャンク数: {len(chunks)}\")\n        \n        start_time = time.time()\n        \n        # 並列分析実行\n        with mp.Pool(processes=mp.cpu_count()) as pool:\n            chunk_results = pool.map(DataAnalyzer.analyze_chunk, chunks)\n        \n        processing_time = time.time() - start_time\n        \n        # 結果を統合\n        total_sum = sum(r[\"sum\"] for r in chunk_results)\n        total_count = sum(r[\"size\"] for r in chunk_results)\n        overall_avg = total_sum / total_count if total_count &gt; 0 else 0\n        overall_min = min(r[\"min\"] for r in chunk_results if r[\"size\"] &gt; 0)\n        overall_max = max(r[\"max\"] for r in chunk_results if r[\"size\"] &gt; 0)\n        \n        final_result = {\n            \"total_elements\": total_count,\n            \"processing_time\": processing_time,\n            \"chunks_processed\": len(chunk_results),\n            \"sum\": total_sum,\n            \"average\": overall_avg,\n            \"minimum\": overall_min,\n            \"maximum\": overall_max\n        }\n        \n        print(f\"\\n=== 分析結果 ===\")\n        for key, value in final_result.items():\n            if isinstance(value, float):\n                print(f\"{key}: {value:.2f}\")\n            else:\n                print(f\"{key}: {value:,}\" if isinstance(value, int) else f\"{key}: {value}\")\n        \n        return final_result\n\ndef data_analysis_demo():\n    \"\"\"データ分析デモ\"\"\"\n    # 大規模データセットを生成\n    data_size = 50000\n    test_data = [random.randint(1, 1000) for _ in range(data_size)]\n    \n    print(\"大規模データ分析デモ\")\n    \n    # 並列分析実行\n    result = DataAnalyzer.parallel_analyze(test_data, chunk_size=5000)\n\n# 実行\nprint(\"=== マルチプロセッシングデモ ===\\n\")\n\n# 1. 画像処理デモ\nbatch_processing_demo()\n\nprint(\"\\n\" + \"=\"*70 + \"\\n\")\n\n# 2. データ分析デモ  \ndata_analysis_demo()",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/13-multiprocessing.html#プロセスプールとワーカー管理",
    "href": "book/13-multiprocessing.html#プロセスプールとワーカー管理",
    "title": "13  マルチプロセッシングと並列計算",
    "section": "13.5 プロセスプールとワーカー管理",
    "text": "13.5 プロセスプールとワーカー管理\n\n13.5.1 高度なプロセス管理\n\nimport multiprocessing as mp\nimport time\nimport random\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\nfrom typing import List, Callable, Any\n\nclass ProcessManager:\n    \"\"\"プロセス管理クラス\"\"\"\n    \n    def __init__(self, max_workers: int = None):\n        self.max_workers = max_workers or mp.cpu_count()\n        self.completed_tasks = 0\n        self.failed_tasks = 0\n        self.total_processing_time = 0\n    \n    def execute_with_progress(self, func: Callable, tasks: List[Any]) -&gt; List[Any]:\n        \"\"\"進捗表示付きでタスクを実行\"\"\"\n        print(f\"=== プロセスプール実行 ===\")\n        print(f\"ワーカー数: {self.max_workers}\")\n        print(f\"タスク数: {len(tasks)}\")\n        \n        results = []\n        start_time = time.time()\n        \n        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n            # 全タスクを送信\n            future_to_task = {executor.submit(func, task): task for task in tasks}\n            \n            # 完了順に結果を処理\n            for future in as_completed(future_to_task):\n                task = future_to_task[future]\n                \n                try:\n                    result = future.result()\n                    results.append(result)\n                    self.completed_tasks += 1\n                    \n                    print(f\"完了: {self.completed_tasks}/{len(tasks)} \"\n                          f\"({(self.completed_tasks/len(tasks)*100):.1f}%)\")\n                    \n                except Exception as e:\n                    self.failed_tasks += 1\n                    print(f\"エラー: タスク {task} - {e}\")\n                    results.append(None)\n        \n        self.total_processing_time = time.time() - start_time\n        \n        print(f\"\\n=== 実行完了 ===\")\n        print(f\"成功: {self.completed_tasks}\")\n        print(f\"失敗: {self.failed_tasks}\")\n        print(f\"総時間: {self.total_processing_time:.2f}秒\")\n        \n        return results\n\ndef complex_calculation(params: dict) -&gt; dict:\n    \"\"\"複雑な計算タスク\"\"\"\n    task_id = params[\"id\"]\n    complexity = params[\"complexity\"]\n    \n    print(f\"タスク {task_id} 開始 (複雑度: {complexity})\")\n    \n    # 計算の複雑さに応じた処理時間\n    processing_time = complexity * random.uniform(0.1, 0.3)\n    time.sleep(processing_time)\n    \n    # ランダムに失敗\n    if random.random() &lt; 0.1:  # 10%の確率で失敗\n        raise Exception(f\"タスク {task_id} で計算エラー\")\n    \n    result = {\n        \"task_id\": task_id,\n        \"result\": complexity ** 2,\n        \"processing_time\": processing_time,\n        \"worker_pid\": mp.current_process().pid\n    }\n    \n    print(f\"タスク {task_id} 完了\")\n    return result\n\ndef advanced_process_management_demo():\n    \"\"\"高度なプロセス管理デモ\"\"\"\n    # タスクリストを生成\n    tasks = [\n        {\"id\": i, \"complexity\": random.randint(1, 10)}\n        for i in range(20)\n    ]\n    \n    # プロセス管理器を作成\n    manager = ProcessManager(max_workers=4)\n    \n    # タスクを実行\n    results = manager.execute_with_progress(complex_calculation, tasks)\n    \n    # 成功した結果のみを分析\n    successful_results = [r for r in results if r is not None]\n    \n    if successful_results:\n        print(f\"\\n=== 結果分析 ===\")\n        total_result = sum(r[\"result\"] for r in successful_results)\n        avg_processing_time = sum(r[\"processing_time\"] for r in successful_results) / len(successful_results)\n        \n        # ワーカーごとの統計\n        worker_stats = {}\n        for result in successful_results:\n            pid = result[\"worker_pid\"]\n            if pid not in worker_stats:\n                worker_stats[pid] = {\"count\": 0, \"total_time\": 0}\n            worker_stats[pid][\"count\"] += 1\n            worker_stats[pid][\"total_time\"] += result[\"processing_time\"]\n        \n        print(f\"合計結果: {total_result}\")\n        print(f\"平均処理時間: {avg_processing_time:.2f}秒\")\n        print(f\"ワーカー統計:\")\n        for pid, stats in worker_stats.items():\n            avg_time = stats[\"total_time\"] / stats[\"count\"]\n            print(f\"  PID {pid}: {stats['count']}タスク, 平均{avg_time:.2f}秒\")\n\n# 実行\nadvanced_process_management_demo()\n\nこの章では、Pythonにおけるマルチプロセッシングの基本概念から実践的な応用まで学習しました。適切にマルチプロセッシングを活用することで、CPU集約的なタスクのパフォーマンスを大幅に向上させることができます。",
    "crumbs": [
      "高度なトピック",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>マルチプロセッシングと並列計算</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html",
    "href": "book/14-data-science.html",
    "title": "14  データサイエンスとPython",
    "section": "",
    "text": "14.1 データサイエンスの基本ライブラリ\nPythonはデータサイエンスの分野で最も人気のある言語の一つです。豊富なライブラリエコシステムにより、データの収集、処理、分析、可視化まで一貫して行うことができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#データサイエンスの基本ライブラリ",
    "href": "book/14-data-science.html#データサイエンスの基本ライブラリ",
    "title": "14  データサイエンスとPython",
    "section": "",
    "text": "14.1.1 NumPy - 数値計算の基盤\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# NumPyの基本操作\nprint(\"=== NumPy基本操作 ===\")\n\n# 配列の作成\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(f\"1次元配列: {arr1}\")\nprint(f\"2次元配列:\\n{arr2}\")\nprint(f\"配列の形状: {arr2.shape}\")\nprint(f\"データ型: {arr2.dtype}\")\n\n# 特殊な配列の作成\nzeros = np.zeros((3, 4))\nones = np.ones((2, 3))\nrandom_arr = np.random.random((3, 3))\n\nprint(f\"\\nゼロ配列:\\n{zeros}\")\nprint(f\"ランダム配列:\\n{random_arr}\")\n\n# 数学的操作\ndata = np.array([1, 4, 9, 16, 25])\nprint(f\"\\n元のデータ: {data}\")\nprint(f\"平方根: {np.sqrt(data)}\")\nprint(f\"対数: {np.log(data)}\")\nprint(f\"合計: {np.sum(data)}\")\nprint(f\"平均: {np.mean(data)}\")\nprint(f\"標準偏差: {np.std(data)}\")\n\n\n\n14.1.2 Pandas - データ操作と分析\n\n# サンプルデータの作成\nprint(\"=== Pandas基本操作 ===\")\n\n# DataFrame の作成\nsales_data = {\n    '日付': pd.date_range('2024-01-01', periods=10, freq='D'),\n    '売上': [120, 150, 98, 200, 175, 160, 210, 185, 145, 190],\n    '商品': ['A', 'B', 'A', 'C', 'B', 'A', 'C', 'B', 'A', 'C'],\n    '地域': ['東京', '大阪', '東京', '福岡', '大阪', '東京', '福岡', '大阪', '東京', '福岡']\n}\n\ndf = pd.DataFrame(sales_data)\nprint(\"売上データ:\")\nprint(df)\n\n# 基本的な統計情報\nprint(f\"\\n基本統計:\")\nprint(df.describe())\n\n# グループ化と集計\nprint(f\"\\n商品別売上:\")\nproduct_sales = df.groupby('商品')['売上'].agg(['sum', 'mean', 'count'])\nprint(product_sales)\n\nprint(f\"\\n地域別売上:\")\nregion_sales = df.groupby('地域')['売上'].sum().sort_values(ascending=False)\nprint(region_sales)\n\n# データフィルタリング\nhigh_sales = df[df['売上'] &gt; 150]\nprint(f\"\\n高売上データ (&gt;150):\")\nprint(high_sales)\n\n\n\n14.1.3 データ可視化\n\n# matplotlib と seaborn を使った可視化\nprint(\"=== データ可視化 ===\")\n\n# 図のサイズとスタイルを設定\nplt.style.use('seaborn-v0_8')\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# 1. 売上の時系列グラフ\naxes[0, 0].plot(df['日付'], df['売上'], marker='o', linewidth=2)\naxes[0, 0].set_title('日別売上推移')\naxes[0, 0].set_xlabel('日付')\naxes[0, 0].set_ylabel('売上')\naxes[0, 0].tick_params(axis='x', rotation=45)\n\n# 2. 商品別売上の棒グラフ\nproduct_totals = df.groupby('商品')['売上'].sum()\naxes[0, 1].bar(product_totals.index, product_totals.values, color=['skyblue', 'lightgreen', 'lightcoral'])\naxes[0, 1].set_title('商品別総売上')\naxes[0, 1].set_xlabel('商品')\naxes[0, 1].set_ylabel('総売上')\n\n# 3. 地域別売上の円グラフ\nregion_totals = df.groupby('地域')['売上'].sum()\naxes[1, 0].pie(region_totals.values, labels=region_totals.index, autopct='%1.1f%%', startangle=90)\naxes[1, 0].set_title('地域別売上割合')\n\n# 4. 売上分布のヒストグラム\naxes[1, 1].hist(df['売上'], bins=6, color='orange', alpha=0.7, edgecolor='black')\naxes[1, 1].set_title('売上分布')\naxes[1, 1].set_xlabel('売上')\naxes[1, 1].set_ylabel('頻度')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"グラフを表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#実際のデータ分析プロジェクト",
    "href": "book/14-data-science.html#実際のデータ分析プロジェクト",
    "title": "14  データサイエンスとPython",
    "section": "14.2 実際のデータ分析プロジェクト",
    "text": "14.2 実際のデータ分析プロジェクト\n\n14.2.1 顧客データ分析\n\n# 模擬顧客データの作成\nnp.random.seed(42)\n\ncustomer_data = {\n    '顧客ID': range(1, 1001),\n    '年齢': np.random.normal(40, 15, 1000).astype(int),\n    '年収': np.random.normal(500, 150, 1000).astype(int),\n    '購入金額': np.random.normal(100, 30, 1000),\n    '購入回数': np.random.poisson(3, 1000),\n    '性別': np.random.choice(['男性', '女性'], 1000),\n    '地域': np.random.choice(['東京', '大阪', '名古屋', '福岡'], 1000, p=[0.4, 0.3, 0.2, 0.1])\n}\n\n# 年齢を現実的な範囲に調整\ncustomer_data['年齢'] = np.clip(customer_data['年齢'], 18, 80)\ncustomer_data['年収'] = np.clip(customer_data['年収'], 200, 1500)\ncustomer_data['購入金額'] = np.clip(customer_data['購入金額'], 10, 500)\n\ncustomers_df = pd.DataFrame(customer_data)\n\nprint(\"=== 顧客データ分析 ===\")\nprint(f\"データ形状: {customers_df.shape}\")\nprint(f\"\\n最初の5行:\")\nprint(customers_df.head())\n\n# データの基本統計\nprint(f\"\\n基本統計情報:\")\nprint(customers_df.describe())\n\n# 性別別分析\nprint(f\"\\n性別別統計:\")\ngender_stats = customers_df.groupby('性別').agg({\n    '年齢': ['mean', 'std'],\n    '年収': ['mean', 'std'], \n    '購入金額': ['mean', 'std'],\n    '購入回数': ['mean', 'std']\n}).round(2)\nprint(gender_stats)\n\n# 地域別分析\nprint(f\"\\n地域別統計:\")\nregion_stats = customers_df.groupby('地域').agg({\n    '購入金額': ['count', 'mean', 'sum'],\n    '購入回数': 'mean'\n}).round(2)\nprint(region_stats)\n\n\n\n14.2.2 相関分析と機械学習の基礎\n\n# 相関分析\nprint(\"=== 相関分析 ===\")\n\n# 数値データの相関マトリックス\nnumeric_columns = ['年齢', '年収', '購入金額', '購入回数']\ncorrelation_matrix = customers_df[numeric_columns].corr()\n\nprint(\"相関マトリックス:\")\nprint(correlation_matrix.round(3))\n\n# 可視化\nplt.figure(figsize=(10, 8))\n\n# 相関マトリックスのヒートマップ\nplt.subplot(2, 2, 1)\nsns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)\nplt.title('変数間の相関')\n\n# 年収と購入金額の散布図\nplt.subplot(2, 2, 2)\nplt.scatter(customers_df['年収'], customers_df['購入金額'], alpha=0.6)\nplt.xlabel('年収')\nplt.ylabel('購入金額')\nplt.title('年収 vs 購入金額')\n\n# 年齢別購入金額の箱ひげ図\nplt.subplot(2, 2, 3)\nage_groups = pd.cut(customers_df['年齢'], bins=[0, 30, 50, 100], labels=['若年', '中年', 'シニア'])\ncustomers_df['年齢層'] = age_groups\nsns.boxplot(data=customers_df, x='年齢層', y='購入金額')\nplt.title('年齢層別購入金額分布')\n\n# 地域別購入金額の棒グラフ\nplt.subplot(2, 2, 4)\nregion_avg = customers_df.groupby('地域')['購入金額'].mean().sort_values(ascending=False)\nplt.bar(region_avg.index, region_avg.values, color=['red', 'blue', 'green', 'orange'])\nplt.title('地域別平均購入金額')\nplt.ylabel('平均購入金額')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"相関分析の可視化を表示しました\")\n\n\n\n14.2.3 機械学習入門\n\n# 簡単な機械学習の例（線形回帰）\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\n\nprint(\"=== 機械学習入門 ===\")\n\n# 特徴量とターゲットの準備\nX = customers_df[['年齢', '年収', '購入回数']]  # 特徴量\ny = customers_df['購入金額']  # 予測対象\n\n# データを訓練用とテスト用に分割\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 線形回帰モデルの作成と訓練\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# 予測の実行\ny_pred = model.predict(X_test)\n\n# モデルの評価\nmse = mean_squared_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\n\nprint(f\"モデル評価:\")\nprint(f\"平均二乗誤差 (MSE): {mse:.2f}\")\nprint(f\"決定係数 (R²): {r2:.3f}\")\n\n# 特徴量の重要度\nfeature_importance = pd.DataFrame({\n    '特徴量': X.columns,\n    '係数': model.coef_,\n    '重要度': np.abs(model.coef_)\n}).sort_values('重要度', ascending=False)\n\nprint(f\"\\n特徴量の重要度:\")\nprint(feature_importance)\n\n# 予測結果の可視化\nplt.figure(figsize=(10, 6))\n\nplt.subplot(1, 2, 1)\nplt.scatter(y_test, y_pred, alpha=0.6)\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)\nplt.xlabel('実際の購入金額')\nplt.ylabel('予測購入金額')\nplt.title(f'予測精度 (R² = {r2:.3f})')\n\nplt.subplot(1, 2, 2)\nresiduals = y_test - y_pred\nplt.scatter(y_pred, residuals, alpha=0.6)\nplt.axhline(y=0, color='r', linestyle='--')\nplt.xlabel('予測値')\nplt.ylabel('残差')\nplt.title('残差プロット')\n\nplt.tight_layout()\nplt.show()\n\nprint(\"機械学習結果の可視化を表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#時系列データ分析",
    "href": "book/14-data-science.html#時系列データ分析",
    "title": "14  データサイエンスとPython",
    "section": "14.3 時系列データ分析",
    "text": "14.3 時系列データ分析\n\n14.3.1 トレンド分析と予測\n\n# 時系列データの作成\nprint(\"=== 時系列データ分析 ===\")\n\n# 月次売上データを作成\ndate_range = pd.date_range('2022-01-01', '2024-12-31', freq='M')\nnp.random.seed(42)\n\n# トレンドとノイズを含む売上データ\ntrend = np.linspace(1000, 1500, len(date_range))\nseasonal = 200 * np.sin(2 * np.pi * np.arange(len(date_range)) / 12)\nnoise = np.random.normal(0, 50, len(date_range))\nsales = trend + seasonal + noise\n\ntime_series_df = pd.DataFrame({\n    '日付': date_range,\n    '売上': sales\n})\n\nprint(f\"時系列データ形状: {time_series_df.shape}\")\nprint(f\"期間: {time_series_df['日付'].min()} から {time_series_df['日付'].max()}\")\n\n# 基本統計\nprint(f\"\\n売上統計:\")\nprint(f\"平均: {time_series_df['売上'].mean():.2f}\")\nprint(f\"最小: {time_series_df['売上'].min():.2f}\")\nprint(f\"最大: {time_series_df['売上'].max():.2f}\")\n\n# 移動平均の計算\ntime_series_df['移動平均_3M'] = time_series_df['売上'].rolling(window=3).mean()\ntime_series_df['移動平均_12M'] = time_series_df['売上'].rolling(window=12).mean()\n\n# 前年同月比の計算\ntime_series_df['前年同月比'] = time_series_df['売上'].pct_change(periods=12) * 100\n\n# 時系列の可視化\nplt.figure(figsize=(15, 10))\n\n# 売上推移\nplt.subplot(3, 1, 1)\nplt.plot(time_series_df['日付'], time_series_df['売上'], label='実際の売上', alpha=0.7)\nplt.plot(time_series_df['日付'], time_series_df['移動平均_3M'], label='3か月移動平均', linewidth=2)\nplt.plot(time_series_df['日付'], time_series_df['移動平均_12M'], label='12か月移動平均', linewidth=2)\nplt.title('月次売上推移')\nplt.ylabel('売上')\nplt.legend()\nplt.grid(True, alpha=0.3)\n\n# 季節性の分析\nplt.subplot(3, 1, 2)\nmonthly_avg = time_series_df.groupby(time_series_df['日付'].dt.month)['売上'].mean()\nplt.bar(monthly_avg.index, monthly_avg.values, color='lightblue', edgecolor='navy')\nplt.title('月別平均売上（季節性）')\nplt.xlabel('月')\nplt.ylabel('平均売上')\nplt.xticks(range(1, 13))\nplt.grid(True, alpha=0.3)\n\n# 前年同月比\nplt.subplot(3, 1, 3)\nplt.plot(time_series_df['日付'], time_series_df['前年同月比'], marker='o', linewidth=2, color='green')\nplt.axhline(y=0, color='red', linestyle='--', alpha=0.7)\nplt.title('前年同月比')\nplt.xlabel('日付')\nplt.ylabel('成長率 (%)')\nplt.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n\nprint(\"時系列分析の可視化を表示しました\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/14-data-science.html#データサイエンスプロジェクトの実践例",
    "href": "book/14-data-science.html#データサイエンスプロジェクトの実践例",
    "title": "14  データサイエンスとPython",
    "section": "14.4 データサイエンスプロジェクトの実践例",
    "text": "14.4 データサイエンスプロジェクトの実践例\n\n14.4.1 A/Bテスト分析\n\n# A/Bテストのシミュレーション\nprint(\"=== A/Bテスト分析 ===\")\n\nnp.random.seed(42)\n\n# A/Bテストデータの作成\nn_users_a = 1000\nn_users_b = 1000\n\n# グループAとBのコンバージョン率\nconversion_rate_a = 0.12  # 12%\nconversion_rate_b = 0.15  # 15%\n\n# テストデータ生成\ngroup_a = np.random.binomial(1, conversion_rate_a, n_users_a)\ngroup_b = np.random.binomial(1, conversion_rate_b, n_users_b)\n\nab_test_df = pd.DataFrame({\n    'グループ': ['A'] * n_users_a + ['B'] * n_users_b,\n    'コンバージョン': np.concatenate([group_a, group_b])\n})\n\n# 基本統計\nresults = ab_test_df.groupby('グループ')['コンバージョン'].agg(['count', 'sum', 'mean']).round(4)\nresults.columns = ['ユーザー数', 'コンバージョン数', 'コンバージョン率']\n\nprint(\"A/Bテスト結果:\")\nprint(results)\n\n# 統計的有意性検定（カイ二乗検定）\nfrom scipy.stats import chi2_contingency\n\ncontingency_table = pd.crosstab(ab_test_df['グループ'], ab_test_df['コンバージョン'])\nchi2, p_value, dof, expected = chi2_contingency(contingency_table)\n\nprint(f\"\\n統計的検定結果:\")\nprint(f\"カイ二乗統計量: {chi2:.4f}\")\nprint(f\"p値: {p_value:.4f}\")\nprint(f\"有意水準0.05で{'有意' if p_value &lt; 0.05 else '有意でない'}な差\")\n\n# 効果の可視化\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nconversion_rates = results['コンバージョン率']\ncolors = ['lightblue', 'lightgreen']\nbars = plt.bar(conversion_rates.index, conversion_rates.values, color=colors, edgecolor='navy')\nplt.title('グループ別コンバージョン率')\nplt.ylabel('コンバージョン率')\nplt.ylim(0, max(conversion_rates.values) * 1.2)\n\n# 数値をバーの上に表示\nfor bar, rate in zip(bars, conversion_rates.values):\n    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.005, \n             f'{rate:.1%}', ha='center', va='bottom', fontweight='bold')\n\nplt.subplot(1, 2, 2)\nimprovement = (results.loc['B', 'コンバージョン率'] - results.loc['A', 'コンバージョン率']) / results.loc['A', 'コンバージョン率'] * 100\nplt.bar(['改善率'], [improvement], color='orange', edgecolor='red')\nplt.title(f'グループBの改善率')\nplt.ylabel('改善率 (%)')\nplt.text(0, improvement + 1, f'{improvement:.1f}%', ha='center', va='bottom', fontweight='bold')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"グループBはグループAより{improvement:.1f}%改善\")\n\n\n\n14.4.2 コホート分析\n\n# コホート分析（顧客のリテンション分析）\nprint(\"=== コホート分析 ===\")\n\n# サンプルデータの作成\nnp.random.seed(42)\n\n# 顧客の初回購入月と再購入データを生成\ncohort_data = []\nfor month in range(12):  # 12か月分\n    n_customers = np.random.randint(80, 120)  # 月ごとの新規顧客数\n    \n    for customer in range(n_customers):\n        customer_id = f\"C{month:02d}_{customer:03d}\"\n        first_purchase = pd.Timestamp('2024-01-01') + pd.DateOffset(months=month)\n        \n        # リテンション率をシミュレート（月が経つにつれて減少）\n        for future_month in range(6):  # 6か月先まで追跡\n            retention_prob = 0.8 * (0.85 ** future_month)  # 指数的減衰\n            if np.random.random() &lt; retention_prob:\n                purchase_date = first_purchase + pd.DateOffset(months=future_month)\n                cohort_data.append({\n                    '顧客ID': customer_id,\n                    '初回購入月': first_purchase,\n                    '購入月': purchase_date,\n                    '経過月数': future_month\n                })\n\ncohort_df = pd.DataFrame(cohort_data)\n\n# コホートテーブルの作成\ncohort_table = cohort_df.pivot_table(\n    index='初回購入月',\n    columns='経過月数', \n    values='顧客ID',\n    aggfunc='nunique'\n).fillna(0)\n\n# リテンション率の計算\ncohort_sizes = cohort_df.groupby('初回購入月')['顧客ID'].nunique()\nretention_table = cohort_table.divide(cohort_sizes, axis=0)\n\nprint(\"コホートリテンション率:\")\nprint(retention_table.round(3))\n\n# 可視化\nplt.figure(figsize=(15, 8))\n\nplt.subplot(2, 1, 1)\nsns.heatmap(retention_table, annot=True, fmt='.2%', cmap='YlOrRd', cbar_kws={'label': 'リテンション率'})\nplt.title('コホート別リテンション率')\nplt.ylabel('初回購入月')\nplt.xlabel('経過月数')\n\nplt.subplot(2, 1, 2)\navg_retention = retention_table.mean()\nplt.plot(avg_retention.index, avg_retention.values, marker='o', linewidth=3, markersize=8)\nplt.title('平均リテンション率の推移')\nplt.xlabel('経過月数')\nplt.ylabel('平均リテンション率')\nplt.grid(True, alpha=0.3)\nplt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: '{:.0%}'.format(y)))\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"平均リテンション率:\")\nfor month, rate in avg_retention.items():\n    print(f\"  {month}か月後: {rate:.1%}\")\n\nこの章では、Pythonを使ったデータサイエンスの基本から実践的な分析手法まで学習しました。NumPy、Pandas、Matplotlibなどの主要ライブラリを活用することで、データの収集、処理、分析、可視化を効率的に行うことができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>データサイエンスとPython</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html",
    "href": "book/15-applications.html",
    "title": "15  実践的なPythonアプリケーション",
    "section": "",
    "text": "15.1 タスク管理システム\nPythonの豊富なライブラリエコシステムを活用して、実際のビジネスや日常生活で役立つアプリケーションを構築する方法を学習します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#タスク管理システム",
    "href": "book/15-applications.html#タスク管理システム",
    "title": "15  実践的なPythonアプリケーション",
    "section": "",
    "text": "15.1.1 完全機能のタスクマネージャー\n\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Optional\nfrom enum import Enum\nimport json\n\nclass Priority(Enum):\n    \"\"\"タスクの優先度\"\"\"\n    LOW = \"低\"\n    MEDIUM = \"中\"\n    HIGH = \"高\"\n    URGENT = \"緊急\"\n\nclass Status(Enum):\n    \"\"\"タスクのステータス\"\"\"\n    TODO = \"未着手\"\n    IN_PROGRESS = \"進行中\"\n    COMPLETED = \"完了\"\n    CANCELLED = \"キャンセル\"\n\nclass Task:\n    \"\"\"個別タスククラス\"\"\"\n    \n    def __init__(self, title: str, description: str = \"\", priority: Priority = Priority.MEDIUM):\n        self.id = id(self)  # 簡易ID\n        self.title = title\n        self.description = description\n        self.priority = priority\n        self.status = Status.TODO\n        self.created_at = datetime.now()\n        self.updated_at = datetime.now()\n        self.due_date: Optional[datetime] = None\n        self.completed_at: Optional[datetime] = None\n        self.tags: List[str] = []\n    \n    def set_due_date(self, due_date: datetime):\n        \"\"\"期限を設定\"\"\"\n        self.due_date = due_date\n        self.updated_at = datetime.now()\n    \n    def add_tag(self, tag: str):\n        \"\"\"タグを追加\"\"\"\n        if tag not in self.tags:\n            self.tags.append(tag)\n            self.updated_at = datetime.now()\n    \n    def remove_tag(self, tag: str):\n        \"\"\"タグを削除\"\"\"\n        if tag in self.tags:\n            self.tags.remove(tag)\n            self.updated_at = datetime.now()\n    \n    def update_status(self, status: Status):\n        \"\"\"ステータスを更新\"\"\"\n        self.status = status\n        self.updated_at = datetime.now()\n        \n        if status == Status.COMPLETED:\n            self.completed_at = datetime.now()\n        elif self.completed_at:\n            self.completed_at = None\n    \n    def is_overdue(self) -&gt; bool:\n        \"\"\"期限切れかチェック\"\"\"\n        if not self.due_date or self.status == Status.COMPLETED:\n            return False\n        return datetime.now() &gt; self.due_date\n    \n    def days_until_due(self) -&gt; Optional[int]:\n        \"\"\"期限までの日数\"\"\"\n        if not self.due_date:\n            return None\n        delta = self.due_date - datetime.now()\n        return delta.days\n    \n    def to_dict(self) -&gt; Dict:\n        \"\"\"辞書形式に変換\"\"\"\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority.value,\n            \"status\": self.status.value,\n            \"created_at\": self.created_at.isoformat(),\n            \"updated_at\": self.updated_at.isoformat(),\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n    \n    def __str__(self):\n        status_icon = {\n            Status.TODO: \"⏳\",\n            Status.IN_PROGRESS: \"🔄\", \n            Status.COMPLETED: \"✅\",\n            Status.CANCELLED: \"❌\"\n        }\n        \n        priority_icon = {\n            Priority.LOW: \"🔵\",\n            Priority.MEDIUM: \"🟡\",\n            Priority.HIGH: \"🟠\", \n            Priority.URGENT: \"🔴\"\n        }\n        \n        due_info = \"\"\n        if self.due_date:\n            days = self.days_until_due()\n            if days is not None:\n                if days &lt; 0:\n                    due_info = f\" (期限切れ: {abs(days)}日)\"\n                elif days == 0:\n                    due_info = \" (今日が期限)\"\n                else:\n                    due_info = f\" (あと{days}日)\"\n        \n        return f\"{status_icon[self.status]} {priority_icon[self.priority]} {self.title}{due_info}\"\n\nclass TaskManager:\n    \"\"\"タスク管理システム\"\"\"\n    \n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def create_task(self, title: str, description: str = \"\", priority: Priority = Priority.MEDIUM) -&gt; Task:\n        \"\"\"新しいタスクを作成\"\"\"\n        task = Task(title, description, priority)\n        self.tasks.append(task)\n        print(f\"✅ タスクを作成しました: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -&gt; Optional[Task]:\n        \"\"\"IDでタスクを取得\"\"\"\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def delete_task(self, task_id: int) -&gt; bool:\n        \"\"\"タスクを削除\"\"\"\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            print(f\"🗑️ タスクを削除しました: {task.title}\")\n            return True\n        return False\n    \n    def list_tasks(self, status_filter: Optional[Status] = None, priority_filter: Optional[Priority] = None) -&gt; List[Task]:\n        \"\"\"タスク一覧を取得\"\"\"\n        filtered_tasks = self.tasks\n        \n        if status_filter:\n            filtered_tasks = [t for t in filtered_tasks if t.status == status_filter]\n        \n        if priority_filter:\n            filtered_tasks = [t for t in filtered_tasks if t.priority == priority_filter]\n        \n        # 優先度とステータスでソート\n        priority_order = {Priority.URGENT: 0, Priority.HIGH: 1, Priority.MEDIUM: 2, Priority.LOW: 3}\n        status_order = {Status.IN_PROGRESS: 0, Status.TODO: 1, Status.COMPLETED: 2, Status.CANCELLED: 3}\n        \n        return sorted(filtered_tasks, key=lambda t: (status_order[t.status], priority_order[t.priority]))\n    \n    def get_overdue_tasks(self) -&gt; List[Task]:\n        \"\"\"期限切れタスクを取得\"\"\"\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def get_upcoming_tasks(self, days: int = 7) -&gt; List[Task]:\n        \"\"\"指定日数以内に期限が来るタスクを取得\"\"\"\n        upcoming = []\n        for task in self.tasks:\n            if task.due_date and task.status != Status.COMPLETED:\n                days_until = task.days_until_due()\n                if days_until is not None and 0 &lt;= days_until &lt;= days:\n                    upcoming.append(task)\n        return sorted(upcoming, key=lambda t: t.due_date)\n    \n    def get_statistics(self) -&gt; Dict:\n        \"\"\"統計情報を取得\"\"\"\n        total = len(self.tasks)\n        if total == 0:\n            return {\"message\": \"タスクがありません\"}\n        \n        completed = len([t for t in self.tasks if t.status == Status.COMPLETED])\n        in_progress = len([t for t in self.tasks if t.status == Status.IN_PROGRESS])\n        overdue = len(self.get_overdue_tasks())\n        \n        return {\n            \"総タスク数\": total,\n            \"完了済み\": completed,\n            \"進行中\": in_progress,\n            \"期限切れ\": overdue,\n            \"完了率\": f\"{(completed/total*100):.1f}%\" if total &gt; 0 else \"0%\"\n        }\n    \n    def export_to_json(self, filename: str):\n        \"\"\"JSONファイルにエクスポート\"\"\"\n        data = [task.to_dict() for task in self.tasks]\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n        print(f\"📄 {filename}にエクスポートしました\")\n\n# タスク管理システムのデモ\ndef demo_task_manager():\n    \"\"\"タスク管理システムのデモンストレーション\"\"\"\n    print(\"=== タスク管理システムデモ ===\")\n    \n    # タスクマネージャーを作成\n    tm = TaskManager()\n    \n    # サンプルタスクを作成\n    task1 = tm.create_task(\"プレゼン資料作成\", \"来週の会議用資料\", Priority.HIGH)\n    task2 = tm.create_task(\"買い物\", \"食材と日用品\", Priority.LOW)\n    task3 = tm.create_task(\"レポート提出\", \"月次売上レポート\", Priority.URGENT)\n    task4 = tm.create_task(\"システム更新\", \"セキュリティパッチ適用\", Priority.MEDIUM)\n    \n    # 期限を設定\n    task1.set_due_date(datetime.now() + timedelta(days=3))\n    task2.set_due_date(datetime.now() + timedelta(days=1))\n    task3.set_due_date(datetime.now() + timedelta(days=-1))  # 期限切れ\n    task4.set_due_date(datetime.now() + timedelta(days=7))\n    \n    # タグを追加\n    task1.add_tag(\"仕事\")\n    task1.add_tag(\"プレゼン\")\n    task2.add_tag(\"個人\")\n    task3.add_tag(\"仕事\")\n    task3.add_tag(\"緊急\")\n    task4.add_tag(\"IT\")\n    \n    # いくつかのタスクのステータスを更新\n    task2.update_status(Status.IN_PROGRESS)\n    task4.update_status(Status.COMPLETED)\n    \n    print(f\"\\n📋 全タスク一覧:\")\n    for task in tm.list_tasks():\n        print(f\"  {task}\")\n    \n    print(f\"\\n⚠️ 期限切れタスク:\")\n    for task in tm.get_overdue_tasks():\n        print(f\"  {task}\")\n    \n    print(f\"\\n📅 今後7日間の期限タスク:\")\n    for task in tm.get_upcoming_tasks(7):\n        print(f\"  {task}\")\n    \n    print(f\"\\n📊 統計情報:\")\n    stats = tm.get_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n\n# 実行\ndemo_task_manager()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#ファイル管理システム",
    "href": "book/15-applications.html#ファイル管理システム",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.2 ファイル管理システム",
    "text": "15.2 ファイル管理システム\n\n15.2.1 自動ファイル整理ツール\n\nimport os\nimport shutil\nfrom pathlib import Path\nfrom collections import defaultdict\nimport mimetypes\n\nclass FileOrganizer:\n    \"\"\"ファイル自動整理クラス\"\"\"\n    \n    def __init__(self, source_directory: str):\n        self.source_dir = Path(source_directory)\n        self.file_types = {\n            'images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'],\n            'documents': ['.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt'],\n            'spreadsheets': ['.xls', '.xlsx', '.csv', '.ods'],\n            'presentations': ['.ppt', '.pptx', '.odp'],\n            'videos': ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'],\n            'audio': ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a'],\n            'archives': ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2'],\n            'code': ['.py', '.js', '.html', '.css', '.java', '.cpp', '.c', '.php'],\n            'executables': ['.exe', '.msi', '.deb', '.rpm', '.dmg', '.app']\n        }\n        \n        self.stats = defaultdict(int)\n    \n    def get_file_category(self, file_path: Path) -&gt; str:\n        \"\"\"ファイルのカテゴリを判定\"\"\"\n        extension = file_path.suffix.lower()\n        \n        for category, extensions in self.file_types.items():\n            if extension in extensions:\n                return category\n        \n        return 'others'\n    \n    def create_directory_structure(self, target_dir: Path):\n        \"\"\"整理用ディレクトリ構造を作成\"\"\"\n        categories = list(self.file_types.keys()) + ['others']\n        \n        for category in categories:\n            category_dir = target_dir / category\n            category_dir.mkdir(parents=True, exist_ok=True)\n        \n        print(f\"📁 ディレクトリ構造を作成しました: {target_dir}\")\n    \n    def organize_files(self, target_directory: str, copy_mode: bool = True):\n        \"\"\"ファイルを整理\"\"\"\n        target_dir = Path(target_directory)\n        \n        if not self.source_dir.exists():\n            print(f\"❌ ソースディレクトリが存在しません: {self.source_dir}\")\n            return\n        \n        # ターゲットディレクトリを作成\n        target_dir.mkdir(parents=True, exist_ok=True)\n        self.create_directory_structure(target_dir)\n        \n        print(f\"🔄 ファイル整理開始...\")\n        print(f\"  ソース: {self.source_dir}\")\n        print(f\"  ターゲット: {target_dir}\")\n        print(f\"  モード: {'コピー' if copy_mode else '移動'}\")\n        \n        # ファイルを処理\n        for file_path in self.source_dir.rglob('*'):\n            if file_path.is_file():\n                self._process_file(file_path, target_dir, copy_mode)\n        \n        self._print_statistics()\n    \n    def _process_file(self, file_path: Path, target_dir: Path, copy_mode: bool):\n        \"\"\"個別ファイルを処理\"\"\"\n        category = self.get_file_category(file_path)\n        category_dir = target_dir / category\n        \n        # 同名ファイルがある場合の処理\n        target_file = category_dir / file_path.name\n        counter = 1\n        while target_file.exists():\n            name_parts = file_path.stem, counter, file_path.suffix\n            target_file = category_dir / f\"{name_parts[0]}_{name_parts[1]}{name_parts[2]}\"\n            counter += 1\n        \n        try:\n            if copy_mode:\n                shutil.copy2(file_path, target_file)\n                action = \"コピー\"\n            else:\n                shutil.move(str(file_path), str(target_file))\n                action = \"移動\"\n            \n            self.stats[category] += 1\n            self.stats['total'] += 1\n            \n            print(f\"  ✅ {action}: {file_path.name} → {category}/\")\n            \n        except Exception as e:\n            print(f\"  ❌ エラー: {file_path.name} - {e}\")\n            self.stats['errors'] += 1\n    \n    def _print_statistics(self):\n        \"\"\"統計情報を表示\"\"\"\n        print(f\"\\n📊 整理結果:\")\n        print(f\"  総ファイル数: {self.stats['total']}\")\n        \n        for category in self.file_types.keys():\n            if self.stats[category] &gt; 0:\n                print(f\"  {category}: {self.stats[category]}ファイル\")\n        \n        if self.stats['others'] &gt; 0:\n            print(f\"  その他: {self.stats['others']}ファイル\")\n        \n        if self.stats['errors'] &gt; 0:\n            print(f\"  エラー: {self.stats['errors']}ファイル\")\n    \n    def analyze_directory(self) -&gt; Dict:\n        \"\"\"ディレクトリを分析\"\"\"\n        if not self.source_dir.exists():\n            return {\"error\": \"ディレクトリが存在しません\"}\n        \n        analysis = {\n            'total_files': 0,\n            'total_size': 0,\n            'categories': defaultdict(list),\n            'largest_files': [],\n            'file_extensions': defaultdict(int)\n        }\n        \n        all_files = []\n        \n        for file_path in self.source_dir.rglob('*'):\n            if file_path.is_file():\n                file_size = file_path.stat().st_size\n                category = self.get_file_category(file_path)\n                extension = file_path.suffix.lower()\n                \n                analysis['total_files'] += 1\n                analysis['total_size'] += file_size\n                analysis['categories'][category].append({\n                    'name': file_path.name,\n                    'size': file_size,\n                    'path': str(file_path)\n                })\n                analysis['file_extensions'][extension] += 1\n                \n                all_files.append((file_path, file_size))\n        \n        # 最大ファイルトップ5\n        all_files.sort(key=lambda x: x[1], reverse=True)\n        analysis['largest_files'] = [\n            {'name': f.name, 'size': s, 'size_mb': s/(1024*1024)}\n            for f, s in all_files[:5]\n        ]\n        \n        return dict(analysis)\n\n# ファイル整理システムのデモ\ndef demo_file_organizer():\n    \"\"\"ファイル整理システムのデモ\"\"\"\n    print(\"=== ファイル整理システムデモ ===\")\n    \n    # テスト用のファイル構造を作成（シミュレーション）\n    test_files = [\n        \"report.pdf\", \"presentation.pptx\", \"photo1.jpg\", \"photo2.png\",\n        \"music.mp3\", \"video.mp4\", \"script.py\", \"data.csv\", \n        \"archive.zip\", \"document.docx\", \"image.gif\", \"code.js\"\n    ]\n    \n    print(f\"📁 テストファイル構造:\")\n    for file in test_files:\n        print(f\"  📄 {file}\")\n    \n    # ファイル分析のシミュレーション\n    organizer = FileOrganizer(\"./test_directory\")\n    \n    # 各ファイルタイプの分析\n    print(f\"\\n🔍 ファイルタイプ分析:\")\n    category_counts = defaultdict(int)\n    \n    for file in test_files:\n        file_path = Path(file)\n        category = organizer.get_file_category(file_path)\n        category_counts[category] += 1\n    \n    for category, count in category_counts.items():\n        print(f\"  {category}: {count}ファイル\")\n    \n    print(f\"\\n📋 推奨整理構造:\")\n    for category in organizer.file_types.keys():\n        if category_counts[category] &gt; 0:\n            print(f\"  📁 {category}/ ({category_counts[category]}ファイル)\")\n    \n    if category_counts['others'] &gt; 0:\n        print(f\"  📁 others/ ({category_counts['others']}ファイル)\")\n\ndemo_file_organizer()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#webスクレイピングツール",
    "href": "book/15-applications.html#webスクレイピングツール",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.3 Webスクレイピングツール",
    "text": "15.3 Webスクレイピングツール\n\n15.3.1 自動データ収集システム\n\nimport requests\nfrom urllib.parse import urljoin, urlparse\nimport time\nimport csv\nfrom typing import List, Dict\nimport json\n\nclass WebScraper:\n    \"\"\"Webスクレイピングクラス\"\"\"\n    \n    def __init__(self, delay: float = 1.0):\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        })\n        self.delay = delay\n        self.scraped_data = []\n    \n    def get_page(self, url: str) -&gt; requests.Response:\n        \"\"\"ページを取得\"\"\"\n        try:\n            print(f\"🌐 取得中: {url}\")\n            response = self.session.get(url)\n            response.raise_for_status()\n            time.sleep(self.delay)  # レート制限\n            return response\n        except requests.RequestException as e:\n            print(f\"❌ エラー: {url} - {e}\")\n            raise\n    \n    def extract_text_content(self, html: str, selectors: List[str]) -&gt; Dict[str, str]:\n        \"\"\"HTMLからテキストコンテンツを抽出（BeautifulSoupの代替として簡略化）\"\"\"\n        # 実際の実装ではBeautifulSoupを使用\n        # ここでは簡略化したデモ用の実装\n        extracted = {}\n        \n        # 模擬的な抽出（実際にはHTML解析が必要）\n        for selector in selectors:\n            if selector == 'title':\n                extracted['title'] = f\"サンプルタイトル from {html[:20]}...\"\n            elif selector == 'price':\n                extracted['price'] = \"¥1,000\"\n            elif selector == 'description':\n                extracted['description'] = \"サンプル商品説明\"\n        \n        return extracted\n    \n    def scrape_product_data(self, urls: List[str]) -&gt; List[Dict]:\n        \"\"\"商品データをスクレイピング\"\"\"\n        print(f\"🛒 商品データスクレイピング開始 ({len(urls)}件)\")\n        \n        products = []\n        selectors = ['title', 'price', 'description']\n        \n        for i, url in enumerate(urls, 1):\n            try:\n                print(f\"進捗: {i}/{len(urls)}\")\n                \n                # ページを取得（実際の実装）\n                # response = self.get_page(url)\n                # extracted = self.extract_text_content(response.text, selectors)\n                \n                # デモ用の模擬データ\n                extracted = {\n                    'url': url,\n                    'title': f\"商品 {i}\",\n                    'price': f\"¥{1000 + i * 100:,}\",\n                    'description': f\"高品質な商品{i}の詳細説明\",\n                    'scraped_at': time.strftime('%Y-%m-%d %H:%M:%S')\n                }\n                \n                products.append(extracted)\n                print(f\"  ✅ {extracted['title']} - {extracted['price']}\")\n                \n                # レート制限\n                time.sleep(self.delay)\n                \n            except Exception as e:\n                print(f\"  ❌ スキップ: {url} - {e}\")\n                continue\n        \n        self.scraped_data = products\n        print(f\"✨ スクレイピング完了: {len(products)}件\")\n        return products\n    \n    def save_to_csv(self, filename: str):\n        \"\"\"CSVファイルに保存\"\"\"\n        if not self.scraped_data:\n            print(\"❌ 保存するデータがありません\")\n            return\n        \n        with open(filename, 'w', newline='', encoding='utf-8') as f:\n            writer = csv.DictWriter(f, fieldnames=self.scraped_data[0].keys())\n            writer.writeheader()\n            writer.writerows(self.scraped_data)\n        \n        print(f\"💾 {filename}に保存しました ({len(self.scraped_data)}件)\")\n    \n    def save_to_json(self, filename: str):\n        \"\"\"JSONファイルに保存\"\"\"\n        if not self.scraped_data:\n            print(\"❌ 保存するデータがありません\")\n            return\n        \n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(self.scraped_data, f, ensure_ascii=False, indent=2)\n        \n        print(f\"💾 {filename}に保存しました ({len(self.scraped_data)}件)\")\n    \n    def get_statistics(self) -&gt; Dict:\n        \"\"\"統計情報を取得\"\"\"\n        if not self.scraped_data:\n            return {\"message\": \"データがありません\"}\n        \n        # 価格統計（¥記号と,を除去して数値化）\n        prices = []\n        for item in self.scraped_data:\n            try:\n                price_str = item['price'].replace('¥', '').replace(',', '')\n                prices.append(int(price_str))\n            except (ValueError, KeyError):\n                continue\n        \n        stats = {\n            \"総データ数\": len(self.scraped_data),\n            \"価格データ数\": len(prices)\n        }\n        \n        if prices:\n            stats.update({\n                \"平均価格\": f\"¥{sum(prices)//len(prices):,}\",\n                \"最低価格\": f\"¥{min(prices):,}\",\n                \"最高価格\": f\"¥{max(prices):,}\"\n            })\n        \n        return stats\n\n# ニュース記事スクレイパー\nclass NewsArticleScraper(WebScraper):\n    \"\"\"ニュース記事専用スクレイパー\"\"\"\n    \n    def scrape_news_articles(self, rss_urls: List[str]) -&gt; List[Dict]:\n        \"\"\"ニュース記事をスクレイピング\"\"\"\n        print(f\"📰 ニュース記事スクレイピング開始\")\n        \n        articles = []\n        \n        # デモ用の模擬記事データ\n        sample_articles = [\n            {\n                \"title\": \"Python 3.12の新機能発表\",\n                \"summary\": \"Pythonの最新バージョンに追加された新機能について\",\n                \"category\": \"テクノロジー\",\n                \"published_date\": \"2024-01-15\"\n            },\n            {\n                \"title\": \"AIとプログラミング教育の未来\", \n                \"summary\": \"人工知能技術がプログラミング教育に与える影響\",\n                \"category\": \"教育\",\n                \"published_date\": \"2024-01-14\"\n            },\n            {\n                \"title\": \"データサイエンス市場の成長\",\n                \"summary\": \"データサイエンス分野の市場規模と将来展望\",\n                \"category\": \"ビジネス\", \n                \"published_date\": \"2024-01-13\"\n            }\n        ]\n        \n        for i, article in enumerate(sample_articles, 1):\n            article['id'] = i\n            article['scraped_at'] = time.strftime('%Y-%m-%d %H:%M:%S')\n            articles.append(article)\n            print(f\"  📄 {article['title']}\")\n            time.sleep(0.5)  # デモ用の遅延\n        \n        self.scraped_data = articles\n        return articles\n    \n    def filter_by_category(self, category: str) -&gt; List[Dict]:\n        \"\"\"カテゴリでフィルタリング\"\"\"\n        return [article for article in self.scraped_data \n                if article.get('category') == category]\n    \n    def get_recent_articles(self, days: int = 7) -&gt; List[Dict]:\n        \"\"\"最近の記事を取得\"\"\"\n        # 簡略化: 全記事を返す\n        return self.scraped_data\n\n# Webスクレイピングデモ\ndef demo_web_scraping():\n    \"\"\"Webスクレイピングデモ\"\"\"\n    print(\"=== Webスクレイピングデモ ===\")\n    \n    # 1. 商品データスクレイピング\n    product_scraper = WebScraper(delay=0.5)\n    \n    sample_urls = [\n        \"https://example-shop.com/product1\",\n        \"https://example-shop.com/product2\", \n        \"https://example-shop.com/product3\",\n        \"https://example-shop.com/product4\"\n    ]\n    \n    products = product_scraper.scrape_product_data(sample_urls)\n    \n    print(f\"\\n📊 商品データ統計:\")\n    stats = product_scraper.get_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # 2. ニュース記事スクレイピング\n    print(f\"\\n\" + \"=\"*50)\n    \n    news_scraper = NewsArticleScraper(delay=0.3)\n    articles = news_scraper.scrape_news_articles([])\n    \n    print(f\"\\n📰 取得した記事:\")\n    for article in articles:\n        print(f\"  📄 [{article['category']}] {article['title']}\")\n        print(f\"      {article['summary']}\")\n        print(f\"      📅 {article['published_date']}\")\n        print()\n    \n    # カテゴリ別フィルタリング\n    tech_articles = news_scraper.filter_by_category(\"テクノロジー\")\n    print(f\"🔧 テクノロジー記事: {len(tech_articles)}件\")\n\ndemo_web_scraping()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/15-applications.html#システム監視ツール",
    "href": "book/15-applications.html#システム監視ツール",
    "title": "15  実践的なPythonアプリケーション",
    "section": "15.4 システム監視ツール",
    "text": "15.4 システム監視ツール\n\n15.4.1 パフォーマンス監視システム\n\nimport psutil\nimport time\nfrom datetime import datetime\nfrom typing import Dict, List\nimport json\n\nclass SystemMonitor:\n    \"\"\"システム監視クラス\"\"\"\n    \n    def __init__(self):\n        self.monitoring_data = []\n        self.alerts = []\n        self.thresholds = {\n            'cpu_percent': 80.0,\n            'memory_percent': 85.0,\n            'disk_percent': 90.0\n        }\n    \n    def get_system_info(self) -&gt; Dict:\n        \"\"\"システム基本情報を取得\"\"\"\n        info = {\n            'timestamp': datetime.now().isoformat(),\n            'cpu': {\n                'percent': psutil.cpu_percent(interval=1),\n                'count': psutil.cpu_count(),\n                'freq': psutil.cpu_freq()._asdict() if psutil.cpu_freq() else None\n            },\n            'memory': {\n                'total': psutil.virtual_memory().total,\n                'available': psutil.virtual_memory().available, \n                'percent': psutil.virtual_memory().percent,\n                'used': psutil.virtual_memory().used\n            },\n            'disk': {\n                'total': psutil.disk_usage('/').total,\n                'used': psutil.disk_usage('/').used,\n                'free': psutil.disk_usage('/').free,\n                'percent': psutil.disk_usage('/').percent\n            },\n            'network': psutil.net_io_counters()._asdict(),\n            'processes': len(psutil.pids())\n        }\n        \n        return info\n    \n    def format_bytes(self, bytes_value: int) -&gt; str:\n        \"\"\"バイト数を読みやすい形式に変換\"\"\"\n        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:\n            if bytes_value &lt; 1024.0:\n                return f\"{bytes_value:.2f} {unit}\"\n            bytes_value /= 1024.0\n        return f\"{bytes_value:.2f} PB\"\n    \n    def check_alerts(self, system_info: Dict):\n        \"\"\"アラートをチェック\"\"\"\n        alerts = []\n        \n        if system_info['cpu']['percent'] &gt; self.thresholds['cpu_percent']:\n            alerts.append({\n                'type': 'CPU',\n                'level': '警告',\n                'message': f\"CPU使用率が高いです: {system_info['cpu']['percent']:.1f}%\",\n                'timestamp': system_info['timestamp']\n            })\n        \n        if system_info['memory']['percent'] &gt; self.thresholds['memory_percent']:\n            alerts.append({\n                'type': 'Memory',\n                'level': '警告', \n                'message': f\"メモリ使用率が高いです: {system_info['memory']['percent']:.1f}%\",\n                'timestamp': system_info['timestamp']\n            })\n        \n        if system_info['disk']['percent'] &gt; self.thresholds['disk_percent']:\n            alerts.append({\n                'type': 'Disk',\n                'level': '警告',\n                'message': f\"ディスク使用率が高いです: {system_info['disk']['percent']:.1f}%\", \n                'timestamp': system_info['timestamp']\n            })\n        \n        self.alerts.extend(alerts)\n        return alerts\n    \n    def display_system_status(self):\n        \"\"\"システム状態を表示\"\"\"\n        info = self.get_system_info()\n        \n        print(f\"🖥️ システム監視レポート - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"{'='*60}\")\n        \n        # CPU情報\n        print(f\"💻 CPU\")\n        print(f\"  使用率: {info['cpu']['percent']:.1f}%\")\n        print(f\"  コア数: {info['cpu']['count']}\")\n        if info['cpu']['freq']:\n            print(f\"  周波数: {info['cpu']['freq']['current']:.0f} MHz\")\n        \n        # メモリ情報\n        print(f\"\\n🧠 メモリ\")\n        print(f\"  使用率: {info['memory']['percent']:.1f}%\")\n        print(f\"  総容量: {self.format_bytes(info['memory']['total'])}\")\n        print(f\"  使用量: {self.format_bytes(info['memory']['used'])}\")\n        print(f\"  利用可能: {self.format_bytes(info['memory']['available'])}\")\n        \n        # ディスク情報\n        print(f\"\\n💾 ディスク\")\n        print(f\"  使用率: {info['disk']['percent']:.1f}%\")\n        print(f\"  総容量: {self.format_bytes(info['disk']['total'])}\")\n        print(f\"  使用量: {self.format_bytes(info['disk']['used'])}\")\n        print(f\"  空き容量: {self.format_bytes(info['disk']['free'])}\")\n        \n        # ネットワーク情報\n        print(f\"\\n🌐 ネットワーク\")\n        print(f\"  送信: {self.format_bytes(info['network']['bytes_sent'])}\")\n        print(f\"  受信: {self.format_bytes(info['network']['bytes_recv'])}\")\n        \n        # プロセス情報\n        print(f\"\\n⚙️ プロセス数: {info['processes']}\")\n        \n        # アラートチェック\n        alerts = self.check_alerts(info)\n        if alerts:\n            print(f\"\\n⚠️ アラート:\")\n            for alert in alerts:\n                print(f\"  {alert['level']}: {alert['message']}\")\n        else:\n            print(f\"\\n✅ システム正常\")\n        \n        return info\n    \n    def monitor_continuous(self, duration: int = 60, interval: int = 5):\n        \"\"\"継続監視\"\"\"\n        print(f\"🔄 システム監視開始 (継続時間: {duration}秒, 間隔: {interval}秒)\")\n        \n        start_time = time.time()\n        iteration = 0\n        \n        while time.time() - start_time &lt; duration:\n            iteration += 1\n            print(f\"\\n--- 監視サイクル {iteration} ---\")\n            \n            system_info = self.display_system_status()\n            self.monitoring_data.append(system_info)\n            \n            # 次の監視まで待機\n            if time.time() - start_time &lt; duration:\n                print(f\"\\n⏳ {interval}秒後に次の監視...\")\n                time.sleep(interval)\n        \n        print(f\"\\n✅ 監視完了\")\n        self._generate_summary_report()\n    \n    def _generate_summary_report(self):\n        \"\"\"サマリーレポートを生成\"\"\"\n        if not self.monitoring_data:\n            return\n        \n        print(f\"\\n📊 監視サマリーレポート\")\n        print(f\"{'='*60}\")\n        print(f\"監視期間: {len(self.monitoring_data)} サイクル\")\n        \n        # CPU統計\n        cpu_usage = [data['cpu']['percent'] for data in self.monitoring_data]\n        print(f\"\\n💻 CPU使用率統計:\")\n        print(f\"  平均: {sum(cpu_usage)/len(cpu_usage):.1f}%\")\n        print(f\"  最大: {max(cpu_usage):.1f}%\")\n        print(f\"  最小: {min(cpu_usage):.1f}%\")\n        \n        # メモリ統計\n        memory_usage = [data['memory']['percent'] for data in self.monitoring_data]\n        print(f\"\\n🧠 メモリ使用率統計:\")\n        print(f\"  平均: {sum(memory_usage)/len(memory_usage):.1f}%\")\n        print(f\"  最大: {max(memory_usage):.1f}%\")\n        print(f\"  最小: {min(memory_usage):.1f}%\")\n        \n        # アラート統計\n        if self.alerts:\n            print(f\"\\n⚠️ アラート統計:\")\n            alert_types = {}\n            for alert in self.alerts:\n                alert_types[alert['type']] = alert_types.get(alert['type'], 0) + 1\n            \n            for alert_type, count in alert_types.items():\n                print(f\"  {alert_type}: {count}回\")\n        else:\n            print(f\"\\n✅ アラートなし\")\n    \n    def get_top_processes(self, limit: int = 5) -&gt; List[Dict]:\n        \"\"\"CPU/メモリ使用率上位プロセスを取得\"\"\"\n        processes = []\n        \n        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):\n            try:\n                processes.append(proc.info)\n            except (psutil.NoSuchProcess, psutil.AccessDenied):\n                pass\n        \n        # CPU使用率でソート\n        processes.sort(key=lambda x: x['cpu_percent'] or 0, reverse=True)\n        \n        return processes[:limit]\n    \n    def display_top_processes(self):\n        \"\"\"上位プロセスを表示\"\"\"\n        print(f\"\\n🔝 CPU使用率上位プロセス:\")\n        top_processes = self.get_top_processes()\n        \n        for i, proc in enumerate(top_processes, 1):\n            cpu = proc['cpu_percent'] or 0\n            memory = proc['memory_percent'] or 0\n            print(f\"  {i}. {proc['name']} (PID: {proc['pid']})\")\n            print(f\"     CPU: {cpu:.1f}%, メモリ: {memory:.1f}%\")\n\n# システム監視デモ\ndef demo_system_monitor():\n    \"\"\"システム監視デモ\"\"\"\n    print(\"=== システム監視デモ ===\")\n    \n    monitor = SystemMonitor()\n    \n    # 単発監視\n    print(\"🔍 現在のシステム状態:\")\n    monitor.display_system_status()\n    \n    # 上位プロセス表示\n    monitor.display_top_processes()\n    \n    print(f\"\\n\" + \"=\"*50)\n    print(\"📈 継続監視のシミュレーション (15秒間、5秒間隔)\")\n    print(\"実際の環境では以下のコマンドで長期監視できます:\")\n    print(\"monitor.monitor_continuous(duration=300, interval=10)\")\n    \n    # 短時間の監視デモ\n    monitor.monitor_continuous(duration=15, interval=5)\n\ndemo_system_monitor()\n\nこの章では、Pythonを使って実際のビジネスや日常生活で役立つアプリケーションを構築する方法を学習しました。タスク管理、ファイル整理、Webスクレイピング、システム監視など、様々な用途に応用できる実践的なスキルを身につけることができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>実践的なPythonアプリケーション</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html",
    "href": "book/16-iot-connectivity.html",
    "title": "16  IoT接続とハードウェア制御",
    "section": "",
    "text": "16.1 IoT基礎とPython\nPythonを使用してIoTデバイスやハードウェアと連携し、実世界のデータを収集・制御する方法を学習します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#iot基礎とpython",
    "href": "book/16-iot-connectivity.html#iot基礎とpython",
    "title": "16  IoT接続とハードウェア制御",
    "section": "",
    "text": "16.1.1 IoTシステムの概要\n\nimport time\nimport random\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass SensorType(Enum):\n    \"\"\"センサータイプ\"\"\"\n    TEMPERATURE = \"温度\"\n    HUMIDITY = \"湿度\"\n    PRESSURE = \"気圧\"\n    LIGHT = \"光\"\n    MOTION = \"動作\"\n    SOUND = \"音\"\n    GAS = \"ガス\"\n\n@dataclass\nclass SensorReading:\n    \"\"\"センサー読み取り値\"\"\"\n    sensor_id: str\n    sensor_type: SensorType\n    value: float\n    unit: str\n    timestamp: datetime\n    location: str = \"\"\n    \n    def to_dict(self) -&gt; Dict:\n        return {\n            \"sensor_id\": self.sensor_id,\n            \"sensor_type\": self.sensor_type.value,\n            \"value\": self.value,\n            \"unit\": self.unit,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"location\": self.location\n        }\n\nclass IoTDevice:\n    \"\"\"IoTデバイス基底クラス\"\"\"\n    \n    def __init__(self, device_id: str, name: str, location: str = \"\"):\n        self.device_id = device_id\n        self.name = name\n        self.location = location\n        self.is_connected = False\n        self.last_seen = None\n        self.readings_history: List[SensorReading] = []\n    \n    def connect(self) -&gt; bool:\n        \"\"\"デバイスに接続\"\"\"\n        print(f\"🔌 デバイス接続中: {self.name} ({self.device_id})\")\n        # 実際の実装では、WiFi、Bluetooth、シリアル通信などを使用\n        self.is_connected = True\n        self.last_seen = datetime.now()\n        print(f\"✅ 接続成功: {self.name}\")\n        return True\n    \n    def disconnect(self):\n        \"\"\"デバイスから切断\"\"\"\n        print(f\"🔌 デバイス切断: {self.name}\")\n        self.is_connected = False\n    \n    def read_sensor(self, sensor_type: SensorType) -&gt; Optional[SensorReading]:\n        \"\"\"センサー値を読み取り\"\"\"\n        if not self.is_connected:\n            print(f\"❌ デバイス未接続: {self.name}\")\n            return None\n        \n        # センサー値のシミュレーション\n        value, unit = self._simulate_sensor_reading(sensor_type)\n        \n        reading = SensorReading(\n            sensor_id=f\"{self.device_id}_{sensor_type.name}\",\n            sensor_type=sensor_type,\n            value=value,\n            unit=unit,\n            timestamp=datetime.now(),\n            location=self.location\n        )\n        \n        self.readings_history.append(reading)\n        self.last_seen = datetime.now()\n        \n        print(f\"📊 {self.name}: {sensor_type.value} = {value}{unit}\")\n        return reading\n    \n    def _simulate_sensor_reading(self, sensor_type: SensorType) -&gt; tuple:\n        \"\"\"センサー読み取り値をシミュレート\"\"\"\n        if sensor_type == SensorType.TEMPERATURE:\n            return round(random.uniform(18.0, 30.0), 1), \"°C\"\n        elif sensor_type == SensorType.HUMIDITY:\n            return round(random.uniform(40.0, 80.0), 1), \"%\"\n        elif sensor_type == SensorType.PRESSURE:\n            return round(random.uniform(1000.0, 1030.0), 1), \"hPa\"\n        elif sensor_type == SensorType.LIGHT:\n            return round(random.uniform(0.0, 1000.0), 0), \"lux\"\n        elif sensor_type == SensorType.MOTION:\n            return random.choice([0, 1]), \"\"\n        elif sensor_type == SensorType.SOUND:\n            return round(random.uniform(30.0, 80.0), 1), \"dB\"\n        elif sensor_type == SensorType.GAS:\n            return round(random.uniform(0.0, 100.0), 1), \"ppm\"\n        else:\n            return 0.0, \"\"\n    \n    def get_status(self) -&gt; Dict:\n        \"\"\"デバイス状態を取得\"\"\"\n        return {\n            \"device_id\": self.device_id,\n            \"name\": self.name,\n            \"location\": self.location,\n            \"is_connected\": self.is_connected,\n            \"last_seen\": self.last_seen.isoformat() if self.last_seen else None,\n            \"total_readings\": len(self.readings_history)\n        }\n\n# 具体的なIoTデバイス\nclass WeatherStation(IoTDevice):\n    \"\"\"気象観測ステーション\"\"\"\n    \n    def __init__(self, device_id: str, location: str = \"\"):\n        super().__init__(device_id, \"気象観測ステーション\", location)\n        self.supported_sensors = [\n            SensorType.TEMPERATURE,\n            SensorType.HUMIDITY, \n            SensorType.PRESSURE\n        ]\n    \n    def read_all_sensors(self) -&gt; List[SensorReading]:\n        \"\"\"全センサーの値を読み取り\"\"\"\n        readings = []\n        for sensor_type in self.supported_sensors:\n            reading = self.read_sensor(sensor_type)\n            if reading:\n                readings.append(reading)\n        return readings\n    \n    def get_weather_summary(self) -&gt; Dict:\n        \"\"\"天気サマリーを取得\"\"\"\n        if not self.readings_history:\n            return {\"message\": \"データがありません\"}\n        \n        # 最新の読み取り値を取得\n        latest_readings = {}\n        for reading in reversed(self.readings_history):\n            if reading.sensor_type not in latest_readings:\n                latest_readings[reading.sensor_type] = reading\n            \n            # 全センサーの値が揃ったら終了\n            if len(latest_readings) == len(self.supported_sensors):\n                break\n        \n        summary = {\n            \"location\": self.location,\n            \"timestamp\": datetime.now().isoformat(),\n            \"readings\": {}\n        }\n        \n        for sensor_type, reading in latest_readings.items():\n            summary[\"readings\"][sensor_type.value] = {\n                \"value\": reading.value,\n                \"unit\": reading.unit\n            }\n        \n        return summary\n\nclass SmartHome(IoTDevice):\n    \"\"\"スマートホームデバイス\"\"\"\n    \n    def __init__(self, device_id: str, room: str = \"\"):\n        super().__init__(device_id, \"スマートホームハブ\", room)\n        self.room = room\n        self.devices = {}\n        self.automation_rules = []\n    \n    def add_device(self, device_name: str, device_type: str):\n        \"\"\"デバイスを追加\"\"\"\n        self.devices[device_name] = {\n            \"type\": device_type,\n            \"status\": \"off\",\n            \"last_updated\": datetime.now()\n        }\n        print(f\"🏠 デバイス追加: {device_name} ({device_type}) @ {self.room}\")\n    \n    def control_device(self, device_name: str, command: str) -&gt; bool:\n        \"\"\"デバイスを制御\"\"\"\n        if device_name not in self.devices:\n            print(f\"❌ デバイスが見つかりません: {device_name}\")\n            return False\n        \n        valid_commands = [\"on\", \"off\", \"toggle\", \"dim\", \"bright\"]\n        if command not in valid_commands:\n            print(f\"❌ 無効なコマンド: {command}\")\n            return False\n        \n        device = self.devices[device_name]\n        \n        if command == \"on\":\n            device[\"status\"] = \"on\"\n        elif command == \"off\":\n            device[\"status\"] = \"off\"\n        elif command == \"toggle\":\n            device[\"status\"] = \"on\" if device[\"status\"] == \"off\" else \"off\"\n        elif command in [\"dim\", \"bright\"]:\n            device[\"status\"] = command\n        \n        device[\"last_updated\"] = datetime.now()\n        \n        print(f\"🎛️ {device_name} を {command} に設定しました\")\n        return True\n    \n    def add_automation_rule(self, condition: str, action: str):\n        \"\"\"自動化ルールを追加\"\"\"\n        rule = {\n            \"id\": len(self.automation_rules) + 1,\n            \"condition\": condition,\n            \"action\": action,\n            \"created_at\": datetime.now(),\n            \"triggered_count\": 0\n        }\n        self.automation_rules.append(rule)\n        print(f\"🤖 自動化ルール追加: {condition} → {action}\")\n    \n    def check_automation(self, sensor_reading: SensorReading):\n        \"\"\"自動化ルールをチェック\"\"\"\n        for rule in self.automation_rules:\n            if self._evaluate_condition(rule[\"condition\"], sensor_reading):\n                self._execute_action(rule[\"action\"])\n                rule[\"triggered_count\"] += 1\n                print(f\"🤖 自動化実行: {rule['condition']} → {rule['action']}\")\n    \n    def _evaluate_condition(self, condition: str, reading: SensorReading) -&gt; bool:\n        \"\"\"条件を評価（簡略化）\"\"\"\n        # 実際の実装ではより複雑な条件解析が必要\n        if \"温度\" in condition and reading.sensor_type == SensorType.TEMPERATURE:\n            if \"25度以上\" in condition:\n                return reading.value &gt;= 25.0\n            elif \"20度以下\" in condition:\n                return reading.value &lt;= 20.0\n        elif \"湿度\" in condition and reading.sensor_type == SensorType.HUMIDITY:\n            if \"70%以上\" in condition:\n                return reading.value &gt;= 70.0\n        return False\n    \n    def _execute_action(self, action: str):\n        \"\"\"アクションを実行（簡略化）\"\"\"\n        if \"エアコン\" in action:\n            if \"on\" in action:\n                self.control_device(\"エアコン\", \"on\")\n            elif \"off\" in action:\n                self.control_device(\"エアコン\", \"off\")\n        elif \"照明\" in action:\n            if \"on\" in action:\n                self.control_device(\"照明\", \"on\")\n            elif \"off\" in action:\n                self.control_device(\"照明\", \"off\")\n\n# IoTデバイス管理システム\nclass IoTManager:\n    \"\"\"IoTデバイス管理システム\"\"\"\n    \n    def __init__(self):\n        self.devices: Dict[str, IoTDevice] = {}\n        self.data_storage: List[SensorReading] = []\n        self.alerts = []\n    \n    def register_device(self, device: IoTDevice):\n        \"\"\"デバイスを登録\"\"\"\n        self.devices[device.device_id] = device\n        print(f\"📱 デバイス登録: {device.name} ({device.device_id})\")\n    \n    def connect_all_devices(self):\n        \"\"\"全デバイスに接続\"\"\"\n        print(\"🔌 全デバイス接続中...\")\n        for device in self.devices.values():\n            device.connect()\n        print(\"✅ 全デバイス接続完了\")\n    \n    def collect_data_from_all(self):\n        \"\"\"全デバイスからデータ収集\"\"\"\n        print(\"📊 データ収集開始...\")\n        \n        for device in self.devices.values():\n            if device.is_connected:\n                if isinstance(device, WeatherStation):\n                    readings = device.read_all_sensors()\n                    self.data_storage.extend(readings)\n                else:\n                    # 基本センサー読み取り\n                    reading = device.read_sensor(SensorType.TEMPERATURE)\n                    if reading:\n                        self.data_storage.append(reading)\n        \n        print(f\"📈 データ収集完了: {len(self.data_storage)}件\")\n    \n    def get_device_summary(self) -&gt; Dict:\n        \"\"\"デバイスサマリーを取得\"\"\"\n        connected = sum(1 for d in self.devices.values() if d.is_connected)\n        total = len(self.devices)\n        \n        return {\n            \"total_devices\": total,\n            \"connected_devices\": connected,\n            \"total_readings\": len(self.data_storage),\n            \"device_types\": list(set(type(d).__name__ for d in self.devices.values()))\n        }\n    \n    def export_data(self, filename: str):\n        \"\"\"データをJSONファイルにエクスポート\"\"\"\n        data = [reading.to_dict() for reading in self.data_storage]\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n        print(f\"💾 データエクスポート完了: {filename}\")\n\n# IoTシステムデモ\ndef demo_iot_system():\n    \"\"\"IoTシステムデモ\"\"\"\n    print(\"=== IoTシステムデモ ===\")\n    \n    # IoT管理システムを作成\n    iot_manager = IoTManager()\n    \n    # 気象観測ステーションを作成\n    weather_station = WeatherStation(\"WS001\", \"屋上\")\n    iot_manager.register_device(weather_station)\n    \n    # スマートホームハブを作成\n    smart_home = SmartHome(\"SH001\", \"リビング\")\n    smart_home.add_device(\"エアコン\", \"空調\")\n    smart_home.add_device(\"照明\", \"照明\")\n    smart_home.add_device(\"扇風機\", \"扇風機\")\n    iot_manager.register_device(smart_home)\n    \n    # 自動化ルールを追加\n    smart_home.add_automation_rule(\"温度25度以上\", \"エアコンon\")\n    smart_home.add_automation_rule(\"湿度70%以上\", \"扇風機on\")\n    \n    # 全デバイスに接続\n    iot_manager.connect_all_devices()\n    \n    print(f\"\\n\" + \"=\"*50)\n    print(\"📊 センサーデータ収集シミュレーション\")\n    \n    # データ収集を複数回実行\n    for cycle in range(3):\n        print(f\"\\n--- サイクル {cycle + 1} ---\")\n        \n        # 気象データを読み取り\n        weather_readings = weather_station.read_all_sensors()\n        \n        # スマートホーム制御\n        for reading in weather_readings:\n            smart_home.check_automation(reading)\n        \n        # データをマネージャーに保存\n        iot_manager.data_storage.extend(weather_readings)\n        \n        # 天気サマリーを表示\n        weather_summary = weather_station.get_weather_summary()\n        print(f\"🌤️ 気象情報: {weather_summary}\")\n        \n        time.sleep(1)  # シミュレーション用の待機\n    \n    # システムサマリー\n    print(f\"\\n📋 システムサマリー:\")\n    summary = iot_manager.get_device_summary()\n    for key, value in summary.items():\n        print(f\"  {key}: {value}\")\n\ndemo_iot_system()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#シリアル通信とセンサー制御",
    "href": "book/16-iot-connectivity.html#シリアル通信とセンサー制御",
    "title": "16  IoT接続とハードウェア制御",
    "section": "16.2 シリアル通信とセンサー制御",
    "text": "16.2 シリアル通信とセンサー制御\n\n16.2.1 Arduino・Raspberry Pi連携\n\nimport serial\nimport time\nimport threading\nfrom queue import Queue\nfrom typing import Callable, Optional\n\nclass SerialCommunicator:\n    \"\"\"シリアル通信クラス\"\"\"\n    \n    def __init__(self, port: str = \"COM3\", baudrate: int = 9600):\n        self.port = port\n        self.baudrate = baudrate\n        self.serial_connection: Optional[serial.Serial] = None\n        self.is_connected = False\n        self.read_thread: Optional[threading.Thread] = None\n        self.message_queue = Queue()\n        self.callbacks = []\n    \n    def connect(self) -&gt; bool:\n        \"\"\"シリアルポートに接続\"\"\"\n        try:\n            print(f\"🔌 シリアル接続中: {self.port} @ {self.baudrate}\")\n            \n            # 実際の環境では以下のコードを使用\n            # self.serial_connection = serial.Serial(self.port, self.baudrate, timeout=1)\n            # self.is_connected = True\n            \n            # デモ用のシミュレーション\n            self.is_connected = True\n            print(f\"✅ シリアル接続成功\")\n            \n            # 読み取りスレッドを開始\n            self.start_reading_thread()\n            return True\n            \n        except Exception as e:\n            print(f\"❌ シリアル接続エラー: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"シリアル接続を切断\"\"\"\n        self.is_connected = False\n        \n        if self.read_thread and self.read_thread.is_alive():\n            self.read_thread.join(timeout=2)\n        \n        if self.serial_connection:\n            self.serial_connection.close()\n        \n        print(\"🔌 シリアル接続を切断しました\")\n    \n    def send_command(self, command: str) -&gt; bool:\n        \"\"\"コマンドを送信\"\"\"\n        if not self.is_connected:\n            print(\"❌ シリアル未接続\")\n            return False\n        \n        try:\n            # 実際の環境では以下のコードを使用\n            # self.serial_connection.write((command + '\\n').encode())\n            \n            # デモ用のシミュレーション\n            print(f\"📤 送信: {command}\")\n            \n            # 模擬応答を生成\n            self._simulate_response(command)\n            return True\n            \n        except Exception as e:\n            print(f\"❌ 送信エラー: {e}\")\n            return False\n    \n    def _simulate_response(self, command: str):\n        \"\"\"模擬応答を生成\"\"\"\n        if command.startswith(\"READ_SENSORS\"):\n            response = \"TEMP:25.3,HUMID:65.2\"\n        elif command.startswith(\"LED_ON\"):\n            response = \"LED:ON\"\n        elif command.startswith(\"LED_OFF\"):\n            response = \"LED:OFF\"\n        elif command.startswith(\"MOTOR\"):\n            response = \"MOTOR:RUNNING\"\n        else:\n            response = \"OK\"\n        \n        # 応答をキューに追加\n        self.message_queue.put(response)\n        \n        # コールバック関数を呼び出し\n        for callback in self.callbacks:\n            callback(response)\n    \n    def start_reading_thread(self):\n        \"\"\"読み取りスレッドを開始\"\"\"\n        self.read_thread = threading.Thread(target=self._read_loop, daemon=True)\n        self.read_thread.start()\n    \n    def _read_loop(self):\n        \"\"\"読み取りループ\"\"\"\n        while self.is_connected:\n            try:\n                # 実際の環境では以下のコードを使用\n                # if self.serial_connection.in_waiting &gt; 0:\n                #     data = self.serial_connection.readline().decode().strip()\n                #     self.message_queue.put(data)\n                \n                # デモ用: 定期的にダミーデータを生成\n                time.sleep(2)\n                if self.is_connected:\n                    dummy_data = f\"SENSOR_DATA:TEMP:{20 + time.time() % 10:.1f}\"\n                    self.message_queue.put(dummy_data)\n                \n            except Exception as e:\n                print(f\"❌ 読み取りエラー: {e}\")\n                break\n    \n    def add_callback(self, callback: Callable[[str], None]):\n        \"\"\"メッセージ受信時のコールバック関数を追加\"\"\"\n        self.callbacks.append(callback)\n    \n    def get_messages(self) -&gt; list:\n        \"\"\"受信したメッセージを取得\"\"\"\n        messages = []\n        while not self.message_queue.empty():\n            messages.append(self.message_queue.get())\n        return messages\n\nclass ArduinoController:\n    \"\"\"Arduino制御クラス\"\"\"\n    \n    def __init__(self, port: str = \"COM3\"):\n        self.communicator = SerialCommunicator(port)\n        self.sensor_data = {}\n        self.led_status = False\n        \n        # コールバック関数を設定\n        self.communicator.add_callback(self._handle_response)\n    \n    def connect(self) -&gt; bool:\n        \"\"\"Arduinoに接続\"\"\"\n        return self.communicator.connect()\n    \n    def disconnect(self):\n        \"\"\"Arduino接続を切断\"\"\"\n        self.communicator.disconnect()\n    \n    def _handle_response(self, response: str):\n        \"\"\"Arduino応答を処理\"\"\"\n        print(f\"📥 受信: {response}\")\n        \n        if response.startswith(\"TEMP:\"):\n            # 温度データを解析\n            parts = response.split(\",\")\n            for part in parts:\n                if \"TEMP:\" in part:\n                    temp = float(part.split(\":\")[1])\n                    self.sensor_data[\"temperature\"] = temp\n                elif \"HUMID:\" in part:\n                    humid = float(part.split(\":\")[1])\n                    self.sensor_data[\"humidity\"] = humid\n    \n    def read_sensors(self) -&gt; Dict:\n        \"\"\"センサー値を読み取り\"\"\"\n        self.communicator.send_command(\"READ_SENSORS\")\n        time.sleep(0.1)  # 応答待機\n        return self.sensor_data.copy()\n    \n    def control_led(self, state: bool) -&gt; bool:\n        \"\"\"LEDを制御\"\"\"\n        command = \"LED_ON\" if state else \"LED_OFF\"\n        success = self.communicator.send_command(command)\n        \n        if success:\n            self.led_status = state\n            print(f\"💡 LED: {'点灯' if state else '消灯'}\")\n        \n        return success\n    \n    def control_motor(self, speed: int, direction: str = \"forward\") -&gt; bool:\n        \"\"\"モーターを制御\"\"\"\n        command = f\"MOTOR:{direction}:{speed}\"\n        success = self.communicator.send_command(command)\n        \n        if success:\n            print(f\"⚙️ モーター: {direction} 速度{speed}\")\n        \n        return success\n    \n    def get_status(self) -&gt; Dict:\n        \"\"\"デバイス状態を取得\"\"\"\n        return {\n            \"connected\": self.communicator.is_connected,\n            \"sensor_data\": self.sensor_data,\n            \"led_status\": self.led_status\n        }\n\n# Raspberry Pi GPIO制御（シミュレーション）\nclass RaspberryPiController:\n    \"\"\"Raspberry Pi GPIO制御クラス\"\"\"\n    \n    def __init__(self):\n        self.gpio_states = {}\n        self.pwm_channels = {}\n        print(\"🥧 Raspberry Pi制御器を初期化しました\")\n    \n    def setup_pin(self, pin: int, mode: str):\n        \"\"\"ピンを設定\"\"\"\n        self.gpio_states[pin] = {\"mode\": mode, \"value\": 0}\n        print(f\"📌 GPIO{pin}を{mode}モードに設定\")\n    \n    def digital_write(self, pin: int, value: int):\n        \"\"\"デジタル出力\"\"\"\n        if pin in self.gpio_states:\n            self.gpio_states[pin][\"value\"] = value\n            print(f\"📌 GPIO{pin} = {value}\")\n        else:\n            print(f\"❌ GPIO{pin}が設定されていません\")\n    \n    def digital_read(self, pin: int) -&gt; int:\n        \"\"\"デジタル入力読み取り\"\"\"\n        if pin in self.gpio_states:\n            # シミュレーション: ランダム値\n            value = random.choice([0, 1])\n            print(f\"📌 GPIO{pin}読み取り: {value}\")\n            return value\n        return 0\n    \n    def setup_pwm(self, pin: int, frequency: int):\n        \"\"\"PWM設定\"\"\"\n        self.pwm_channels[pin] = {\"frequency\": frequency, \"duty_cycle\": 0}\n        print(f\"🌊 GPIO{pin}をPWM {frequency}Hzに設定\")\n    \n    def set_pwm_duty_cycle(self, pin: int, duty_cycle: float):\n        \"\"\"PWMデューティサイクル設定\"\"\"\n        if pin in self.pwm_channels:\n            self.pwm_channels[pin][\"duty_cycle\"] = duty_cycle\n            print(f\"🌊 GPIO{pin} PWM: {duty_cycle}%\")\n        else:\n            print(f\"❌ GPIO{pin}のPWMが設定されていません\")\n\n# ハードウェア制御デモ\ndef demo_hardware_control():\n    \"\"\"ハードウェア制御デモ\"\"\"\n    print(\"=== ハードウェア制御デモ ===\")\n    \n    # Arduino制御デモ\n    print(\"🤖 Arduino制御デモ\")\n    arduino = ArduinoController(\"COM3\")\n    \n    if arduino.connect():\n        print(\"\\n📊 センサー読み取りテスト:\")\n        for i in range(3):\n            sensors = arduino.read_sensors()\n            print(f\"  サイクル {i+1}: {sensors}\")\n            time.sleep(1)\n        \n        print(\"\\n💡 LED制御テスト:\")\n        arduino.control_led(True)\n        time.sleep(1)\n        arduino.control_led(False)\n        \n        print(\"\\n⚙️ モーター制御テスト:\")\n        arduino.control_motor(100, \"forward\")\n        time.sleep(1)\n        arduino.control_motor(50, \"backward\")\n        \n        # 状態確認\n        status = arduino.get_status()\n        print(f\"\\n📋 Arduino状態: {status}\")\n        \n        arduino.disconnect()\n    \n    print(f\"\\n\" + \"=\"*50)\n    \n    # Raspberry Pi制御デモ\n    print(\"🥧 Raspberry Pi GPIO制御デモ\")\n    rpi = RaspberryPiController()\n    \n    # GPIO設定\n    rpi.setup_pin(18, \"OUTPUT\")  # LED用\n    rpi.setup_pin(24, \"INPUT\")   # センサー用\n    rpi.setup_pin(12, \"PWM\")     # PWM用\n    \n    # デジタル出力テスト\n    print(\"\\n💡 デジタル出力テスト:\")\n    rpi.digital_write(18, 1)\n    time.sleep(0.5)\n    rpi.digital_write(18, 0)\n    \n    # デジタル入力テスト\n    print(\"\\n📥 デジタル入力テスト:\")\n    for i in range(3):\n        value = rpi.digital_read(24)\n        print(f\"  読み取り {i+1}: {value}\")\n    \n    # PWM制御テスト\n    print(\"\\n🌊 PWM制御テスト:\")\n    rpi.setup_pwm(12, 1000)  # 1kHz\n    for duty in [0, 25, 50, 75, 100]:\n        rpi.set_pwm_duty_cycle(12, duty)\n        time.sleep(0.3)\n\ndemo_hardware_control()",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/16-iot-connectivity.html#ネットワーク通信とクラウド連携",
    "href": "book/16-iot-connectivity.html#ネットワーク通信とクラウド連携",
    "title": "16  IoT接続とハードウェア制御",
    "section": "16.3 ネットワーク通信とクラウド連携",
    "text": "16.3 ネットワーク通信とクラウド連携\n\n16.3.1 MQTT通信とクラウドサービス\n\nimport json\nimport time\nimport threading\nfrom datetime import datetime\nfrom typing import Dict, List, Callable, Optional\nimport hashlib\n\nclass MQTTClient:\n    \"\"\"MQTTクライアント（シミュレーション）\"\"\"\n    \n    def __init__(self, broker_host: str = \"localhost\", port: int = 1883):\n        self.broker_host = broker_host\n        self.port = port\n        self.is_connected = False\n        self.subscriptions = {}\n        self.message_handlers = {}\n        self.published_messages = []\n    \n    def connect(self, client_id: str, username: str = None, password: str = None) -&gt; bool:\n        \"\"\"MQTTブローカーに接続\"\"\"\n        try:\n            print(f\"🌐 MQTT接続中: {client_id} @ {self.broker_host}:{self.port}\")\n            \n            # 実際の環境では以下のライブラリを使用:\n            # import paho.mqtt.client as mqtt\n            # self.client = mqtt.Client(client_id)\n            # if username and password:\n            #     self.client.username_pw_set(username, password)\n            # self.client.connect(self.broker_host, self.port, 60)\n            \n            # シミュレーション\n            self.client_id = client_id\n            self.is_connected = True\n            print(f\"✅ MQTT接続成功: {client_id}\")\n            return True\n            \n        except Exception as e:\n            print(f\"❌ MQTT接続エラー: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"MQTT接続を切断\"\"\"\n        self.is_connected = False\n        print(\"🌐 MQTT接続を切断しました\")\n    \n    def subscribe(self, topic: str, callback: Callable[[str, str], None]):\n        \"\"\"トピックをサブスクライブ\"\"\"\n        if not self.is_connected:\n            print(\"❌ MQTT未接続\")\n            return False\n        \n        self.subscriptions[topic] = True\n        self.message_handlers[topic] = callback\n        print(f\"📡 サブスクライブ: {topic}\")\n        return True\n    \n    def publish(self, topic: str, payload: str, qos: int = 0) -&gt; bool:\n        \"\"\"メッセージを発行\"\"\"\n        if not self.is_connected:\n            print(\"❌ MQTT未接続\")\n            return False\n        \n        message = {\n            \"topic\": topic,\n            \"payload\": payload,\n            \"qos\": qos,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        self.published_messages.append(message)\n        print(f\"📤 発行: {topic} -&gt; {payload}\")\n        \n        # シミュレーション: 自分のサブスクリプションをチェック\n        self._simulate_message_delivery(topic, payload)\n        return True\n    \n    def _simulate_message_delivery(self, topic: str, payload: str):\n        \"\"\"メッセージ配信をシミュレート\"\"\"\n        for subscribed_topic, callback in self.message_handlers.items():\n            if self._topic_matches(subscribed_topic, topic):\n                threading.Thread(\n                    target=callback,\n                    args=(topic, payload),\n                    daemon=True\n                ).start()\n    \n    def _topic_matches(self, pattern: str, topic: str) -&gt; bool:\n        \"\"\"トピックパターンマッチング\"\"\"\n        if pattern == topic:\n            return True\n        if pattern.endswith(\"#\"):\n            prefix = pattern[:-1]\n            return topic.startswith(prefix)\n        if \"+\" in pattern:\n            # 簡略化したワイルドカード処理\n            return True\n        return False\n\nclass IoTCloudPlatform:\n    \"\"\"IoTクラウドプラットフォーム\"\"\"\n    \n    def __init__(self, platform_name: str = \"IoT Platform\"):\n        self.platform_name = platform_name\n        self.mqtt_client = MQTTClient()\n        self.devices = {}\n        self.telemetry_data = []\n        self.alerts = []\n        self.is_running = False\n    \n    def connect(self, client_id: str) -&gt; bool:\n        \"\"\"クラウドプラットフォームに接続\"\"\"\n        success = self.mqtt_client.connect(client_id)\n        if success:\n            self._setup_subscriptions()\n        return success\n    \n    def _setup_subscriptions(self):\n        \"\"\"サブスクリプションを設定\"\"\"\n        # デバイステレメトリ\n        self.mqtt_client.subscribe(\"devices/+/telemetry\", self._handle_telemetry)\n        \n        # デバイスステータス\n        self.mqtt_client.subscribe(\"devices/+/status\", self._handle_device_status)\n        \n        # アラート\n        self.mqtt_client.subscribe(\"devices/+/alert\", self._handle_alert)\n    \n    def _handle_telemetry(self, topic: str, payload: str):\n        \"\"\"テレメトリデータを処理\"\"\"\n        try:\n            device_id = topic.split('/')[1]\n            data = json.loads(payload)\n            \n            telemetry_record = {\n                \"device_id\": device_id,\n                \"data\": data,\n                \"timestamp\": datetime.now().isoformat(),\n                \"topic\": topic\n            }\n            \n            self.telemetry_data.append(telemetry_record)\n            print(f\"📊 テレメトリ受信: {device_id} -&gt; {data}\")\n            \n            # データ分析とアラート生成\n            self._analyze_telemetry(telemetry_record)\n            \n        except Exception as e:\n            print(f\"❌ テレメトリ処理エラー: {e}\")\n    \n    def _handle_device_status(self, topic: str, payload: str):\n        \"\"\"デバイスステータスを処理\"\"\"\n        device_id = topic.split('/')[1]\n        status = payload\n        \n        if device_id not in self.devices:\n            self.devices[device_id] = {}\n        \n        self.devices[device_id][\"status\"] = status\n        self.devices[device_id][\"last_seen\"] = datetime.now().isoformat()\n        \n        print(f\"📱 デバイスステータス: {device_id} = {status}\")\n    \n    def _handle_alert(self, topic: str, payload: str):\n        \"\"\"アラートを処理\"\"\"\n        try:\n            device_id = topic.split('/')[1]\n            alert_data = json.loads(payload)\n            \n            alert = {\n                \"device_id\": device_id,\n                \"alert_data\": alert_data,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n            self.alerts.append(alert)\n            print(f\"🚨 アラート: {device_id} -&gt; {alert_data}\")\n            \n        except Exception as e:\n            print(f\"❌ アラート処理エラー: {e}\")\n    \n    def _analyze_telemetry(self, record: Dict):\n        \"\"\"テレメトリデータを分析\"\"\"\n        data = record[\"data\"]\n        device_id = record[\"device_id\"]\n        \n        # 温度アラート\n        if \"temperature\" in data:\n            temp = data[\"temperature\"]\n            if temp &gt; 30:\n                self._generate_alert(device_id, \"high_temperature\", \n                                   f\"高温警告: {temp}°C\")\n            elif temp &lt; 10:\n                self._generate_alert(device_id, \"low_temperature\", \n                                   f\"低温警告: {temp}°C\")\n        \n        # 湿度アラート\n        if \"humidity\" in data:\n            humidity = data[\"humidity\"]\n            if humidity &gt; 80:\n                self._generate_alert(device_id, \"high_humidity\", \n                                   f\"高湿度警告: {humidity}%\")\n    \n    def _generate_alert(self, device_id: str, alert_type: str, message: str):\n        \"\"\"アラートを生成\"\"\"\n        alert_payload = {\n            \"type\": alert_type,\n            \"message\": message,\n            \"severity\": \"warning\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        topic = f\"alerts/{device_id}\"\n        self.mqtt_client.publish(topic, json.dumps(alert_payload))\n    \n    def send_command(self, device_id: str, command: Dict) -&gt; bool:\n        \"\"\"デバイスにコマンドを送信\"\"\"\n        topic = f\"devices/{device_id}/commands\"\n        payload = json.dumps(command)\n        return self.mqtt_client.publish(topic, payload)\n    \n    def get_device_data(self, device_id: str, hours: int = 24) -&gt; List[Dict]:\n        \"\"\"デバイスデータを取得\"\"\"\n        return [record for record in self.telemetry_data \n                if record[\"device_id\"] == device_id]\n    \n    def get_platform_statistics(self) -&gt; Dict:\n        \"\"\"プラットフォーム統計を取得\"\"\"\n        return {\n            \"total_devices\": len(self.devices),\n            \"active_devices\": len([d for d in self.devices.values() \n                                 if d.get(\"status\") == \"online\"]),\n            \"total_telemetry_records\": len(self.telemetry_data),\n            \"total_alerts\": len(self.alerts),\n            \"recent_alerts\": len([a for a in self.alerts \n                                if (datetime.now() - datetime.fromisoformat(a[\"timestamp\"])).seconds &lt; 3600])\n        }\n\n# IoT仮想デバイス\nclass VirtualIoTDevice:\n    \"\"\"仮想IoTデバイス\"\"\"\n    \n    def __init__(self, device_id: str, device_type: str):\n        self.device_id = device_id\n        self.device_type = device_type\n        self.mqtt_client = MQTTClient()\n        self.is_running = False\n        self.telemetry_thread = None\n    \n    def connect_to_platform(self) -&gt; bool:\n        \"\"\"プラットフォームに接続\"\"\"\n        success = self.mqtt_client.connect(f\"device_{self.device_id}\")\n        if success:\n            self._setup_command_subscription()\n            self._send_status(\"online\")\n        return success\n    \n    def _setup_command_subscription(self):\n        \"\"\"コマンドサブスクリプションを設定\"\"\"\n        topic = f\"devices/{self.device_id}/commands\"\n        self.mqtt_client.subscribe(topic, self._handle_command)\n    \n    def _handle_command(self, topic: str, payload: str):\n        \"\"\"コマンドを処理\"\"\"\n        try:\n            command = json.loads(payload)\n            print(f\"📥 {self.device_id}: コマンド受信 -&gt; {command}\")\n            \n            # コマンド実行シミュレーション\n            if command.get(\"action\") == \"reboot\":\n                print(f\"🔄 {self.device_id}: 再起動中...\")\n            elif command.get(\"action\") == \"update_config\":\n                print(f\"⚙️ {self.device_id}: 設定更新中...\")\n            \n        except Exception as e:\n            print(f\"❌ コマンド処理エラー: {e}\")\n    \n    def start_telemetry(self, interval: int = 5):\n        \"\"\"テレメトリ送信を開始\"\"\"\n        self.is_running = True\n        self.telemetry_thread = threading.Thread(\n            target=self._telemetry_loop,\n            args=(interval,),\n            daemon=True\n        )\n        self.telemetry_thread.start()\n        print(f\"📊 {self.device_id}: テレメトリ送信開始 ({interval}秒間隔)\")\n    \n    def stop_telemetry(self):\n        \"\"\"テレメトリ送信を停止\"\"\"\n        self.is_running = False\n        self._send_status(\"offline\")\n        print(f\"📊 {self.device_id}: テレメトリ送信停止\")\n    \n    def _telemetry_loop(self, interval: int):\n        \"\"\"テレメトリ送信ループ\"\"\"\n        while self.is_running:\n            telemetry_data = self._generate_telemetry()\n            topic = f\"devices/{self.device_id}/telemetry\"\n            payload = json.dumps(telemetry_data)\n            \n            self.mqtt_client.publish(topic, payload)\n            time.sleep(interval)\n    \n    def _generate_telemetry(self) -&gt; Dict:\n        \"\"\"テレメトリデータを生成\"\"\"\n        base_data = {\n            \"device_id\": self.device_id,\n            \"device_type\": self.device_type,\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        if self.device_type == \"weather_station\":\n            base_data.update({\n                \"temperature\": round(random.uniform(15, 35), 1),\n                \"humidity\": round(random.uniform(30, 90), 1),\n                \"pressure\": round(random.uniform(1000, 1030), 1)\n            })\n        elif self.device_type == \"air_quality\":\n            base_data.update({\n                \"pm25\": round(random.uniform(10, 100), 1),\n                \"co2\": round(random.uniform(400, 1000), 0),\n                \"temperature\": round(random.uniform(18, 28), 1)\n            })\n        \n        return base_data\n    \n    def _send_status(self, status: str):\n        \"\"\"ステータスを送信\"\"\"\n        topic = f\"devices/{self.device_id}/status\"\n        self.mqtt_client.publish(topic, status)\n\n# クラウド連携デモ\ndef demo_cloud_connectivity():\n    \"\"\"クラウド連携デモ\"\"\"\n    print(\"=== IoTクラウド連携デモ ===\")\n    \n    # クラウドプラットフォームを起動\n    platform = IoTCloudPlatform(\"スマートシティプラットフォーム\")\n    platform.connect(\"cloud_platform\")\n    \n    print(\"\\n🌐 仮想IoTデバイス作成・接続中...\")\n    \n    # 仮想デバイスを作成\n    weather_device = VirtualIoTDevice(\"WS001\", \"weather_station\")\n    air_quality_device = VirtualIoTDevice(\"AQ001\", \"air_quality\")\n    \n    # プラットフォームに接続\n    weather_device.connect_to_platform()\n    air_quality_device.connect_to_platform()\n    \n    # テレメトリ送信を開始\n    weather_device.start_telemetry(interval=3)\n    air_quality_device.start_telemetry(interval=4)\n    \n    print(\"\\n📊 データ収集中...\")\n    time.sleep(15)  # 15秒間データ収集\n    \n    # デバイスにコマンドを送信\n    print(\"\\n📤 デバイス制御コマンド送信...\")\n    platform.send_command(\"WS001\", {\"action\": \"reboot\", \"reason\": \"scheduled_maintenance\"})\n    platform.send_command(\"AQ001\", {\"action\": \"update_config\", \"config\": {\"sample_rate\": 60}})\n    \n    time.sleep(2)\n    \n    # 統計情報を表示\n    print(\"\\n📈 プラットフォーム統計:\")\n    stats = platform.get_platform_statistics()\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # デバイス別データサマリー\n    print(\"\\n📊 デバイス別データサマリー:\")\n    for device_id in [\"WS001\", \"AQ001\"]:\n        device_data = platform.get_device_data(device_id)\n        if device_data:\n            latest = device_data[-1][\"data\"]\n            print(f\"  {device_id}: {latest}\")\n    \n    # テレメトリ送信を停止\n    weather_device.stop_telemetry()\n    air_quality_device.stop_telemetry()\n    \n    platform.mqtt_client.disconnect()\n    print(\"\\n✅ デモ完了\")\n\ndemo_cloud_connectivity()\n\nこの章では、PythonによるIoT開発の基本から実践的な応用まで学習しました。センサーデータの収集、ハードウェア制御、ネットワーク通信、クラウド連携など、IoTシステム開発に必要な技術を総合的に習得することができます。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>IoT接続とハードウェア制御</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html",
    "href": "book/99-self-review-1.html",
    "title": "17  自己評価: Python の基礎",
    "section": "",
    "text": "17.1 📝 学習内容の復習\nこの章では、これまで学習した Python の基礎概念を復習し、理解度を確認します。",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#学習内容の復習",
    "href": "book/99-self-review-1.html#学習内容の復習",
    "title": "17  自己評価: Python の基礎",
    "section": "",
    "text": "17.1.1 1. 環境構築とツール\n\nuv パッケージマネージャーの使用\nGit と GitHub でのバージョン管理\nVS Code での開発環境設定\n\n\n\n17.1.2 2. Python の基本構文\n\n変数と代入\nデータ型（文字列、数値、ブール値）\nインデントによるコードブロック\n\n\n\n17.1.3 3. データ型とコレクション\n\nリスト: 順序付きの要素のコレクション\n辞書: キーと値のペア\nセット: 重複のない要素のコレクション\nタプル: 不変の順序付きコレクション\n\n\n\n17.1.4 4. 制御フロー\n\n条件文: if、elif、else\nループ: for、while\nループ制御: break、continue\n\n\n\n17.1.5 5. 関数\n\n関数の定義と呼び出し\n引数とパラメータ\n戻り値\nスコープ\n\n\n\n17.1.6 6. エラー処理\n\ntry-except 文\n異なる例外の処理\nfinally ブロック\n\n\n\n17.1.7 7. モジュールとパッケージ\n\nモジュールのインポート\n標準ライブラリの使用\nカスタムモジュールの作成",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#理解度チェック問題",
    "href": "book/99-self-review-1.html#理解度チェック問題",
    "title": "17  自己評価: Python の基礎",
    "section": "17.2 🧪 理解度チェック問題",
    "text": "17.2 🧪 理解度チェック問題\n\n17.2.1 問題 1: 基本的なデータ操作\n\n# 課題: 学生の成績管理システム\nstudents = [\n    {\"名前\": \"田中太郎\", \"数学\": 85, \"英語\": 92, \"理科\": 78},\n    {\"名前\": \"佐藤花子\", \"数学\": 93, \"英語\": 87, \"理科\": 95},\n    {\"名前\": \"鈴木次郎\", \"数学\": 76, \"英語\": 84, \"理科\": 89}\n]\n\n# 1. 各学生の平均点を計算\nprint(\"=== 学生の平均点 ===\")\nfor student in students:\n    name = student[\"名前\"]\n    scores = [student[\"数学\"], student[\"英語\"], student[\"理科\"]]\n    average = sum(scores) / len(scores)\n    print(f\"{name}: {average:.1f}点\")\n\n# 2. 科目別の平均点を計算\nsubjects = [\"数学\", \"英語\", \"理科\"]\nprint(\"\\n=== 科目別平均点 ===\")\nfor subject in subjects:\n    total = sum(student[subject] for student in students)\n    average = total / len(students)\n    print(f\"{subject}: {average:.1f}点\")\n\n# 3. 最高点を取った学生を見つける\nprint(\"\\n=== 各科目の最高点 ===\")\nfor subject in subjects:\n    max_score = 0\n    top_student = \"\"\n    for student in students:\n        if student[subject] &gt; max_score:\n            max_score = student[subject]\n            top_student = student[\"名前\"]\n    print(f\"{subject}: {top_student} ({max_score}点)\")\n\n\n\n17.2.2 問題 2: 関数とエラー処理\n\ndef calculate_bmi(weight, height):\n    \"\"\"BMI (Body Mass Index) を計算する関数\"\"\"\n    try:\n        # BMI = 体重(kg) / 身長(m)^2\n        bmi = weight / (height ** 2)\n        return round(bmi, 2)\n    except ZeroDivisionError:\n        return \"エラー: 身長に0は指定できません\"\n    except TypeError:\n        return \"エラー: 数値を入力してください\"\n\ndef get_bmi_category(bmi):\n    \"\"\"BMI値から体型カテゴリを判定\"\"\"\n    if isinstance(bmi, str):  # エラーメッセージの場合\n        return bmi\n    \n    if bmi &lt; 18.5:\n        return \"やせ型\"\n    elif bmi &lt; 25:\n        return \"標準\"\n    elif bmi &lt; 30:\n        return \"肥満度1\"\n    else:\n        return \"肥満度2以上\"\n\n# テストデータ\ntest_data = [\n    {\"名前\": \"田中\", \"体重\": 70, \"身長\": 1.75},\n    {\"名前\": \"佐藤\", \"体重\": 55, \"身長\": 1.60},\n    {\"名前\": \"鈴木\", \"体重\": 85, \"身長\": 1.80},\n    {\"名前\": \"エラー例\", \"体重\": 70, \"身長\": 0},  # エラーケース\n]\n\nprint(\"=== BMI 計算結果 ===\")\nfor person in test_data:\n    name = person[\"名前\"]\n    weight = person[\"体重\"]\n    height = person[\"身長\"]\n    \n    bmi = calculate_bmi(weight, height)\n    category = get_bmi_category(bmi)\n    \n    if isinstance(bmi, str):  # エラーの場合\n        print(f\"{name}: {bmi}\")\n    else:\n        print(f\"{name}: BMI={bmi}, 判定={category}\")\n\n\n\n17.2.3 問題 3: ファイル処理とデータ分析\n\nimport json\nfrom datetime import datetime, timedelta\n\n# サンプルデータ（実際のファイルの代わり）\nsample_data = [\n    {\"日付\": \"2024-01-01\", \"売上\": 120000, \"顧客数\": 45},\n    {\"日付\": \"2024-01-02\", \"売上\": 98000, \"顧客数\": 38},\n    {\"日付\": \"2024-01-03\", \"売上\": 145000, \"顧客数\": 52},\n    {\"日付\": \"2024-01-04\", \"売上\": 87000, \"顧客数\": 33},\n    {\"日付\": \"2024-01-05\", \"売上\": 167000, \"顧客数\": 61},\n]\n\ndef analyze_sales_data(data):\n    \"\"\"売上データを分析する関数\"\"\"\n    if not data:\n        return {\"エラー\": \"データが空です\"}\n    \n    # 基本統計\n    total_sales = sum(day[\"売上\"] for day in data)\n    total_customers = sum(day[\"顧客数\"] for day in data)\n    average_sales = total_sales / len(data)\n    average_customers = total_customers / len(data)\n    \n    # 最高・最低売上日\n    best_day = max(data, key=lambda x: x[\"売上\"])\n    worst_day = min(data, key=lambda x: x[\"売上\"])\n    \n    # 顧客あたりの平均売上\n    customer_avg_spending = []\n    for day in data:\n        if day[\"顧客数\"] &gt; 0:\n            avg = day[\"売上\"] / day[\"顧客数\"]\n            customer_avg_spending.append(avg)\n    \n    overall_avg_spending = sum(customer_avg_spending) / len(customer_avg_spending)\n    \n    return {\n        \"分析期間\": f\"{data[0]['日付']} ～ {data[-1]['日付']}\",\n        \"総売上\": f\"{total_sales:,}円\",\n        \"総顧客数\": f\"{total_customers:,}人\",\n        \"日平均売上\": f\"{average_sales:,.0f}円\",\n        \"日平均顧客数\": f\"{average_customers:.1f}人\",\n        \"最高売上日\": f\"{best_day['日付']} ({best_day['売上']:,}円)\",\n        \"最低売上日\": f\"{worst_day['日付']} ({worst_day['売上']:,}円)\",\n        \"顧客あたり平均単価\": f\"{overall_avg_spending:,.0f}円\"\n    }\n\n# データ分析の実行\nanalysis = analyze_sales_data(sample_data)\n\nprint(\"=== 売上分析レポート ===\")\nfor key, value in analysis.items():\n    print(f\"{key}: {value}\")",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#実践課題",
    "href": "book/99-self-review-1.html#実践課題",
    "title": "17  自己評価: Python の基礎",
    "section": "17.3 🎯 実践課題",
    "text": "17.3 🎯 実践課題\n\n17.3.1 課題 1: 家計簿アプリケーション\n以下の機能を持つ簡単な家計簿プログラムを作成してください：\n\nclass HouseholdBudget:\n    \"\"\"家計簿管理クラス\"\"\"\n    \n    def __init__(self):\n        self.transactions = []\n        self.categories = {\n            \"収入\": [\"給与\", \"ボーナス\", \"その他収入\"],\n            \"支出\": [\"食費\", \"住居費\", \"交通費\", \"娯楽費\", \"その他支出\"]\n        }\n    \n    def add_transaction(self, date, category, amount, description=\"\"):\n        \"\"\"取引を追加\"\"\"\n        transaction = {\n            \"日付\": date,\n            \"カテゴリ\": category,\n            \"金額\": amount,\n            \"説明\": description,\n            \"ID\": len(self.transactions) + 1\n        }\n        self.transactions.append(transaction)\n        return f\"取引を追加しました: {description} ({amount:,}円)\"\n    \n    def get_balance(self):\n        \"\"\"収支を計算\"\"\"\n        income = sum(t[\"金額\"] for t in self.transactions \n                    if t[\"カテゴリ\"] in self.categories[\"収入\"])\n        expense = sum(t[\"金額\"] for t in self.transactions \n                     if t[\"カテゴリ\"] in self.categories[\"支出\"])\n        return income - expense\n    \n    def get_summary_by_category(self):\n        \"\"\"カテゴリ別集計\"\"\"\n        summary = {}\n        for transaction in self.transactions:\n            category = transaction[\"カテゴリ\"]\n            amount = transaction[\"金額\"]\n            if category in summary:\n                summary[category] += amount\n            else:\n                summary[category] = amount\n        return summary\n    \n    def get_monthly_report(self, year, month):\n        \"\"\"月次レポート\"\"\"\n        monthly_transactions = [\n            t for t in self.transactions \n            if t[\"日付\"].startswith(f\"{year}-{month:02d}\")\n        ]\n        \n        if not monthly_transactions:\n            return f\"{year}年{month}月のデータがありません\"\n        \n        income = sum(t[\"金額\"] for t in monthly_transactions \n                    if t[\"カテゴリ\"] in self.categories[\"収入\"])\n        expense = sum(t[\"金額\"] for t in monthly_transactions \n                     if t[\"カテゴリ\"] in self.categories[\"支出\"])\n        \n        return {\n            \"期間\": f\"{year}年{month}月\",\n            \"収入\": f\"{income:,}円\",\n            \"支出\": f\"{expense:,}円\",\n            \"収支\": f\"{income - expense:,}円\",\n            \"取引件数\": len(monthly_transactions)\n        }\n\n# 家計簿のテスト\nbudget = HouseholdBudget()\n\n# サンプルデータの追加\nprint(\"=== 取引データの追加 ===\")\nprint(budget.add_transaction(\"2024-01-01\", \"給与\", 300000, \"月給\"))\nprint(budget.add_transaction(\"2024-01-03\", \"食費\", -5000, \"スーパーでの買い物\"))\nprint(budget.add_transaction(\"2024-01-05\", \"住居費\", -80000, \"家賃\"))\nprint(budget.add_transaction(\"2024-01-10\", \"娯楽費\", -12000, \"映画・食事\"))\nprint(budget.add_transaction(\"2024-01-15\", \"その他収入\", 50000, \"副業\"))\n\n# 残高確認\nprint(f\"\\n現在の残高: {budget.get_balance():,}円\")\n\n# カテゴリ別集計\nprint(\"\\n=== カテゴリ別集計 ===\")\nsummary = budget.get_summary_by_category()\nfor category, amount in summary.items():\n    print(f\"{category}: {amount:,}円\")\n\n# 月次レポート\nprint(\"\\n=== 月次レポート ===\")\nreport = budget.get_monthly_report(2024, 1)\nif isinstance(report, dict):\n    for key, value in report.items():\n        print(f\"{key}: {value}\")\nelse:\n    print(report)",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#習熟度評価",
    "href": "book/99-self-review-1.html#習熟度評価",
    "title": "17  自己評価: Python の基礎",
    "section": "17.4 🏆 習熟度評価",
    "text": "17.4 🏆 習熟度評価\n\n17.4.1 レベル 1 (初心者)\n\n変数と基本データ型を理解している\n簡単な計算とprint文が使える\nリストと辞書の基本操作ができる\n\n\n\n17.4.2 レベル 2 (初級)\n\nif文とfor文を組み合わせて使える\n関数を定義して使える\n基本的なエラー処理ができる\n\n\n\n17.4.3 レベル 3 (中級)\n\n複雑なデータ構造を扱える\nモジュールを作成・利用できる\nクラスの基本概念を理解している\n\n\n\n17.4.4 レベル 4 (中上級)\n\n実践的なアプリケーションを作成できる\nデバッグとテストができる\nコードの可読性と保守性を意識できる",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#次のステップ",
    "href": "book/99-self-review-1.html#次のステップ",
    "title": "17  自己評価: Python の基礎",
    "section": "17.5 💡 次のステップ",
    "text": "17.5 💡 次のステップ\nこの自己評価で自信がついたら、次の分野に進みましょう：\n\nオブジェクト指向プログラミング: クラスと継承\n高度なトピック: 型ヒント、非同期プログラミング\n実践的な応用: Webアプリケーション、データサイエンス\nツールとライブラリ: pandas、requests、Flask など",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "book/99-self-review-1.html#お疲れさまでした",
    "href": "book/99-self-review-1.html#お疲れさまでした",
    "title": "17  自己評価: Python の基礎",
    "section": "17.6 🎉 お疲れさまでした！",
    "text": "17.6 🎉 お疲れさまでした！\nPython の基礎をしっかりと学習されました。これらの概念は今後のプログラミング学習の土台となります。継続的に練習し、実際のプロジェクトで応用してください。\n\n17.6.1 学習のコツ\n\n実際にコードを書く: 読むだけでなく、手を動かして練習\n小さなプロジェクトから始める: 身近な問題を解決するプログラムを作成\nコミュニティに参加: オンラインフォーラムや勉強会で交流\n継続的な学習: 新しい機能やライブラリを定期的に学ぶ\n\n頑張ってください！🚀",
    "crumbs": [
      "応用・実践",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>自己評価: Python の基礎</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python チュートリアル",
    "section": "",
    "text": "Python チュートリアル\n包括的な Python チュートリアルへようこそ！この本では Python の基礎から応用まで学習できます。",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#学習内容",
    "href": "index.html#学習内容",
    "title": "Python チュートリアル",
    "section": "学習内容",
    "text": "学習内容\nこのチュートリアルは様々なスキルレベルに対応し、以下の内容をカバーします：\n\n環境構築 - uv、poetry、miniforge、Git/GitHub、VS Code\nPython の基本 - 構文、データ型、制御フロー、関数\nオブジェクト指向プログラミング - クラス、継承、高度なパターン\n高度なトピック - 型ヒント、非同期プログラミング、マルチプロセシング\n実際の応用 - データサイエンス、自動化、Web 開発",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#チュートリアルの特徴",
    "href": "index.html#チュートリアルの特徴",
    "title": "Python チュートリアル",
    "section": "チュートリアルの特徴",
    "text": "チュートリアルの特徴\n\n🖥️ インタラクティブな例 - 実行結果付きのコード\n📝 演習とクイズ - 理解度をテスト\n🚀 実践プロジェクト - 実際のアプリケーションを構築\n🎯 複数の形式 - 書籍、スライド、PDF\n🌐 バイリンガル - 英語と日本語で利用可能\n\n\n\n\n\n\n\n⚡ 新機能: ライブインタラクティブ Python + ファイルアップロード\n\n\n\nこのチュートリアルは Quarto Live と Quarto Drop を搭載 - ブラウザで直接 Python コードを実行・編集でき、独自のデータファイルもアップロード可能！インストール不要で、実データを使った実践的な学習がすぐに始められます。",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#前提条件",
    "href": "index.html#前提条件",
    "title": "Python チュートリアル",
    "section": "前提条件",
    "text": "前提条件\n\n基本的なコンピュータリテラシー\n学習と実験への意欲\nPython 3.12+（インストール方法も説明します！）",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#このチュートリアルの使い方",
    "href": "index.html#このチュートリアルの使い方",
    "title": "Python チュートリアル",
    "section": "このチュートリアルの使い方",
    "text": "このチュートリアルの使い方\n\n順次学習 - 最良の結果を得るために章順に進む\nコード実践 - すべての例を自分で実行する\n演習完了 - 学習を強化する\nプロジェクト構築 - 実際の問題に知識を適用する",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#書籍チャプター",
    "href": "index.html#書籍チャプター",
    "title": "Python チュートリアル",
    "section": "📚 書籍チャプター",
    "text": "📚 書籍チャプター\nPython の旅を始める準備はできましたか？環境構築から始めましょう！",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#インタラクティブ-revealjs-スライド",
    "href": "index.html#インタラクティブ-revealjs-スライド",
    "title": "Python チュートリアル",
    "section": "🎬 インタラクティブ RevealJS スライド",
    "text": "🎬 インタラクティブ RevealJS スライド\n完全なナビゲーション機能とモバイル最適化付きプロフェッショナルプレゼンテーション：\n🎯 スライドコレクションを見る →\n\n日本語スライド (完全版利用可能)\n基本概念: - 🚀 導入とセットアップ - Python と uv を始める - 📊 データ型とコレクション - リスト、辞書、セット - 🔀 制御フロー - If/else文、ループ - ⚙️ 関数 - 再利用可能なコードブロック - 🚨 エラーハンドリング - Try/except パターン\nコード組織: - 📦 モジュールとパッケージ - コード組織 - 🏗️ クラスとオブジェクト - オブジェクト指向プログラミング - 🔗 継承 - 高度な OOP 概念 - 🏷️ 型ヒント - 現代的な Python 型システム\n高度な応用: - 📈 データサイエンス - NumPy、Pandas、機械学習 - 🌐 IoT 接続と産業プロトコル - シリアル、Modbus、InfluxDB\n\n\nEnglish スライド (完全版利用可能)\nコア Python 概念: - 🚀 Introduction & Setup - Python と uv を始める - 📊 Data Types & Collections - リスト、辞書、セット - 🔀 Control Flow - If/else文、ループ - ⚙️ Functions - 再利用可能なコードブロック - 🚨 Error Handling - Try/except パターン\nコード組織: - 📦 Modules & Packages - コード組織 - 🏗️ Classes & Objects - オブジェクト指向プログラミング - 🔗 Inheritance - 高度な OOP 概念 - 🏷️ Type Hints - 現代的な Python 型システム\n高度な応用: - 📈 Data Science - NumPy、Pandas、機械学習 - 🌐 IoT Connectivity - Serial、Modbus、InfluxDB\n\n\n🎮 RevealJS 機能:\n\nナビゲーション: 矢印キー、マウスクリック、タッチジェスチャー (iPhone 対応)\nショートカット: ESC (概要表示), F (フルスクリーン), S (発表者モード)\nインタラクティブ: チョークボード (B キー)、メニュー、プログレスバー\nモバイル: スマートフォンを含むすべてのデバイスに最適化",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "index.html#言語ナビゲーション",
    "href": "index.html#言語ナビゲーション",
    "title": "Python チュートリアル",
    "section": "🌐 言語ナビゲーション",
    "text": "🌐 言語ナビゲーション\n\n🇯🇵 日本語 (現在) - 日本語版を表示中\n🇺🇸 English版 - 英語版に切り替え\n🏠 メインランディング - ホームページに戻る\n\n\nPython を学習する準備はできましたか？ 環境構築から始めるか、上記のインタラクティブスライドを探索してください！",
    "crumbs": [
      "Python チュートリアル"
    ]
  },
  {
    "objectID": "book/04-data-types.html",
    "href": "book/04-data-types.html",
    "title": "4  データ型とコレクション",
    "section": "",
    "text": "4.1 リスト - 順序付きコレクション\nPython は、データを効率的に整理・操作するための強力な組み込みデータ構造を提供しています。\nリストは異なるデータ型を保持できる可変シーケンスです：\n# リストの作成\nfruits = [\"apple\", \"banana\", \"cherry\"]\nnumbers = [1, 2, 3, 4, 5]\nmixed = [\"hello\", 42, 3.14, True]\n\nprint(\"果物:\", fruits)\nprint(\"数字:\", numbers)\nprint(\"混合型:\", mixed)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#リスト---順序付きコレクション",
    "href": "book/04-data-types.html#リスト---順序付きコレクション",
    "title": "4  データ型とコレクション",
    "section": "",
    "text": "4.1.1 リストの操作\n\ncolors = [\"red\", \"green\", \"blue\"]\n\n# 要素へのアクセス（0から始まるインデックス）\nprint(f\"最初の色: {colors[0]}\")\nprint(f\"最後の色: {colors[-1]}\")\n\n# 要素の追加\ncolors.append(\"yellow\")           # 末尾に追加\ncolors.insert(1, \"purple\")        # 指定位置に挿入\nprint(f\"追加後: {colors}\")\n\n# 要素の削除\ncolors.remove(\"purple\")           # 値で削除\nlast_color = colors.pop()         # 最後を削除して返す\nprint(f\"削除後: {colors}\")\nprint(f\"削除した色: {last_color}\")\n\n\n\n4.1.2 リストのメソッドとプロパティ\n\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\n\nprint(f\"元のリスト: {numbers}\")\nprint(f\"長さ: {len(numbers)}\")\nprint(f\"1の個数: {numbers.count(1)}\")\nprint(f\"4のインデックス: {numbers.index(4)}\")\n\n# ソート\nnumbers.sort()\nprint(f\"ソート後: {numbers}\")\n\n# 逆順\nnumbers.reverse()\nprint(f\"逆順: {numbers}\")\n\n# リスト内包表記（プレビュー）\nsquares = [x**2 for x in range(1, 6)]\nprint(f\"平方数: {squares}\")\n\n\n\n4.1.3 リストのスライシング\n\nletters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\nprint(f\"元のリスト: {letters}\")\nprint(f\"最初の3つ: {letters[:3]}\")\nprint(f\"最後の3つ: {letters[-3:]}\")\nprint(f\"中間: {letters[2:5]}\")\nprint(f\"2つおき: {letters[::2]}\")\nprint(f\"逆順: {letters[::-1]}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#タプル---不変シーケンス",
    "href": "book/04-data-types.html#タプル---不変シーケンス",
    "title": "4  データ型とコレクション",
    "section": "4.2 タプル - 不変シーケンス",
    "text": "4.2 タプル - 不変シーケンス\nタプルは不変シーケンスで、固定データに最適です：\n\n# タプルの作成\npoint = (10, 20)\nrgb_color = (255, 128, 0)\nperson = (\"Alice\", 25, \"Engineer\")\n\nprint(f\"座標: {point}\")\nprint(f\"RGB色: {rgb_color}\")\nprint(f\"人物情報: {person}\")\n\n# 要素へのアクセス\nprint(f\"X座標: {point[0]}\")\nprint(f\"Y座標: {point[1]}\")\n\n# タプルのアンパック\nname, age, job = person\nprint(f\"名前: {name}, 年齢: {age}, 職業: {job}\")\n\n\n4.2.1 タプルのメソッド\n\ngrades = (85, 92, 78, 92, 88, 92)\n\nprint(f\"成績: {grades}\")\nprint(f\"92の個数: {grades.count(92)}\")\nprint(f\"78のインデックス: {grades.index(78)}\")\nprint(f\"長さ: {len(grades)}\")\n\n# リストとタプルの変換\ngrades_list = list(grades)\nprint(f\"リストとして: {grades_list}\")\n\nnew_tuple = tuple([1, 2, 3, 4])\nprint(f\"リストから: {new_tuple}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#辞書---キー-値ペア",
    "href": "book/04-data-types.html#辞書---キー-値ペア",
    "title": "4  データ型とコレクション",
    "section": "4.3 辞書 - キー-値ペア",
    "text": "4.3 辞書 - キー-値ペア\n辞書はキー-値ペアとしてデータを格納します：\n\n# 辞書の作成\nstudent = {\n    \"name\": \"Alice\",\n    \"age\": 20,\n    \"major\": \"Computer Science\",\n    \"gpa\": 3.8\n}\n\nprint(\"学生情報:\", student)\n\n# 値へのアクセス\nprint(f\"名前: {student['name']}\")\nprint(f\"GPA: {student.get('gpa', '見つかりません')}\")\n\n# 値の追加/更新\nstudent[\"graduation_year\"] = 2025\nstudent[\"age\"] = 21\nprint(\"更新後:\", student)\n\n\n4.3.1 辞書のメソッド\n\ninventory = {\n    \"apples\": 50,\n    \"bananas\": 30,\n    \"oranges\": 25\n}\n\nprint(\"在庫:\", inventory)\n\n# 辞書のメソッド\nprint(\"キー:\", list(inventory.keys()))\nprint(\"値:\", list(inventory.values()))\nprint(\"アイテム:\", list(inventory.items()))\n\n# 存在確認\nprint(\"りんごあり:\", \"apples\" in inventory)\nprint(\"ぶどうあり:\", \"grapes\" in inventory)\n\n# 安全な削除\nremoved = inventory.pop(\"bananas\", 0)\nprint(f\"バナナを{removed}個削除\")\nprint(\"削除後:\", inventory)\n\n\n\n4.3.2 辞書の反復処理\n\nscores = {\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92}\n\n# キーの反復処理\nprint(\"学生:\")\nfor name in scores:\n    print(f\"  {name}\")\n\n# 値の反復処理\nprint(\"スコア:\")\nfor score in scores.values():\n    print(f\"  {score}\")\n\n# キー-値ペアの反復処理\nprint(\"学生スコア:\")\nfor name, score in scores.items():\n    print(f\"  {name}: {score}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#セット---一意なコレクション",
    "href": "book/04-data-types.html#セット---一意なコレクション",
    "title": "4  データ型とコレクション",
    "section": "4.4 セット - 一意なコレクション",
    "text": "4.4 セット - 一意なコレクション\nセットは一意な要素を格納し、数学的操作をサポートします：\n\n# セットの作成\nfruits = {\"apple\", \"banana\", \"cherry\"}\nnumbers = {1, 2, 3, 4, 5}\nmixed_set = {1, \"hello\", 3.14}\n\nprint(\"果物セット:\", fruits)\nprint(\"数字セット:\", numbers)\n\n# 要素の追加\nfruits.add(\"orange\")\nprint(\"オレンジ追加後:\", fruits)\n\n# 要素の削除\nfruits.discard(\"banana\")  # 安全な削除\nprint(\"バナナ削除後:\", fruits)\n\n\n4.4.1 セット演算\n\nset_a = {1, 2, 3, 4, 5}\nset_b = {4, 5, 6, 7, 8}\n\nprint(f\"セットA: {set_a}\")\nprint(f\"セットB: {set_b}\")\n\n# 数学的演算\nprint(f\"和集合 (A ∪ B): {set_a | set_b}\")\nprint(f\"積集合 (A ∩ B): {set_a & set_b}\")\nprint(f\"差集合 (A - B): {set_a - set_b}\")\nprint(f\"対称差集合: {set_a ^ set_b}\")\n\n# 包含テスト\nprint(f\"3 は A に含まれる: {3 in set_a}\")\nprint(f\"A は B の部分集合: {set_a.issubset(set_b)}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#適切なデータ構造の選択",
    "href": "book/04-data-types.html#適切なデータ構造の選択",
    "title": "4  データ型とコレクション",
    "section": "4.5 適切なデータ構造の選択",
    "text": "4.5 適切なデータ構造の選択\n\n\n\nデータ構造\n使用場面\n例\n\n\n\n\nリスト\n順序付き、可変コレクション\n買い物リスト、スコア\n\n\nタプル\n順序付き、不変コレクション\n座標、RGB値\n\n\n辞書\nキー-値マッピング\n学生記録、在庫\n\n\nセット\n一意な要素、高速検索\nタグ、一意ID\n\n\n\n\n# 実用的な例\nshopping_list = [\"milk\", \"bread\", \"eggs\"]        # リスト: 変更可能\ncoordinates = (40.7128, -74.0060)                # タプル: 固定点\nstudent_grades = {\"math\": 95, \"science\": 87}     # 辞書: 科目で検索\nunique_visitors = {\"alice\", \"bob\", \"charlie\"}     # セット: 重複なし",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#一般的なパターンと操作",
    "href": "book/04-data-types.html#一般的なパターンと操作",
    "title": "4  データ型とコレクション",
    "section": "4.6 一般的なパターンと操作",
    "text": "4.6 一般的なパターンと操作\n\n4.6.1 リスト内包表記\nリスト内包表記は、既存のシーケンスに基づいて新しいリストを簡潔に作成する方法です。従来のループよりも読みやすく、しばしば高速です。\n基本構文: [式 for 要素 in イテラブル if 条件]\n段階的に見てみましょう：\n\n# 従来の方法 - ループとappendを使用\nsquares = []\nfor x in range(1, 6):\n    squares.append(x**2)\nprint(\"従来型:\", squares)\n\n# リスト内包表記 - 1行で完結\n# これは「1から5までの各xについて、x²のリストを作成する」と読めます\nsquares = [x**2 for x in range(1, 6)]\nprint(\"内包表記:\", squares)\n\n# 条件付き - フィルタリングしながら変換\n# これは「1から10までの各xについて、xが偶数の場合のみx²のリストを作成する」\n# （x % 2 == 0 は余りが0、つまり偶数を意味します）\neven_squares = [x**2 for x in range(1, 11) if x % 2 == 0]\nprint(\"偶数の二乗:\", even_squares)\n\n# 文字列との組み合わせ - 各単語を変換\n# これは「wordsリストの各wordについて、word.upper()のリストを作成する」\nwords = [\"hello\", \"world\", \"python\"]\nuppercase = [word.upper() for word in words]\nprint(\"大文字:\", uppercase)\n\nなぜリスト内包表記を使うのか？ - 読みやすさ: 意図が1行で明確 - パフォーマンス: Pythonが内部的に最適化 - Pythonic: Pythonらしい書き方とされている",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#演習",
    "href": "book/04-data-types.html#演習",
    "title": "4  データ型とコレクション",
    "section": "7.1 演習",
    "text": "7.1 演習\n\n7.1.1 演習1: 学生管理システム\n\n# 学生管理システムを作成\nstudents = []\n\n# 学生を追加\ndef add_student(name, age, grades):\n    student = {\n        \"name\": name,\n        \"age\": age,\n        \"grades\": grades,\n        \"average\": sum(grades) / len(grades)\n    }\n    students.append(student)\n\n# 学生を追加\nadd_student(\"Alice\", 20, [95, 87, 92])\nadd_student(\"Bob\", 19, [78, 84, 88])\nadd_student(\"Charlie\", 21, [92, 96, 89])\n\n# 学生を表示\nprint(\"=== 学生記録 ===\")\nfor student in students:\n    print(f\"名前: {student['name']}\")\n    print(f\"年齢: {student['age']}\")\n    print(f\"成績: {student['grades']}\")\n    print(f\"平均: {student['average']:.1f}\")\n    print(\"-\" * 20)\n\n\n\n7.1.2 演習2: 単語頻度カウンター\n\n# テキスト内の単語頻度をカウント\ntext = \"python is great python is powerful python is fun\"\nwords = text.split()\n\n# 方法1: 辞書を使用\nword_count = {}\nfor word in words:\n    word_count[word] = word_count.get(word, 0) + 1\n\nprint(\"単語の頻度:\")\nfor word, count in word_count.items():\n    print(f\"{word}: {count}\")\n\n# 方法2: Counter を使用（collections から）\nfrom collections import Counter\nword_count_2 = Counter(words)\nprint(\"\\nCounter使用:\", dict(word_count_2))\n\n\n\n7.1.3 演習3: データでのセット演算\n\n# 学生の履修科目\nmath_students = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}\nscience_students = {\"Bob\", \"Charlie\", \"Eve\", \"Frank\"}\nenglish_students = {\"Alice\", \"Charlie\", \"Eve\", \"Grace\"}\n\nprint(\"数学受講生:\", math_students)\nprint(\"理科受講生:\", science_students)\nprint(\"英語受講生:\", english_students)\n\n# 分析\nboth_math_science = math_students & science_students\nprint(\"数学と理科の両方:\", both_math_science)\n\nall_students = math_students | science_students | english_students\nprint(\"全学生:\", all_students)\n\nonly_math = math_students - science_students - english_students\nprint(\"数学のみ:\", only_math)",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#自己確認問題",
    "href": "book/04-data-types.html#自己確認問題",
    "title": "4  データ型とコレクション",
    "section": "7.2 自己確認問題",
    "text": "7.2 自己確認問題\n\n7.2.1 知識チェック\n\nリストとタプルの違いは何ですか？\nリストの代わりに辞書を使うのはいつですか？\nセットに重複を追加しようとするとどうなりますか？\nリストの最後の要素にアクセスするにはどうしますか？\nリストのremove()とpop()の違いは何ですか？\n\n\n\n7.2.2 コーディングチャレンジ\n\n2つのリストの共通要素を見つける関数を作成\n2つの辞書をマージするプログラムを作成\nリスト内包表記を使ってリストから偶数をフィルタリング\nリスト内で最も頻繁に現れる要素を返す関数を作成\n\n\n\n7.2.3 回答\n\nリストは可変で順序付き；タプルは不変で順序付き\nキー-値の関連付けやキーによる高速検索が必要な時\n何も起こらない - セットは自動的に重複を処理\nmy_list[-1] または my_list[len(my_list)-1]\nremove()は値で削除；pop()はインデックスで削除して値を返す",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#ベストプラクティス",
    "href": "book/04-data-types.html#ベストプラクティス",
    "title": "4  データ型とコレクション",
    "section": "7.3 ベストプラクティス",
    "text": "7.3 ベストプラクティス\n\n用途に適したデータ構造を選択する\n簡単な変換にはリスト内包表記を使用する\n辞書の安全なアクセスにはget()メソッドを使用する\n包含テストと重複除去にはセットを使用する\n複数の代入にはタプルアンパックを使用する",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#よくある落とし穴",
    "href": "book/04-data-types.html#よくある落とし穴",
    "title": "4  データ型とコレクション",
    "section": "7.4 よくある落とし穴",
    "text": "7.4 よくある落とし穴\n\n反復処理中にリストを変更 - 最初にコピーを作成\n関数パラメータで可変なデフォルトを使用\n比較でisと==を混同\n辞書が挿入順序を保持することを忘れる（Python 3.7+）",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#パフォーマンスのヒント",
    "href": "book/04-data-types.html#パフォーマンスのヒント",
    "title": "4  データ型とコレクション",
    "section": "7.5 パフォーマンスのヒント",
    "text": "7.5 パフォーマンスのヒント\n\nimport time\n\n# 包含テストでのリスト vs セット\nlarge_list = list(range(10000))\nlarge_set = set(range(10000))\n\n# リストの検索時間\nstart = time.time()\n9999 in large_list\nlist_time = time.time() - start\n\n# セットの検索時間\nstart = time.time()\n9999 in large_set\nset_time = time.time() - start\n\nprint(f\"リスト検索: {list_time:.6f} 秒\")\nprint(f\"セット検索: {set_time:.6f} 秒\")\nprint(f\"包含テストでセットは{list_time/set_time:.1f}倍高速\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#次のステップ",
    "href": "book/04-data-types.html#次のステップ",
    "title": "4  データ型とコレクション",
    "section": "7.6 次のステップ",
    "text": "7.6 次のステップ\n素晴らしい！Python の核となるデータ構造を理解しました。次は 制御フロー について学び、プログラムで判断を下し、アクションを繰り返す方法を学びましょう。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/04-data-types.html#リソース",
    "href": "book/04-data-types.html#リソース",
    "title": "4  データ型とコレクション",
    "section": "7.7 リソース",
    "text": "7.7 リソース\n\nPython データ構造ドキュメント\nReal Python: Python データ構造\nCollections モジュール",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データ型とコレクション</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html",
    "href": "book/05-control-flow.html",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "",
    "text": "5.1 条件文 - if、elif、else\n制御フロー文により、プログラムが条件に基づいて判断を行い、処理を繰り返すことができます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#条件文---ifelifelse",
    "href": "book/05-control-flow.html#条件文---ifelifelse",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "",
    "text": "5.1.1 基本的な if 文\n\nage = 18\n\nif age &gt;= 18:\n    print(\"あなたは成人です\")\n    print(\"投票できます\")\n\nprint(\"この行は常に実行されます\")\n\n\n\n5.1.2 if-else 文\n\ntemperature = 25\n\nif temperature &gt; 30:\n    print(\"外は暑いです！\")\n    print(\"水分補給を忘れずに\")\nelse:\n    print(\"それほど暑くありません\")\n    print(\"完璧な天気です\")\n\nprint(f\"現在の気温: {temperature}°C\")\n\n\n\n5.1.3 if-elif-else チェーン\n\nscore = 85\n\nif score &gt;= 90:\n    grade = \"A\"\n    message = \"素晴らしい！\"\nelif score &gt;= 80:\n    grade = \"B\"\n    message = \"よくできました！\"\nelif score &gt;= 70:\n    grade = \"C\"\n    message = \"頑張り続けましょう！\"\nelif score &gt;= 60:\n    grade = \"D\"\n    message = \"改善が必要です\"\nelse:\n    grade = \"F\"\n    message = \"もっと勉強しましょう\"\n\nprint(f\"得点: {score}\")\nprint(f\"評価: {grade}\")\nprint(f\"コメント: {message}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#ループ---処理の繰り返し",
    "href": "book/05-control-flow.html#ループ---処理の繰り返し",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.2 ループ - 処理の繰り返し",
    "text": "5.2 ループ - 処理の繰り返し\n\n5.2.1 for ループ\n\n# リストを使った繰り返し\nfruits = [\"りんご\", \"バナナ\", \"さくらんぼ\"]\n\nfor fruit in fruits:\n    print(f\"私は{fruit}が好きです\")\n\n\n# range() を使った数値の繰り返し\nprint(\"1から5までの数字:\")\nfor i in range(1, 6):\n    print(f\"数字: {i}\")\n\n\n# 九九の表\nprint(\"九九の表:\")\nfor i in range(1, 10):\n    for j in range(1, 10):\n        result = i * j\n        print(f\"{i} × {j} = {result:2d}\", end=\"  \")\n    print()  # 改行\n\n\n\n5.2.2 while ループ\n\n# カウントダウン\ncount = 5\nprint(\"カウントダウン開始:\")\n\nwhile count &gt; 0:\n    print(f\"{count}...\")\n    count -= 1\n\nprint(\"発射！🚀\")\n\n\n# ユーザー入力のシミュレーション（実際の例）\nimport random\n\n# ランダムな数字を生成\nsecret_number = random.randint(1, 10)\nattempts = 0\nmax_attempts = 3\n\nprint(\"1から10の数字を当ててください！\")\nprint(f\"ヒント: 秘密の数字は {secret_number} です（実際のゲームでは表示されません）\")\n\n# シミュレートされた推測\nguesses = [5, 8, secret_number]  # 実際の例では input() を使用\n\nfor guess in guesses:\n    attempts += 1\n    print(f\"推測 {attempts}: {guess}\")\n    \n    if guess == secret_number:\n        print(\"正解です！🎉\")\n        break\n    elif guess &lt; secret_number:\n        print(\"もっと大きい数字です\")\n    else:\n        print(\"もっと小さい数字です\")\n    \n    if attempts &gt;= max_attempts:\n        print(f\"残念！正解は {secret_number} でした\")\n        break",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#ループ制御文",
    "href": "book/05-control-flow.html#ループ制御文",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.3 ループ制御文",
    "text": "5.3 ループ制御文\n\n5.3.1 break - ループの中断\n\n# 特定の条件でループを終了\nnumbers = [1, 3, 5, 8, 9, 11, 13]\n\nprint(\"最初の偶数を探しています...\")\nfor num in numbers:\n    print(f\"チェック中: {num}\")\n    if num % 2 == 0:\n        print(f\"見つかりました！最初の偶数は {num} です\")\n        break\nelse:\n    print(\"偶数が見つかりませんでした\")\n\n\n\n5.3.2 continue - 次の反復へスキップ\n\n# 奇数のみを表示\nprint(\"1から10の奇数:\")\nfor i in range(1, 11):\n    if i % 2 == 0:  # 偶数の場合\n        continue    # 残りの処理をスキップ\n    print(f\"奇数: {i}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#実践的な例",
    "href": "book/05-control-flow.html#実践的な例",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.4 実践的な例",
    "text": "5.4 実践的な例\n\n5.4.1 成績計算システム\n\n# 学生の成績を処理\nstudents = [\n    {\"名前\": \"田中\", \"得点\": [85, 90, 78]},\n    {\"名前\": \"鈴木\", \"得点\": [92, 88, 95]},\n    {\"名前\": \"佐藤\", \"得点\": [76, 82, 80]}\n]\n\nprint(\"=== 成績レポート ===\")\nfor student in students:\n    name = student[\"名前\"]\n    scores = student[\"得点\"]\n    \n    # 平均点を計算\n    average = sum(scores) / len(scores)\n    \n    # 評価を決定\n    if average &gt;= 90:\n        grade = \"A\"\n    elif average &gt;= 80:\n        grade = \"B\"\n    elif average &gt;= 70:\n        grade = \"C\"\n    else:\n        grade = \"D\"\n    \n    print(f\"学生: {name}\")\n    print(f\"  得点: {scores}\")\n    print(f\"  平均: {average:.1f}\")\n    print(f\"  評価: {grade}\")\n    print()\n\n\n\n5.4.2 パスワード強度チェッカー\n\ndef check_password_strength(password):\n    \"\"\"パスワードの強度をチェックする関数\"\"\"\n    \n    # 初期設定\n    score = 0\n    feedback = []\n    \n    # 長さをチェック\n    if len(password) &gt;= 8:\n        score += 1\n    else:\n        feedback.append(\"8文字以上にしてください\")\n    \n    # 文字の種類をチェック\n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    has_special = any(c in \"!@#$%^&*\" for c in password)\n    \n    if has_upper:\n        score += 1\n    else:\n        feedback.append(\"大文字を含めてください\")\n        \n    if has_lower:\n        score += 1\n    else:\n        feedback.append(\"小文字を含めてください\")\n        \n    if has_digit:\n        score += 1\n    else:\n        feedback.append(\"数字を含めてください\")\n        \n    if has_special:\n        score += 1\n    else:\n        feedback.append(\"特殊文字を含めてください\")\n    \n    # 強度を評価\n    if score &gt;= 4:\n        strength = \"強い\"\n    elif score &gt;= 3:\n        strength = \"普通\"\n    else:\n        strength = \"弱い\"\n    \n    return strength, feedback\n\n# テスト例\ntest_passwords = [\"123\", \"password\", \"Password1\", \"MyStrongP@ss1\"]\n\nfor password in test_passwords:\n    strength, feedback = check_password_strength(password)\n    print(f\"パスワード: '{password}'\")\n    print(f\"強度: {strength}\")\n    if feedback:\n        print(\"改善点:\")\n        for suggestion in feedback:\n            print(f\"  - {suggestion}\")\n    print()",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#練習問題",
    "href": "book/05-control-flow.html#練習問題",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.5 練習問題",
    "text": "5.5 練習問題\n\n5.5.1 問題 1: FizzBuzz\n1から30までの数字を表示し、以下のルールに従ってください： - 3の倍数の場合は “Fizz” を表示 - 5の倍数の場合は “Buzz” を表示\n- 3と5の両方の倍数の場合は “FizzBuzz” を表示\n\nprint(\"=== FizzBuzz ===\")\nfor i in range(1, 31):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)\n\n\n\n5.5.2 問題 2: 素数判定\n\ndef is_prime(n):\n    \"\"\"数字が素数かどうかを判定\"\"\"\n    if n &lt; 2:\n        return False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# 1から50までの素数を表示\nprint(\"1から50までの素数:\")\nprimes = []\nfor num in range(1, 51):\n    if is_prime(num):\n        primes.append(num)\n\nprint(primes)\nprint(f\"見つかった素数の数: {len(primes)}\")",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#まとめ",
    "href": "book/05-control-flow.html#まとめ",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.6 まとめ",
    "text": "5.6 まとめ\nこの章では以下を学習しました：\n\n条件文: if、elif、else を使った判断処理\nループ: for と while を使った繰り返し処理\nループ制御: break と continue の使い方\n実践例: 成績処理、パスワード強度チェック\nアルゴリズム: FizzBuzz、素数判定\n\n制御フローはプログラミングの基本中の基本です。これらの概念をしっかりと理解し、様々な問題解決に活用しましょう。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  },
  {
    "objectID": "book/05-control-flow.html#次の章",
    "href": "book/05-control-flow.html#次の章",
    "title": "5  制御フロー - 条件分岐とループ",
    "section": "5.7 次の章",
    "text": "5.7 次の章\n次は関数について学習し、コードを整理して再利用可能にする方法を学びます。",
    "crumbs": [
      "Python の基本",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>制御フロー - 条件分岐とループ</span>"
    ]
  }
]