---
title: "å‹ãƒ’ãƒ³ãƒˆã¨é™çš„å‹ä»˜ã‘"
subtitle: "Pythonã‚³ãƒ¼ãƒ‰ã‚’ã‚ˆã‚Šå …ç‰¢ã«ã™ã‚‹"
---

# å‹ãƒ’ãƒ³ãƒˆ {background-color="#2E86AB"}

## å‹ãƒ’ãƒ³ãƒˆã¨ã¯ï¼Ÿ

::: {.incremental}
- **Python 3.5+** ã§å°å…¥ã•ã‚ŒãŸ**ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½**
- å¤‰æ•°ã‚„é–¢æ•°ã®**æœŸå¾…ã•ã‚Œã‚‹å‹ã‚’æ˜ç¤º**
- å®Ÿè¡Œæ™‚ã«ã¯**å½±éŸ¿ã—ãªã„**ï¼ˆç´”ç²‹ã«ãƒ’ãƒ³ãƒˆï¼‰
- **IDE**, **å‹ãƒã‚§ãƒƒã‚«ãƒ¼**, **é–‹ç™ºè€…**ãŒç†è§£ã—ã‚„ã™ãã™ã‚‹
- **å¤§è¦æ¨¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**ã§ã®ä¿å®ˆæ€§å‘ä¸Š
:::

::: {.fragment}
```python
# å‹ãƒ’ãƒ³ãƒˆãªã—
def add(a, b):
    return a + b

# å‹ãƒ’ãƒ³ãƒˆã‚ã‚Š
def add(a: int, b: int) -> int:
    return a + b

# ä½¿ç”¨ä¾‹
result: int = add(5, 3)  # å¤‰æ•°ã«ã‚‚å‹ãƒ’ãƒ³ãƒˆå¯èƒ½
```
:::

## åŸºæœ¬çš„ãªå‹ãƒ’ãƒ³ãƒˆ

::: {.fragment}
```python
# åŸºæœ¬å‹
name: str = "å¤ªéƒ"
age: int = 25
height: float = 170.5
is_student: bool = True

# é–¢æ•°ã®å‹ãƒ’ãƒ³ãƒˆ
def greet(name: str) -> str:
    return f"ã“ã‚“ã«ã¡ã¯ã€{name}ã•ã‚“ï¼"

def calculate_area(radius: float) -> float:
    return 3.14159 * radius ** 2

def print_info(name: str, age: int) -> None:  # æˆ»ã‚Šå€¤ãªã—
    print(f"{name}ã•ã‚“ã¯{age}æ­³ã§ã™")

# ä½¿ç”¨ä¾‹
message: str = greet("èŠ±å­")
area: float = calculate_area(5.0)
print_info("æ¬¡éƒ", 30)
```
:::

## ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã®ãƒ’ãƒ³ãƒˆ

::: {.fragment}
```python
from typing import List, Dict, Tuple, Set, Optional

# ãƒªã‚¹ãƒˆå‹
numbers: List[int] = [1, 2, 3, 4, 5]
names: List[str] = ["å¤ªéƒ", "èŠ±å­", "æ¬¡éƒ"]

# è¾æ›¸å‹
student: Dict[str, int] = {"å¤ªéƒ": 85, "èŠ±å­": 92}
config: Dict[str, str] = {"host": "localhost", "port": "8080"}

# ã‚¿ãƒ—ãƒ«å‹
point: Tuple[int, int] = (10, 20)
person: Tuple[str, int, bool] = ("å¤ªéƒ", 25, True)

# ã‚»ãƒƒãƒˆå‹
unique_numbers: Set[int] = {1, 2, 3, 4, 5}

# ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å‹ï¼ˆNone ãŒè¨±å¯ã•ã‚Œã‚‹ï¼‰
maybe_name: Optional[str] = None  # str | None ã¨åŒã˜
maybe_age: Optional[int] = 25

def find_user(user_id: int) -> Optional[str]:
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢ã—ã€è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°Noneã‚’è¿”ã™"""
    users = {1: "å¤ªéƒ", 2: "èŠ±å­"}
    return users.get(user_id)

# ä½¿ç”¨ä¾‹
user: Optional[str] = find_user(1)  # "å¤ªéƒ"
unknown: Optional[str] = find_user(99)  # None
```
:::

## é–¢æ•°å‹ã®ãƒ’ãƒ³ãƒˆ

::: {.fragment}
```python
from typing import Callable, List, Any

# é–¢æ•°å‹
def apply_operation(numbers: List[int], operation: Callable[[int], int]) -> List[int]:
    """æ•°å€¤ãƒªã‚¹ãƒˆã«æ“ä½œã‚’é©ç”¨"""
    return [operation(num) for num in numbers]

def square(x: int) -> int:
    return x ** 2

def double(x: int) -> int:
    return x * 2

# ä½¿ç”¨ä¾‹
numbers = [1, 2, 3, 4, 5]
squared = apply_operation(numbers, square)    # [1, 4, 9, 16, 25]
doubled = apply_operation(numbers, double)    # [2, 4, 6, 8, 10]

# ã‚ˆã‚Šè¤‡é›‘ãªé–¢æ•°å‹
Calculator = Callable[[float, float], float]

def add(a: float, b: float) -> float:
    return a + b

def multiply(a: float, b: float) -> float:
    return a * b

def perform_calculation(calc: Calculator, x: float, y: float) -> float:
    return calc(x, y)

result1 = perform_calculation(add, 5.0, 3.0)       # 8.0
result2 = perform_calculation(multiply, 4.0, 2.0)  # 8.0
```
:::

## ã‚¯ãƒ©ã‚¹ã®å‹ãƒ’ãƒ³ãƒˆ

::: {.fragment}
```python
from typing import List, Optional, ClassVar
from dataclasses import dataclass

class Student:
    # ã‚¯ãƒ©ã‚¹å¤‰æ•°ã®å‹ãƒ’ãƒ³ãƒˆ
    school_name: ClassVar[str] = "Pythoné«˜æ ¡"
    total_students: ClassVar[int] = 0
    
    def __init__(self, name: str, student_id: str, grades: Optional[List[int]] = None):
        self.name: str = name
        self.student_id: str = student_id
        self.grades: List[int] = grades or []
        Student.total_students += 1
    
    def add_grade(self, grade: int) -> None:
        self.grades.append(grade)
    
    def get_average(self) -> Optional[float]:
        if not self.grades:
            return None
        return sum(self.grades) / len(self.grades)
    
    def __str__(self) -> str:
        return f"Student({self.name}, {self.student_id})"

# ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ï¼ˆè‡ªå‹•çš„ã«å‹ãƒ’ãƒ³ãƒˆå¯¾å¿œï¼‰
@dataclass
class Point:
    x: float
    y: float
    
    def distance_from_origin(self) -> float:
        return (self.x ** 2 + self.y ** 2) ** 0.5

@dataclass
class Course:
    name: str
    credits: int
    students: List[Student]
    instructor: Optional[str] = None
    
    def add_student(self, student: Student) -> None:
        self.students.append(student)
    
    def get_enrollment_count(self) -> int:
        return len(self.students)

# ä½¿ç”¨ä¾‹
student1 = Student("å¤ªéƒ", "S001", [85, 92, 78])
student2 = Student("èŠ±å­", "S002")

course = Course("Pythonå…¥é–€", 3, [student1])
course.add_student(student2)

point = Point(3.0, 4.0)
distance: float = point.distance_from_origin()  # 5.0
```
:::

## Unionå‹ã¨æ–°ã—ã„æ§‹æ–‡ï¼ˆPython 3.10+ï¼‰

::: {.fragment}
```python
from typing import Union, List, Dict

# Unionå‹ï¼ˆè¤‡æ•°ã®å‹ã‚’è¨±å¯ï¼‰
def process_id(user_id: Union[int, str]) -> str:
    return str(user_id).upper()

# Python 3.10+ ã®æ–°ã—ã„æ§‹æ–‡
def process_id_new(user_id: int | str) -> str:
    return str(user_id).upper()

# è¤‡é›‘ãªUnionå‹
ApiResponse = Union[Dict[str, str], List[Dict[str, str]], str]

def handle_api_response(response: ApiResponse) -> None:
    if isinstance(response, dict):
        print(f"å˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ: {response}")
    elif isinstance(response, list):
        print(f"é…åˆ—ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {len(response)}å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ")
    else:
        print(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {response}")

# Optional ã¯ Union[T, None] ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
def find_by_name(name: str) -> Optional[Student]:
    # Python 3.10+ã§ã¯ Student | None
    pass

# ä½¿ç”¨ä¾‹
process_id(123)        # "123"
process_id("abc")      # "ABC"

handle_api_response({"status": "success"})
handle_api_response([{"id": 1}, {"id": 2}])
handle_api_response("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ")
```
:::

## ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹

::: {.fragment}
```python
from typing import TypeVar, Generic, List, Optional

# å‹å¤‰æ•°ã‚’å®šç¾©
T = TypeVar('T')

class Stack(Generic[T]):
    """ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãªã‚¹ã‚¿ãƒƒã‚¯å®Ÿè£…"""
    
    def __init__(self) -> None:
        self._items: List[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> Optional[T]:
        if self._items:
            return self._items.pop()
        return None
    
    def peek(self) -> Optional[T]:
        if self._items:
            return self._items[-1]
        return None
    
    def is_empty(self) -> bool:
        return len(self._items) == 0
    
    def size(self) -> int:
        return len(self._items)

# ä½¿ç”¨ä¾‹
# æ–‡å­—åˆ—ã‚¹ã‚¿ãƒƒã‚¯
string_stack: Stack[str] = Stack()
string_stack.push("Hello")
string_stack.push("World")
top_string: Optional[str] = string_stack.pop()  # "World"

# æ•´æ•°ã‚¹ã‚¿ãƒƒã‚¯
int_stack: Stack[int] = Stack()
int_stack.push(1)
int_stack.push(2)
top_int: Optional[int] = int_stack.pop()  # 2

# ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°
def get_first_item(items: List[T]) -> Optional[T]:
    return items[0] if items else None

first_str: Optional[str] = get_first_item(["a", "b", "c"])  # "a"
first_int: Optional[int] = get_first_item([1, 2, 3])       # 1
```
:::

## å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã®ä½¿ç”¨

::: {.fragment}
```python
# mypy ã§ã®ãƒã‚§ãƒƒã‚¯ä¾‹

def calculate_discount(price: float, discount_rate: float) -> float:
    if discount_rate < 0 or discount_rate > 1:
        raise ValueError("å‰²å¼•ç‡ã¯0-1ã®é–“ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
    return price * (1 - discount_rate)

# æ­£ã—ã„ä½¿ç”¨
final_price: float = calculate_discount(100.0, 0.1)  # OK

# å‹ã‚¨ãƒ©ãƒ¼ï¼ˆmypyãŒæ¤œå‡ºï¼‰
# final_price = calculate_discount("100", "0.1")  # error: Argument 1 has incompatible type
# final_price = calculate_discount(100.0)         # error: Too few arguments

# pyright ã§ã®è¨­å®šä¾‹ï¼ˆpyproject.tomlï¼‰
"""
[tool.pyright]
include = ["src"]
exclude = ["**/__pycache__"]
reportMissingImports = true
reportMissingTypeStubs = false
pythonVersion = "3.12"
"""

# mypyã§ã®è¨­å®šä¾‹ï¼ˆmypy.iniï¼‰
"""
[mypy]
python_version = 3.12
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
"""
```
:::

## å®Ÿè·µæ¼”ç¿’ {background-color="#F18F01"}

## æ¼”ç¿’: å‹ãƒ’ãƒ³ãƒˆä»˜ããƒ©ã‚¤ãƒ–ãƒ©ãƒª

::: {.fragment}
```python
from typing import List, Dict, Optional, Union, Callable, TypeVar, Generic
from dataclasses import dataclass
from datetime import datetime

# å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
UserId = int
BookId = str
ISBN = str

@dataclass
class User:
    id: UserId
    name: str
    email: str
    registration_date: datetime
    
    def __str__(self) -> str:
        return f"User(id={self.id}, name='{self.name}')"

@dataclass 
class Book:
    id: BookId
    title: str
    author: str
    isbn: ISBN
    available_copies: int
    
    def is_available(self) -> bool:
        return self.available_copies > 0
    
    def __str__(self) -> str:
        return f"Book('{self.title}' by {self.author})"

@dataclass
class BorrowRecord:
    user_id: UserId
    book_id: BookId
    borrow_date: datetime
    return_date: Optional[datetime] = None
    
    def is_returned(self) -> bool:
        return self.return_date is not None

class LibraryError(Exception):
    """å›³æ›¸é¤¨é–¢é€£ã®ã‚¨ãƒ©ãƒ¼"""
    pass

class Library:
    def __init__(self, name: str) -> None:
        self.name: str = name
        self.users: Dict[UserId, User] = {}
        self.books: Dict[BookId, Book] = {}
        self.borrow_records: List[BorrowRecord] = []
        self._next_user_id: UserId = 1
    
    def register_user(self, name: str, email: str) -> User:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç™»éŒ²"""
        user = User(
            id=self._next_user_id,
            name=name,
            email=email,
            registration_date=datetime.now()
        )
        self.users[user.id] = user
        self._next_user_id += 1
        return user
    
    def add_book(self, title: str, author: str, isbn: ISBN, copies: int = 1) -> Book:
        """æœ¬ã‚’è¿½åŠ """
        book_id = f"B{len(self.books) + 1:04d}"
        book = Book(
            id=book_id,
            title=title,
            author=author,
            isbn=isbn,
            available_copies=copies
        )
        self.books[book_id] = book
        return book
    
    def find_user(self, user_id: UserId) -> Optional[User]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢"""
        return self.users.get(user_id)
    
    def find_book(self, book_id: BookId) -> Optional[Book]:
        """æœ¬ã‚’æ¤œç´¢"""
        return self.books.get(book_id)
    
    def search_books(self, query: str) -> List[Book]:
        """æœ¬ã‚’æ¤œç´¢ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ã¾ãŸã¯è‘—è€…ï¼‰"""
        query_lower = query.lower()
        results: List[Book] = []
        
        for book in self.books.values():
            if (query_lower in book.title.lower() or 
                query_lower in book.author.lower()):
                results.append(book)
        
        return results
    
    def borrow_book(self, user_id: UserId, book_id: BookId) -> BorrowRecord:
        """æœ¬ã‚’è²¸ã—å‡ºã—"""
        user = self.find_user(user_id)
        if not user:
            raise LibraryError(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ID {user_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        
        book = self.find_book(book_id)
        if not book:
            raise LibraryError(f"æœ¬ID {book_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        
        if not book.is_available():
            raise LibraryError(f"'{book.title}' ã¯ç¾åœ¨è²¸å‡ºä¸­ã§ã™")
        
        # è²¸ã—å‡ºã—è¨˜éŒ²ã‚’ä½œæˆ
        record = BorrowRecord(
            user_id=user_id,
            book_id=book_id,
            borrow_date=datetime.now()
        )
        
        # åœ¨åº«ã‚’æ¸›ã‚‰ã™
        book.available_copies -= 1
        self.borrow_records.append(record)
        
        return record
    
    def return_book(self, user_id: UserId, book_id: BookId) -> bool:
        """æœ¬ã‚’è¿”å´"""
        # æœªè¿”å´ã®è¨˜éŒ²ã‚’æ¤œç´¢
        for record in self.borrow_records:
            if (record.user_id == user_id and 
                record.book_id == book_id and 
                not record.is_returned()):
                
                # è¿”å´å‡¦ç†
                record.return_date = datetime.now()
                book = self.find_book(book_id)
                if book:
                    book.available_copies += 1
                return True
        
        return False
    
    def get_user_borrowed_books(self, user_id: UserId) -> List[Book]:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å€Ÿç”¨ä¸­ã®æœ¬ã‚’å–å¾—"""
        borrowed_books: List[Book] = []
        
        for record in self.borrow_records:
            if record.user_id == user_id and not record.is_returned():
                book = self.find_book(record.book_id)
                if book:
                    borrowed_books.append(book)
        
        return borrowed_books
    
    def get_overdue_books(self, days: int = 14) -> List[tuple[User, Book, int]]:
        """å»¶æ»æœ¬ã®ä¸€è¦§ã‚’å–å¾—"""
        from datetime import timedelta
        
        overdue: List[tuple[User, Book, int]] = []
        cutoff_date = datetime.now() - timedelta(days=days)
        
        for record in self.borrow_records:
            if not record.is_returned() and record.borrow_date < cutoff_date:
                user = self.find_user(record.user_id)
                book = self.find_book(record.book_id)
                if user and book:
                    days_overdue = (datetime.now() - record.borrow_date).days
                    overdue.append((user, book, days_overdue))
        
        return overdue

# ä½¿ç”¨ä¾‹ã¨ãƒ†ã‚¹ãƒˆ
def main() -> None:
    # å›³æ›¸é¤¨ã‚’ä½œæˆ
    library = Library("å¸‚ç«‹å›³æ›¸é¤¨")
    
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
    user1 = library.register_user("ç”°ä¸­å¤ªéƒ", "tanaka@example.com")
    user2 = library.register_user("ä½è—¤èŠ±å­", "sato@example.com")
    
    # æœ¬ã‚’è¿½åŠ 
    book1 = library.add_book("Pythonå…¥é–€", "å±±ç”°ä¸€éƒ", "978-1234567890", 3)
    book2 = library.add_book("ãƒ‡ãƒ¼ã‚¿åˆ†æ", "éˆ´æœ¨æ¬¡éƒ", "978-0987654321", 2)
    book3 = library.add_book("æ©Ÿæ¢°å­¦ç¿’", "ç”°ä¸­ä¸‰éƒ", "978-1111111111", 1)
    
    # æœ¬ã‚’æ¤œç´¢
    search_results: List[Book] = library.search_books("Python")
    print(f"æ¤œç´¢çµæœ: {len(search_results)}å†Š")
    
    # è²¸ã—å‡ºã—
    try:
        record1 = library.borrow_book(user1.id, book1.id)
        record2 = library.borrow_book(user2.id, book2.id)
        print("è²¸ã—å‡ºã—æˆåŠŸ")
    except LibraryError as e:
        print(f"ã‚¨ãƒ©ãƒ¼: {e}")
    
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å€Ÿç”¨æœ¬ç¢ºèª
    borrowed: List[Book] = library.get_user_borrowed_books(user1.id)
    print(f"{user1.name}ã®å€Ÿç”¨æœ¬: {len(borrowed)}å†Š")
    
    # è¿”å´
    success: bool = library.return_book(user1.id, book1.id)
    print(f"è¿”å´æˆåŠŸ: {success}")

if __name__ == "__main__":
    main()
```
:::

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ {background-color="#A23B72"}

::: {.incremental}
1. **æ®µéšçš„å°å…¥** - æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã«å¾ã€…ã«å‹ãƒ’ãƒ³ãƒˆã‚’è¿½åŠ 
2. **å…¬é–‹APIå„ªå…ˆ** - ã¾ãšé–¢æ•°ã®å¼•æ•°ã¨æˆ»ã‚Šå€¤ã‹ã‚‰
3. **å‹ãƒã‚§ãƒƒã‚«ãƒ¼ä½¿ç”¨** - mypy, pyright ã§å®šæœŸçš„ãƒã‚§ãƒƒã‚¯
4. **Union ã¯æœ€å°é™ã«** - å¯èƒ½ãªé™ã‚Šå…·ä½“çš„ãªå‹ã‚’ä½¿ç”¨
5. **å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ´»ç”¨** - è¤‡é›‘ãªå‹ã«åˆ†ã‹ã‚Šã‚„ã™ã„åå‰ã‚’ä»˜ã‘ã‚‹
:::

## æ¬¡ã®å†…å®¹

::: {.incremental}
- **éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°** (async/await)
- **ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚·ãƒ³ã‚°** (ä¸¦åˆ—å‡¦ç†)
- **ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹** (NumPy, Pandas)
- **å®Ÿä¸–ç•Œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³** (Webé–‹ç™ºã€è‡ªå‹•åŒ–)
:::

## ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼ {background-color="#C73E1D"}

### è³ªå•ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

æ¬¡ã¯ [éåŒæœŸå‡¦ç†](../book/10-async.html) ã«é€²ã¿ã¾ã—ã‚‡ã†ï¼

---

**ãƒªã‚½ãƒ¼ã‚¹:**
- [Python.org - å‹ãƒ’ãƒ³ãƒˆ](https://docs.python.org/ja/3/library/typing.html)
- [mypy ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://mypy.readthedocs.io/)
- [Real Python - å‹ãƒ’ãƒ³ãƒˆ](https://realpython.com/python-type-checking/)

---

## ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³

::: {.columns}
::: {.column width="33%"}
**å‰ã¸:**  
[ç¶™æ‰¿](08-inheritance.html)
:::
::: {.column width="33%"}
**ãƒ›ãƒ¼ãƒ :**  
[ğŸ“š ã‚¹ãƒ©ã‚¤ãƒ‰ä¸€è¦§](index.html) | [ğŸ“– ãƒ–ãƒƒã‚¯](../book/index.html)
:::
::: {.column width="33%"}
**æ¬¡ã¸:**  
[ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚¨ãƒ³ã‚¹](12-data-science.html)
:::
:::