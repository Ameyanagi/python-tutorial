# IoTæ¥ç¶šã¨ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡

Pythonã‚’ä½¿ç”¨ã—ã¦IoTãƒ‡ãƒã‚¤ã‚¹ã‚„ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã¨é€£æºã—ã€å®Ÿä¸–ç•Œã®ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ãƒ»åˆ¶å¾¡ã™ã‚‹æ–¹æ³•ã‚’å­¦ç¿’ã—ã¾ã™ã€‚

## IoTåŸºç¤ã¨Python

### IoTã‚·ã‚¹ãƒ†ãƒ ã®æ¦‚è¦

```{python}
import time
import random
import json
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum

class SensorType(Enum):
    """ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—"""
    TEMPERATURE = "æ¸©åº¦"
    HUMIDITY = "æ¹¿åº¦"
    PRESSURE = "æ°—åœ§"
    LIGHT = "å…‰"
    MOTION = "å‹•ä½œ"
    SOUND = "éŸ³"
    GAS = "ã‚¬ã‚¹"

@dataclass
class SensorReading:
    """ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤"""
    sensor_id: str
    sensor_type: SensorType
    value: float
    unit: str
    timestamp: datetime
    location: str = ""
    
    def to_dict(self) -> Dict:
        return {
            "sensor_id": self.sensor_id,
            "sensor_type": self.sensor_type.value,
            "value": self.value,
            "unit": self.unit,
            "timestamp": self.timestamp.isoformat(),
            "location": self.location
        }

class IoTDevice:
    """IoTãƒ‡ãƒã‚¤ã‚¹åŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, device_id: str, name: str, location: str = ""):
        self.device_id = device_id
        self.name = name
        self.location = location
        self.is_connected = False
        self.last_seen = None
        self.readings_history: List[SensorReading] = []
    
    def connect(self) -> bool:
        """ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶š"""
        print(f"ğŸ”Œ ãƒ‡ãƒã‚¤ã‚¹æ¥ç¶šä¸­: {self.name} ({self.device_id})")
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€WiFiã€Bluetoothã€ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ãªã©ã‚’ä½¿ç”¨
        self.is_connected = True
        self.last_seen = datetime.now()
        print(f"âœ… æ¥ç¶šæˆåŠŸ: {self.name}")
        return True
    
    def disconnect(self):
        """ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰åˆ‡æ–­"""
        print(f"ğŸ”Œ ãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­: {self.name}")
        self.is_connected = False
    
    def read_sensor(self, sensor_type: SensorType) -> Optional[SensorReading]:
        """ã‚»ãƒ³ã‚µãƒ¼å€¤ã‚’èª­ã¿å–ã‚Š"""
        if not self.is_connected:
            print(f"âŒ ãƒ‡ãƒã‚¤ã‚¹æœªæ¥ç¶š: {self.name}")
            return None
        
        # ã‚»ãƒ³ã‚µãƒ¼å€¤ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        value, unit = self._simulate_sensor_reading(sensor_type)
        
        reading = SensorReading(
            sensor_id=f"{self.device_id}_{sensor_type.name}",
            sensor_type=sensor_type,
            value=value,
            unit=unit,
            timestamp=datetime.now(),
            location=self.location
        )
        
        self.readings_history.append(reading)
        self.last_seen = datetime.now()
        
        print(f"ğŸ“Š {self.name}: {sensor_type.value} = {value}{unit}")
        return reading
    
    def _simulate_sensor_reading(self, sensor_type: SensorType) -> tuple:
        """ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ"""
        if sensor_type == SensorType.TEMPERATURE:
            return round(random.uniform(18.0, 30.0), 1), "Â°C"
        elif sensor_type == SensorType.HUMIDITY:
            return round(random.uniform(40.0, 80.0), 1), "%"
        elif sensor_type == SensorType.PRESSURE:
            return round(random.uniform(1000.0, 1030.0), 1), "hPa"
        elif sensor_type == SensorType.LIGHT:
            return round(random.uniform(0.0, 1000.0), 0), "lux"
        elif sensor_type == SensorType.MOTION:
            return random.choice([0, 1]), ""
        elif sensor_type == SensorType.SOUND:
            return round(random.uniform(30.0, 80.0), 1), "dB"
        elif sensor_type == SensorType.GAS:
            return round(random.uniform(0.0, 100.0), 1), "ppm"
        else:
            return 0.0, ""
    
    def get_status(self) -> Dict:
        """ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—"""
        return {
            "device_id": self.device_id,
            "name": self.name,
            "location": self.location,
            "is_connected": self.is_connected,
            "last_seen": self.last_seen.isoformat() if self.last_seen else None,
            "total_readings": len(self.readings_history)
        }

# å…·ä½“çš„ãªIoTãƒ‡ãƒã‚¤ã‚¹
class WeatherStation(IoTDevice):
    """æ°—è±¡è¦³æ¸¬ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³"""
    
    def __init__(self, device_id: str, location: str = ""):
        super().__init__(device_id, "æ°—è±¡è¦³æ¸¬ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³", location)
        self.supported_sensors = [
            SensorType.TEMPERATURE,
            SensorType.HUMIDITY, 
            SensorType.PRESSURE
        ]
    
    def read_all_sensors(self) -> List[SensorReading]:
        """å…¨ã‚»ãƒ³ã‚µãƒ¼ã®å€¤ã‚’èª­ã¿å–ã‚Š"""
        readings = []
        for sensor_type in self.supported_sensors:
            reading = self.read_sensor(sensor_type)
            if reading:
                readings.append(reading)
        return readings
    
    def get_weather_summary(self) -> Dict:
        """å¤©æ°—ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
        if not self.readings_history:
            return {"message": "ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“"}
        
        # æœ€æ–°ã®èª­ã¿å–ã‚Šå€¤ã‚’å–å¾—
        latest_readings = {}
        for reading in reversed(self.readings_history):
            if reading.sensor_type not in latest_readings:
                latest_readings[reading.sensor_type] = reading
            
            # å…¨ã‚»ãƒ³ã‚µãƒ¼ã®å€¤ãŒæƒã£ãŸã‚‰çµ‚äº†
            if len(latest_readings) == len(self.supported_sensors):
                break
        
        summary = {
            "location": self.location,
            "timestamp": datetime.now().isoformat(),
            "readings": {}
        }
        
        for sensor_type, reading in latest_readings.items():
            summary["readings"][sensor_type.value] = {
                "value": reading.value,
                "unit": reading.unit
            }
        
        return summary

class SmartHome(IoTDevice):
    """ã‚¹ãƒãƒ¼ãƒˆãƒ›ãƒ¼ãƒ ãƒ‡ãƒã‚¤ã‚¹"""
    
    def __init__(self, device_id: str, room: str = ""):
        super().__init__(device_id, "ã‚¹ãƒãƒ¼ãƒˆãƒ›ãƒ¼ãƒ ãƒãƒ–", room)
        self.room = room
        self.devices = {}
        self.automation_rules = []
    
    def add_device(self, device_name: str, device_type: str):
        """ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ """
        self.devices[device_name] = {
            "type": device_type,
            "status": "off",
            "last_updated": datetime.now()
        }
        print(f"ğŸ  ãƒ‡ãƒã‚¤ã‚¹è¿½åŠ : {device_name} ({device_type}) @ {self.room}")
    
    def control_device(self, device_name: str, command: str) -> bool:
        """ãƒ‡ãƒã‚¤ã‚¹ã‚’åˆ¶å¾¡"""
        if device_name not in self.devices:
            print(f"âŒ ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {device_name}")
            return False
        
        valid_commands = ["on", "off", "toggle", "dim", "bright"]
        if command not in valid_commands:
            print(f"âŒ ç„¡åŠ¹ãªã‚³ãƒãƒ³ãƒ‰: {command}")
            return False
        
        device = self.devices[device_name]
        
        if command == "on":
            device["status"] = "on"
        elif command == "off":
            device["status"] = "off"
        elif command == "toggle":
            device["status"] = "on" if device["status"] == "off" else "off"
        elif command in ["dim", "bright"]:
            device["status"] = command
        
        device["last_updated"] = datetime.now()
        
        print(f"ğŸ›ï¸ {device_name} ã‚’ {command} ã«è¨­å®šã—ã¾ã—ãŸ")
        return True
    
    def add_automation_rule(self, condition: str, action: str):
        """è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ """
        rule = {
            "id": len(self.automation_rules) + 1,
            "condition": condition,
            "action": action,
            "created_at": datetime.now(),
            "triggered_count": 0
        }
        self.automation_rules.append(rule)
        print(f"ğŸ¤– è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«è¿½åŠ : {condition} â†’ {action}")
    
    def check_automation(self, sensor_reading: SensorReading):
        """è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯"""
        for rule in self.automation_rules:
            if self._evaluate_condition(rule["condition"], sensor_reading):
                self._execute_action(rule["action"])
                rule["triggered_count"] += 1
                print(f"ğŸ¤– è‡ªå‹•åŒ–å®Ÿè¡Œ: {rule['condition']} â†’ {rule['action']}")
    
    def _evaluate_condition(self, condition: str, reading: SensorReading) -> bool:
        """æ¡ä»¶ã‚’è©•ä¾¡ï¼ˆç°¡ç•¥åŒ–ï¼‰"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã‚ˆã‚Šè¤‡é›‘ãªæ¡ä»¶è§£æãŒå¿…è¦
        if "æ¸©åº¦" in condition and reading.sensor_type == SensorType.TEMPERATURE:
            if "25åº¦ä»¥ä¸Š" in condition:
                return reading.value >= 25.0
            elif "20åº¦ä»¥ä¸‹" in condition:
                return reading.value <= 20.0
        elif "æ¹¿åº¦" in condition and reading.sensor_type == SensorType.HUMIDITY:
            if "70%ä»¥ä¸Š" in condition:
                return reading.value >= 70.0
        return False
    
    def _execute_action(self, action: str):
        """ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œï¼ˆç°¡ç•¥åŒ–ï¼‰"""
        if "ã‚¨ã‚¢ã‚³ãƒ³" in action:
            if "on" in action:
                self.control_device("ã‚¨ã‚¢ã‚³ãƒ³", "on")
            elif "off" in action:
                self.control_device("ã‚¨ã‚¢ã‚³ãƒ³", "off")
        elif "ç…§æ˜" in action:
            if "on" in action:
                self.control_device("ç…§æ˜", "on")
            elif "off" in action:
                self.control_device("ç…§æ˜", "off")

# IoTãƒ‡ãƒã‚¤ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
class IoTManager:
    """IoTãƒ‡ãƒã‚¤ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self):
        self.devices: Dict[str, IoTDevice] = {}
        self.data_storage: List[SensorReading] = []
        self.alerts = []
    
    def register_device(self, device: IoTDevice):
        """ãƒ‡ãƒã‚¤ã‚¹ã‚’ç™»éŒ²"""
        self.devices[device.device_id] = device
        print(f"ğŸ“± ãƒ‡ãƒã‚¤ã‚¹ç™»éŒ²: {device.name} ({device.device_id})")
    
    def connect_all_devices(self):
        """å…¨ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶š"""
        print("ğŸ”Œ å…¨ãƒ‡ãƒã‚¤ã‚¹æ¥ç¶šä¸­...")
        for device in self.devices.values():
            device.connect()
        print("âœ… å…¨ãƒ‡ãƒã‚¤ã‚¹æ¥ç¶šå®Œäº†")
    
    def collect_data_from_all(self):
        """å…¨ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿åé›†"""
        print("ğŸ“Š ãƒ‡ãƒ¼ã‚¿åé›†é–‹å§‹...")
        
        for device in self.devices.values():
            if device.is_connected:
                if isinstance(device, WeatherStation):
                    readings = device.read_all_sensors()
                    self.data_storage.extend(readings)
                else:
                    # åŸºæœ¬ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Š
                    reading = device.read_sensor(SensorType.TEMPERATURE)
                    if reading:
                        self.data_storage.append(reading)
        
        print(f"ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿åé›†å®Œäº†: {len(self.data_storage)}ä»¶")
    
    def get_device_summary(self) -> Dict:
        """ãƒ‡ãƒã‚¤ã‚¹ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
        connected = sum(1 for d in self.devices.values() if d.is_connected)
        total = len(self.devices)
        
        return {
            "total_devices": total,
            "connected_devices": connected,
            "total_readings": len(self.data_storage),
            "device_types": list(set(type(d).__name__ for d in self.devices.values()))
        }
    
    def export_data(self, filename: str):
        """ãƒ‡ãƒ¼ã‚¿ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        data = [reading.to_dict() for reading in self.data_storage]
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        print(f"ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†: {filename}")

# IoTã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¢
def demo_iot_system():
    """IoTã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¢"""
    print("=== IoTã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¢ ===")
    
    # IoTç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
    iot_manager = IoTManager()
    
    # æ°—è±¡è¦³æ¸¬ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
    weather_station = WeatherStation("WS001", "å±‹ä¸Š")
    iot_manager.register_device(weather_station)
    
    # ã‚¹ãƒãƒ¼ãƒˆãƒ›ãƒ¼ãƒ ãƒãƒ–ã‚’ä½œæˆ
    smart_home = SmartHome("SH001", "ãƒªãƒ“ãƒ³ã‚°")
    smart_home.add_device("ã‚¨ã‚¢ã‚³ãƒ³", "ç©ºèª¿")
    smart_home.add_device("ç…§æ˜", "ç…§æ˜")
    smart_home.add_device("æ‰‡é¢¨æ©Ÿ", "æ‰‡é¢¨æ©Ÿ")
    iot_manager.register_device(smart_home)
    
    # è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
    smart_home.add_automation_rule("æ¸©åº¦25åº¦ä»¥ä¸Š", "ã‚¨ã‚¢ã‚³ãƒ³on")
    smart_home.add_automation_rule("æ¹¿åº¦70%ä»¥ä¸Š", "æ‰‡é¢¨æ©Ÿon")
    
    # å…¨ãƒ‡ãƒã‚¤ã‚¹ã«æ¥ç¶š
    iot_manager.connect_all_devices()
    
    print(f"\n" + "="*50)
    print("ğŸ“Š ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿åé›†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³")
    
    # ãƒ‡ãƒ¼ã‚¿åé›†ã‚’è¤‡æ•°å›å®Ÿè¡Œ
    for cycle in range(3):
        print(f"\n--- ã‚µã‚¤ã‚¯ãƒ« {cycle + 1} ---")
        
        # æ°—è±¡ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚Š
        weather_readings = weather_station.read_all_sensors()
        
        # ã‚¹ãƒãƒ¼ãƒˆãƒ›ãƒ¼ãƒ åˆ¶å¾¡
        for reading in weather_readings:
            smart_home.check_automation(reading)
        
        # ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«ä¿å­˜
        iot_manager.data_storage.extend(weather_readings)
        
        # å¤©æ°—ã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º
        weather_summary = weather_station.get_weather_summary()
        print(f"ğŸŒ¤ï¸ æ°—è±¡æƒ…å ±: {weather_summary}")
        
        time.sleep(1)  # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®å¾…æ©Ÿ
    
    # ã‚·ã‚¹ãƒ†ãƒ ã‚µãƒãƒªãƒ¼
    print(f"\nğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ ã‚µãƒãƒªãƒ¼:")
    summary = iot_manager.get_device_summary()
    for key, value in summary.items():
        print(f"  {key}: {value}")

demo_iot_system()
```

## ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ã¨ã‚»ãƒ³ã‚µãƒ¼åˆ¶å¾¡

### Arduinoãƒ»Raspberry Pié€£æº

```{python}
import serial
import time
import threading
from queue import Queue
from typing import Callable, Optional

class SerialCommunicator:
    """ã‚·ãƒªã‚¢ãƒ«é€šä¿¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, port: str = "COM3", baudrate: int = 9600):
        self.port = port
        self.baudrate = baudrate
        self.serial_connection: Optional[serial.Serial] = None
        self.is_connected = False
        self.read_thread: Optional[threading.Thread] = None
        self.message_queue = Queue()
        self.callbacks = []
    
    def connect(self) -> bool:
        """ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã«æ¥ç¶š"""
        try:
            print(f"ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šä¸­: {self.port} @ {self.baudrate}")
            
            # å®Ÿéš›ã®ç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            # self.serial_connection = serial.Serial(self.port, self.baudrate, timeout=1)
            # self.is_connected = True
            
            # ãƒ‡ãƒ¢ç”¨ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            self.is_connected = True
            print(f"âœ… ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šæˆåŠŸ")
            
            # èª­ã¿å–ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹
            self.start_reading_thread()
            return True
            
        except Exception as e:
            print(f"âŒ ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def disconnect(self):
        """ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šã‚’åˆ‡æ–­"""
        self.is_connected = False
        
        if self.read_thread and self.read_thread.is_alive():
            self.read_thread.join(timeout=2)
        
        if self.serial_connection:
            self.serial_connection.close()
        
        print("ğŸ”Œ ã‚·ãƒªã‚¢ãƒ«æ¥ç¶šã‚’åˆ‡æ–­ã—ã¾ã—ãŸ")
    
    def send_command(self, command: str) -> bool:
        """ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡"""
        if not self.is_connected:
            print("âŒ ã‚·ãƒªã‚¢ãƒ«æœªæ¥ç¶š")
            return False
        
        try:
            # å®Ÿéš›ã®ç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            # self.serial_connection.write((command + '\n').encode())
            
            # ãƒ‡ãƒ¢ç”¨ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            print(f"ğŸ“¤ é€ä¿¡: {command}")
            
            # æ¨¡æ“¬å¿œç­”ã‚’ç”Ÿæˆ
            self._simulate_response(command)
            return True
            
        except Exception as e:
            print(f"âŒ é€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def _simulate_response(self, command: str):
        """æ¨¡æ“¬å¿œç­”ã‚’ç”Ÿæˆ"""
        if command.startswith("READ_SENSORS"):
            response = "TEMP:25.3,HUMID:65.2"
        elif command.startswith("LED_ON"):
            response = "LED:ON"
        elif command.startswith("LED_OFF"):
            response = "LED:OFF"
        elif command.startswith("MOTOR"):
            response = "MOTOR:RUNNING"
        else:
            response = "OK"
        
        # å¿œç­”ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        self.message_queue.put(response)
        
        # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å‘¼ã³å‡ºã—
        for callback in self.callbacks:
            callback(response)
    
    def start_reading_thread(self):
        """èª­ã¿å–ã‚Šã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹"""
        self.read_thread = threading.Thread(target=self._read_loop, daemon=True)
        self.read_thread.start()
    
    def _read_loop(self):
        """èª­ã¿å–ã‚Šãƒ«ãƒ¼ãƒ—"""
        while self.is_connected:
            try:
                # å®Ÿéš›ã®ç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
                # if self.serial_connection.in_waiting > 0:
                #     data = self.serial_connection.readline().decode().strip()
                #     self.message_queue.put(data)
                
                # ãƒ‡ãƒ¢ç”¨: å®šæœŸçš„ã«ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                time.sleep(2)
                if self.is_connected:
                    dummy_data = f"SENSOR_DATA:TEMP:{20 + time.time() % 10:.1f}"
                    self.message_queue.put(dummy_data)
                
            except Exception as e:
                print(f"âŒ èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {e}")
                break
    
    def add_callback(self, callback: Callable[[str], None]):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¿½åŠ """
        self.callbacks.append(callback)
    
    def get_messages(self) -> list:
        """å—ä¿¡ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—"""
        messages = []
        while not self.message_queue.empty():
            messages.append(self.message_queue.get())
        return messages

class ArduinoController:
    """Arduinoåˆ¶å¾¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, port: str = "COM3"):
        self.communicator = SerialCommunicator(port)
        self.sensor_data = {}
        self.led_status = False
        
        # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’è¨­å®š
        self.communicator.add_callback(self._handle_response)
    
    def connect(self) -> bool:
        """Arduinoã«æ¥ç¶š"""
        return self.communicator.connect()
    
    def disconnect(self):
        """Arduinoæ¥ç¶šã‚’åˆ‡æ–­"""
        self.communicator.disconnect()
    
    def _handle_response(self, response: str):
        """Arduinoå¿œç­”ã‚’å‡¦ç†"""
        print(f"ğŸ“¥ å—ä¿¡: {response}")
        
        if response.startswith("TEMP:"):
            # æ¸©åº¦ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
            parts = response.split(",")
            for part in parts:
                if "TEMP:" in part:
                    temp = float(part.split(":")[1])
                    self.sensor_data["temperature"] = temp
                elif "HUMID:" in part:
                    humid = float(part.split(":")[1])
                    self.sensor_data["humidity"] = humid
    
    def read_sensors(self) -> Dict:
        """ã‚»ãƒ³ã‚µãƒ¼å€¤ã‚’èª­ã¿å–ã‚Š"""
        self.communicator.send_command("READ_SENSORS")
        time.sleep(0.1)  # å¿œç­”å¾…æ©Ÿ
        return self.sensor_data.copy()
    
    def control_led(self, state: bool) -> bool:
        """LEDã‚’åˆ¶å¾¡"""
        command = "LED_ON" if state else "LED_OFF"
        success = self.communicator.send_command(command)
        
        if success:
            self.led_status = state
            print(f"ğŸ’¡ LED: {'ç‚¹ç¯' if state else 'æ¶ˆç¯'}")
        
        return success
    
    def control_motor(self, speed: int, direction: str = "forward") -> bool:
        """ãƒ¢ãƒ¼ã‚¿ãƒ¼ã‚’åˆ¶å¾¡"""
        command = f"MOTOR:{direction}:{speed}"
        success = self.communicator.send_command(command)
        
        if success:
            print(f"âš™ï¸ ãƒ¢ãƒ¼ã‚¿ãƒ¼: {direction} é€Ÿåº¦{speed}")
        
        return success
    
    def get_status(self) -> Dict:
        """ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—"""
        return {
            "connected": self.communicator.is_connected,
            "sensor_data": self.sensor_data,
            "led_status": self.led_status
        }

# Raspberry Pi GPIOåˆ¶å¾¡ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
class RaspberryPiController:
    """Raspberry Pi GPIOåˆ¶å¾¡ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.gpio_states = {}
        self.pwm_channels = {}
        print("ğŸ¥§ Raspberry Piåˆ¶å¾¡å™¨ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
    
    def setup_pin(self, pin: int, mode: str):
        """ãƒ”ãƒ³ã‚’è¨­å®š"""
        self.gpio_states[pin] = {"mode": mode, "value": 0}
        print(f"ğŸ“Œ GPIO{pin}ã‚’{mode}ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š")
    
    def digital_write(self, pin: int, value: int):
        """ãƒ‡ã‚¸ã‚¿ãƒ«å‡ºåŠ›"""
        if pin in self.gpio_states:
            self.gpio_states[pin]["value"] = value
            print(f"ğŸ“Œ GPIO{pin} = {value}")
        else:
            print(f"âŒ GPIO{pin}ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
    
    def digital_read(self, pin: int) -> int:
        """ãƒ‡ã‚¸ã‚¿ãƒ«å…¥åŠ›èª­ã¿å–ã‚Š"""
        if pin in self.gpio_states:
            # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒ©ãƒ³ãƒ€ãƒ å€¤
            value = random.choice([0, 1])
            print(f"ğŸ“Œ GPIO{pin}èª­ã¿å–ã‚Š: {value}")
            return value
        return 0
    
    def setup_pwm(self, pin: int, frequency: int):
        """PWMè¨­å®š"""
        self.pwm_channels[pin] = {"frequency": frequency, "duty_cycle": 0}
        print(f"ğŸŒŠ GPIO{pin}ã‚’PWM {frequency}Hzã«è¨­å®š")
    
    def set_pwm_duty_cycle(self, pin: int, duty_cycle: float):
        """PWMãƒ‡ãƒ¥ãƒ¼ãƒ†ã‚£ã‚µã‚¤ã‚¯ãƒ«è¨­å®š"""
        if pin in self.pwm_channels:
            self.pwm_channels[pin]["duty_cycle"] = duty_cycle
            print(f"ğŸŒŠ GPIO{pin} PWM: {duty_cycle}%")
        else:
            print(f"âŒ GPIO{pin}ã®PWMãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")

# ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡ãƒ‡ãƒ¢
def demo_hardware_control():
    """ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡ãƒ‡ãƒ¢"""
    print("=== ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡ãƒ‡ãƒ¢ ===")
    
    # Arduinoåˆ¶å¾¡ãƒ‡ãƒ¢
    print("ğŸ¤– Arduinoåˆ¶å¾¡ãƒ‡ãƒ¢")
    arduino = ArduinoController("COM3")
    
    if arduino.connect():
        print("\nğŸ“Š ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šãƒ†ã‚¹ãƒˆ:")
        for i in range(3):
            sensors = arduino.read_sensors()
            print(f"  ã‚µã‚¤ã‚¯ãƒ« {i+1}: {sensors}")
            time.sleep(1)
        
        print("\nğŸ’¡ LEDåˆ¶å¾¡ãƒ†ã‚¹ãƒˆ:")
        arduino.control_led(True)
        time.sleep(1)
        arduino.control_led(False)
        
        print("\nâš™ï¸ ãƒ¢ãƒ¼ã‚¿ãƒ¼åˆ¶å¾¡ãƒ†ã‚¹ãƒˆ:")
        arduino.control_motor(100, "forward")
        time.sleep(1)
        arduino.control_motor(50, "backward")
        
        # çŠ¶æ…‹ç¢ºèª
        status = arduino.get_status()
        print(f"\nğŸ“‹ ArduinoçŠ¶æ…‹: {status}")
        
        arduino.disconnect()
    
    print(f"\n" + "="*50)
    
    # Raspberry Piåˆ¶å¾¡ãƒ‡ãƒ¢
    print("ğŸ¥§ Raspberry Pi GPIOåˆ¶å¾¡ãƒ‡ãƒ¢")
    rpi = RaspberryPiController()
    
    # GPIOè¨­å®š
    rpi.setup_pin(18, "OUTPUT")  # LEDç”¨
    rpi.setup_pin(24, "INPUT")   # ã‚»ãƒ³ã‚µãƒ¼ç”¨
    rpi.setup_pin(12, "PWM")     # PWMç”¨
    
    # ãƒ‡ã‚¸ã‚¿ãƒ«å‡ºåŠ›ãƒ†ã‚¹ãƒˆ
    print("\nğŸ’¡ ãƒ‡ã‚¸ã‚¿ãƒ«å‡ºåŠ›ãƒ†ã‚¹ãƒˆ:")
    rpi.digital_write(18, 1)
    time.sleep(0.5)
    rpi.digital_write(18, 0)
    
    # ãƒ‡ã‚¸ã‚¿ãƒ«å…¥åŠ›ãƒ†ã‚¹ãƒˆ
    print("\nğŸ“¥ ãƒ‡ã‚¸ã‚¿ãƒ«å…¥åŠ›ãƒ†ã‚¹ãƒˆ:")
    for i in range(3):
        value = rpi.digital_read(24)
        print(f"  èª­ã¿å–ã‚Š {i+1}: {value}")
    
    # PWMåˆ¶å¾¡ãƒ†ã‚¹ãƒˆ
    print("\nğŸŒŠ PWMåˆ¶å¾¡ãƒ†ã‚¹ãƒˆ:")
    rpi.setup_pwm(12, 1000)  # 1kHz
    for duty in [0, 25, 50, 75, 100]:
        rpi.set_pwm_duty_cycle(12, duty)
        time.sleep(0.3)

demo_hardware_control()
```

## ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡ã¨ã‚¯ãƒ©ã‚¦ãƒ‰é€£æº

### MQTTé€šä¿¡ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹

```{python}
import json
import time
import threading
from datetime import datetime
from typing import Dict, List, Callable, Optional
import hashlib

class MQTTClient:
    """MQTTã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰"""
    
    def __init__(self, broker_host: str = "localhost", port: int = 1883):
        self.broker_host = broker_host
        self.port = port
        self.is_connected = False
        self.subscriptions = {}
        self.message_handlers = {}
        self.published_messages = []
    
    def connect(self, client_id: str, username: str = None, password: str = None) -> bool:
        """MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã«æ¥ç¶š"""
        try:
            print(f"ğŸŒ MQTTæ¥ç¶šä¸­: {client_id} @ {self.broker_host}:{self.port}")
            
            # å®Ÿéš›ã®ç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨:
            # import paho.mqtt.client as mqtt
            # self.client = mqtt.Client(client_id)
            # if username and password:
            #     self.client.username_pw_set(username, password)
            # self.client.connect(self.broker_host, self.port, 60)
            
            # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            self.client_id = client_id
            self.is_connected = True
            print(f"âœ… MQTTæ¥ç¶šæˆåŠŸ: {client_id}")
            return True
            
        except Exception as e:
            print(f"âŒ MQTTæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    def disconnect(self):
        """MQTTæ¥ç¶šã‚’åˆ‡æ–­"""
        self.is_connected = False
        print("ğŸŒ MQTTæ¥ç¶šã‚’åˆ‡æ–­ã—ã¾ã—ãŸ")
    
    def subscribe(self, topic: str, callback: Callable[[str, str], None]):
        """ãƒˆãƒ”ãƒƒã‚¯ã‚’ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–"""
        if not self.is_connected:
            print("âŒ MQTTæœªæ¥ç¶š")
            return False
        
        self.subscriptions[topic] = True
        self.message_handlers[topic] = callback
        print(f"ğŸ“¡ ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–: {topic}")
        return True
    
    def publish(self, topic: str, payload: str, qos: int = 0) -> bool:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç™ºè¡Œ"""
        if not self.is_connected:
            print("âŒ MQTTæœªæ¥ç¶š")
            return False
        
        message = {
            "topic": topic,
            "payload": payload,
            "qos": qos,
            "timestamp": datetime.now().isoformat()
        }
        
        self.published_messages.append(message)
        print(f"ğŸ“¤ ç™ºè¡Œ: {topic} -> {payload}")
        
        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: è‡ªåˆ†ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
        self._simulate_message_delivery(topic, payload)
        return True
    
    def _simulate_message_delivery(self, topic: str, payload: str):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ"""
        for subscribed_topic, callback in self.message_handlers.items():
            if self._topic_matches(subscribed_topic, topic):
                threading.Thread(
                    target=callback,
                    args=(topic, payload),
                    daemon=True
                ).start()
    
    def _topic_matches(self, pattern: str, topic: str) -> bool:
        """ãƒˆãƒ”ãƒƒã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°"""
        if pattern == topic:
            return True
        if pattern.endswith("#"):
            prefix = pattern[:-1]
            return topic.startswith(prefix)
        if "+" in pattern:
            # ç°¡ç•¥åŒ–ã—ãŸãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰å‡¦ç†
            return True
        return False

class IoTCloudPlatform:
    """IoTã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ """
    
    def __init__(self, platform_name: str = "IoT Platform"):
        self.platform_name = platform_name
        self.mqtt_client = MQTTClient()
        self.devices = {}
        self.telemetry_data = []
        self.alerts = []
        self.is_running = False
    
    def connect(self, client_id: str) -> bool:
        """ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«æ¥ç¶š"""
        success = self.mqtt_client.connect(client_id)
        if success:
            self._setup_subscriptions()
        return success
    
    def _setup_subscriptions(self):
        """ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®š"""
        # ãƒ‡ãƒã‚¤ã‚¹ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª
        self.mqtt_client.subscribe("devices/+/telemetry", self._handle_telemetry)
        
        # ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
        self.mqtt_client.subscribe("devices/+/status", self._handle_device_status)
        
        # ã‚¢ãƒ©ãƒ¼ãƒˆ
        self.mqtt_client.subscribe("devices/+/alert", self._handle_alert)
    
    def _handle_telemetry(self, topic: str, payload: str):
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†"""
        try:
            device_id = topic.split('/')[1]
            data = json.loads(payload)
            
            telemetry_record = {
                "device_id": device_id,
                "data": data,
                "timestamp": datetime.now().isoformat(),
                "topic": topic
            }
            
            self.telemetry_data.append(telemetry_record)
            print(f"ğŸ“Š ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªå—ä¿¡: {device_id} -> {data}")
            
            # ãƒ‡ãƒ¼ã‚¿åˆ†æã¨ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
            self._analyze_telemetry(telemetry_record)
            
        except Exception as e:
            print(f"âŒ ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _handle_device_status(self, topic: str, payload: str):
        """ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å‡¦ç†"""
        device_id = topic.split('/')[1]
        status = payload
        
        if device_id not in self.devices:
            self.devices[device_id] = {}
        
        self.devices[device_id]["status"] = status
        self.devices[device_id]["last_seen"] = datetime.now().isoformat()
        
        print(f"ğŸ“± ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {device_id} = {status}")
    
    def _handle_alert(self, topic: str, payload: str):
        """ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‡¦ç†"""
        try:
            device_id = topic.split('/')[1]
            alert_data = json.loads(payload)
            
            alert = {
                "device_id": device_id,
                "alert_data": alert_data,
                "timestamp": datetime.now().isoformat()
            }
            
            self.alerts.append(alert)
            print(f"ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆ: {device_id} -> {alert_data}")
            
        except Exception as e:
            print(f"âŒ ã‚¢ãƒ©ãƒ¼ãƒˆå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _analyze_telemetry(self, record: Dict):
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æ"""
        data = record["data"]
        device_id = record["device_id"]
        
        # æ¸©åº¦ã‚¢ãƒ©ãƒ¼ãƒˆ
        if "temperature" in data:
            temp = data["temperature"]
            if temp > 30:
                self._generate_alert(device_id, "high_temperature", 
                                   f"é«˜æ¸©è­¦å‘Š: {temp}Â°C")
            elif temp < 10:
                self._generate_alert(device_id, "low_temperature", 
                                   f"ä½æ¸©è­¦å‘Š: {temp}Â°C")
        
        # æ¹¿åº¦ã‚¢ãƒ©ãƒ¼ãƒˆ
        if "humidity" in data:
            humidity = data["humidity"]
            if humidity > 80:
                self._generate_alert(device_id, "high_humidity", 
                                   f"é«˜æ¹¿åº¦è­¦å‘Š: {humidity}%")
    
    def _generate_alert(self, device_id: str, alert_type: str, message: str):
        """ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ç”Ÿæˆ"""
        alert_payload = {
            "type": alert_type,
            "message": message,
            "severity": "warning",
            "timestamp": datetime.now().isoformat()
        }
        
        topic = f"alerts/{device_id}"
        self.mqtt_client.publish(topic, json.dumps(alert_payload))
    
    def send_command(self, device_id: str, command: Dict) -> bool:
        """ãƒ‡ãƒã‚¤ã‚¹ã«ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡"""
        topic = f"devices/{device_id}/commands"
        payload = json.dumps(command)
        return self.mqtt_client.publish(topic, payload)
    
    def get_device_data(self, device_id: str, hours: int = 24) -> List[Dict]:
        """ãƒ‡ãƒã‚¤ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—"""
        return [record for record in self.telemetry_data 
                if record["device_id"] == device_id]
    
    def get_platform_statistics(self) -> Dict:
        """ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ çµ±è¨ˆã‚’å–å¾—"""
        return {
            "total_devices": len(self.devices),
            "active_devices": len([d for d in self.devices.values() 
                                 if d.get("status") == "online"]),
            "total_telemetry_records": len(self.telemetry_data),
            "total_alerts": len(self.alerts),
            "recent_alerts": len([a for a in self.alerts 
                                if (datetime.now() - datetime.fromisoformat(a["timestamp"])).seconds < 3600])
        }

# IoTä»®æƒ³ãƒ‡ãƒã‚¤ã‚¹
class VirtualIoTDevice:
    """ä»®æƒ³IoTãƒ‡ãƒã‚¤ã‚¹"""
    
    def __init__(self, device_id: str, device_type: str):
        self.device_id = device_id
        self.device_type = device_type
        self.mqtt_client = MQTTClient()
        self.is_running = False
        self.telemetry_thread = None
    
    def connect_to_platform(self) -> bool:
        """ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«æ¥ç¶š"""
        success = self.mqtt_client.connect(f"device_{self.device_id}")
        if success:
            self._setup_command_subscription()
            self._send_status("online")
        return success
    
    def _setup_command_subscription(self):
        """ã‚³ãƒãƒ³ãƒ‰ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®š"""
        topic = f"devices/{self.device_id}/commands"
        self.mqtt_client.subscribe(topic, self._handle_command)
    
    def _handle_command(self, topic: str, payload: str):
        """ã‚³ãƒãƒ³ãƒ‰ã‚’å‡¦ç†"""
        try:
            command = json.loads(payload)
            print(f"ğŸ“¥ {self.device_id}: ã‚³ãƒãƒ³ãƒ‰å—ä¿¡ -> {command}")
            
            # ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            if command.get("action") == "reboot":
                print(f"ğŸ”„ {self.device_id}: å†èµ·å‹•ä¸­...")
            elif command.get("action") == "update_config":
                print(f"âš™ï¸ {self.device_id}: è¨­å®šæ›´æ–°ä¸­...")
            
        except Exception as e:
            print(f"âŒ ã‚³ãƒãƒ³ãƒ‰å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
    
    def start_telemetry(self, interval: int = 5):
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡ã‚’é–‹å§‹"""
        self.is_running = True
        self.telemetry_thread = threading.Thread(
            target=self._telemetry_loop,
            args=(interval,),
            daemon=True
        )
        self.telemetry_thread.start()
        print(f"ğŸ“Š {self.device_id}: ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡é–‹å§‹ ({interval}ç§’é–“éš”)")
    
    def stop_telemetry(self):
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡ã‚’åœæ­¢"""
        self.is_running = False
        self._send_status("offline")
        print(f"ğŸ“Š {self.device_id}: ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡åœæ­¢")
    
    def _telemetry_loop(self, interval: int):
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡ãƒ«ãƒ¼ãƒ—"""
        while self.is_running:
            telemetry_data = self._generate_telemetry()
            topic = f"devices/{self.device_id}/telemetry"
            payload = json.dumps(telemetry_data)
            
            self.mqtt_client.publish(topic, payload)
            time.sleep(interval)
    
    def _generate_telemetry(self) -> Dict:
        """ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ"""
        base_data = {
            "device_id": self.device_id,
            "device_type": self.device_type,
            "timestamp": datetime.now().isoformat()
        }
        
        if self.device_type == "weather_station":
            base_data.update({
                "temperature": round(random.uniform(15, 35), 1),
                "humidity": round(random.uniform(30, 90), 1),
                "pressure": round(random.uniform(1000, 1030), 1)
            })
        elif self.device_type == "air_quality":
            base_data.update({
                "pm25": round(random.uniform(10, 100), 1),
                "co2": round(random.uniform(400, 1000), 0),
                "temperature": round(random.uniform(18, 28), 1)
            })
        
        return base_data
    
    def _send_status(self, status: str):
        """ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’é€ä¿¡"""
        topic = f"devices/{self.device_id}/status"
        self.mqtt_client.publish(topic, status)

# ã‚¯ãƒ©ã‚¦ãƒ‰é€£æºãƒ‡ãƒ¢
def demo_cloud_connectivity():
    """ã‚¯ãƒ©ã‚¦ãƒ‰é€£æºãƒ‡ãƒ¢"""
    print("=== IoTã‚¯ãƒ©ã‚¦ãƒ‰é€£æºãƒ‡ãƒ¢ ===")
    
    # ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’èµ·å‹•
    platform = IoTCloudPlatform("ã‚¹ãƒãƒ¼ãƒˆã‚·ãƒ†ã‚£ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ")
    platform.connect("cloud_platform")
    
    print("\nğŸŒ ä»®æƒ³IoTãƒ‡ãƒã‚¤ã‚¹ä½œæˆãƒ»æ¥ç¶šä¸­...")
    
    # ä»®æƒ³ãƒ‡ãƒã‚¤ã‚¹ã‚’ä½œæˆ
    weather_device = VirtualIoTDevice("WS001", "weather_station")
    air_quality_device = VirtualIoTDevice("AQ001", "air_quality")
    
    # ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã«æ¥ç¶š
    weather_device.connect_to_platform()
    air_quality_device.connect_to_platform()
    
    # ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡ã‚’é–‹å§‹
    weather_device.start_telemetry(interval=3)
    air_quality_device.start_telemetry(interval=4)
    
    print("\nğŸ“Š ãƒ‡ãƒ¼ã‚¿åé›†ä¸­...")
    time.sleep(15)  # 15ç§’é–“ãƒ‡ãƒ¼ã‚¿åé›†
    
    # ãƒ‡ãƒã‚¤ã‚¹ã«ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡
    print("\nğŸ“¤ ãƒ‡ãƒã‚¤ã‚¹åˆ¶å¾¡ã‚³ãƒãƒ³ãƒ‰é€ä¿¡...")
    platform.send_command("WS001", {"action": "reboot", "reason": "scheduled_maintenance"})
    platform.send_command("AQ001", {"action": "update_config", "config": {"sample_rate": 60}})
    
    time.sleep(2)
    
    # çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
    print("\nğŸ“ˆ ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ çµ±è¨ˆ:")
    stats = platform.get_platform_statistics()
    for key, value in stats.items():
        print(f"  {key}: {value}")
    
    # ãƒ‡ãƒã‚¤ã‚¹åˆ¥ãƒ‡ãƒ¼ã‚¿ã‚µãƒãƒªãƒ¼
    print("\nğŸ“Š ãƒ‡ãƒã‚¤ã‚¹åˆ¥ãƒ‡ãƒ¼ã‚¿ã‚µãƒãƒªãƒ¼:")
    for device_id in ["WS001", "AQ001"]:
        device_data = platform.get_device_data(device_id)
        if device_data:
            latest = device_data[-1]["data"]
            print(f"  {device_id}: {latest}")
    
    # ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªé€ä¿¡ã‚’åœæ­¢
    weather_device.stop_telemetry()
    air_quality_device.stop_telemetry()
    
    platform.mqtt_client.disconnect()
    print("\nâœ… ãƒ‡ãƒ¢å®Œäº†")

demo_cloud_connectivity()
```

ã“ã®ç« ã§ã¯ã€Pythonã«ã‚ˆã‚‹IoTé–‹ç™ºã®åŸºæœ¬ã‹ã‚‰å®Ÿè·µçš„ãªå¿œç”¨ã¾ã§å­¦ç¿’ã—ã¾ã—ãŸã€‚ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®åé›†ã€ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åˆ¶å¾¡ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡ã€ã‚¯ãƒ©ã‚¦ãƒ‰é€£æºãªã©ã€IoTã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºã«å¿…è¦ãªæŠ€è¡“ã‚’ç·åˆçš„ã«ç¿’å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚